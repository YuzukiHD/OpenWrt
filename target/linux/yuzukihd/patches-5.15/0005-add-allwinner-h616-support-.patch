diff -Nuar -r --no-dereference linux-5.15.139/sound/soc/sunxi/Makefile linux/sound/soc/sunxi/Makefile
--- linux-5.15.139/sound/soc/sunxi/Makefile	2023-11-20 18:08:30.000000000 +0800
+++ linux/sound/soc/sunxi/Makefile	2024-01-03 16:06:25.935131000 +0800
@@ -1,8 +1,10 @@
 # SPDX-License-Identifier: GPL-2.0
+obj-$(CONFIG_SND_SUN8I_CODEC_ANALOG) += sun8i-codec-analog.o
 obj-$(CONFIG_SND_SUN4I_CODEC) += sun4i-codec.o
 obj-$(CONFIG_SND_SUN4I_I2S) += sun4i-i2s.o
 obj-$(CONFIG_SND_SUN4I_SPDIF) += sun4i-spdif.o
-obj-$(CONFIG_SND_SUN8I_CODEC_ANALOG) += sun8i-codec-analog.o
 obj-$(CONFIG_SND_SUN50I_CODEC_ANALOG) += sun50i-codec-analog.o
 obj-$(CONFIG_SND_SUN8I_CODEC) += sun8i-codec.o
 obj-$(CONFIG_SND_SUN8I_ADDA_PR_REGMAP) += sun8i-adda-pr-regmap.o
+obj-$(CONFIG_SND_SUN9I_HDMI_AUDIO) += sun9i-hdmi-audio.o
+obj-$(CONFIG_SND_AC100_CODEC) += ac100-codec.o
diff -Nuar -r --no-dereference linux-5.15.139/sound/soc/sunxi/sun4i-spdif.c linux/sound/soc/sunxi/sun4i-spdif.c
--- linux-5.15.139/sound/soc/sunxi/sun4i-spdif.c	2023-11-20 18:08:30.000000000 +0800
+++ linux/sound/soc/sunxi/sun4i-spdif.c	2024-01-03 16:06:25.935131000 +0800
@@ -175,6 +175,7 @@
 	unsigned int reg_dac_txdata;
 	bool has_reset;
 	unsigned int val_fctl_ftx;
+	unsigned int mclk_multiplier;
 };
 
 struct sun4i_spdif_dev {
@@ -311,6 +312,7 @@
 	default:
 		return -EINVAL;
 	}
+	mclk *= host->quirks->mclk_multiplier;
 
 	ret = clk_set_rate(host->spdif_clk, mclk);
 	if (ret < 0) {
@@ -345,6 +347,7 @@
 	default:
 		return -EINVAL;
 	}
+	mclk_div *= host->quirks->mclk_multiplier;
 
 	reg_val = 0;
 	reg_val |= SUN4I_SPDIF_TXCFG_ASS;
@@ -427,24 +430,28 @@
 static const struct sun4i_spdif_quirks sun4i_a10_spdif_quirks = {
 	.reg_dac_txdata	= SUN4I_SPDIF_TXFIFO,
 	.val_fctl_ftx   = SUN4I_SPDIF_FCTL_FTX,
+	.mclk_multiplier = 1,
 };
 
 static const struct sun4i_spdif_quirks sun6i_a31_spdif_quirks = {
 	.reg_dac_txdata	= SUN4I_SPDIF_TXFIFO,
 	.val_fctl_ftx   = SUN4I_SPDIF_FCTL_FTX,
 	.has_reset	= true,
+	.mclk_multiplier = 1,
 };
 
 static const struct sun4i_spdif_quirks sun8i_h3_spdif_quirks = {
 	.reg_dac_txdata	= SUN8I_SPDIF_TXFIFO,
 	.val_fctl_ftx   = SUN4I_SPDIF_FCTL_FTX,
 	.has_reset	= true,
+	.mclk_multiplier = 4,
 };
 
 static const struct sun4i_spdif_quirks sun50i_h6_spdif_quirks = {
 	.reg_dac_txdata = SUN8I_SPDIF_TXFIFO,
 	.val_fctl_ftx   = SUN50I_H6_SPDIF_FCTL_FTX,
 	.has_reset      = true,
+	.mclk_multiplier = 1,
 };
 
 static const struct of_device_id sun4i_spdif_of_match[] = {
diff -Nuar -r --no-dereference linux-5.15.139/sound/soc/sunxi/ac100-codec.c linux/sound/soc/sunxi/ac100-codec.c
--- linux-5.15.139/sound/soc/sunxi/ac100-codec.c	1970-01-01 08:00:00.000000000 +0800
+++ linux/sound/soc/sunxi/ac100-codec.c	2024-01-03 16:06:25.935131000 +0800
@@ -0,0 +1,1002 @@
+/*
+ * This driver supports the controls for X-Powers (Allwinner)
+ * AC100 audio codec. This codec is co-packaged with AXP81x PMICs.
+ *
+ * (C) Copyright 2020 Ondrej Jirman <megous@megous.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/pm_runtime.h>
+#include <linux/regmap.h>
+#include <linux/mfd/ac100.h>
+
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/tlv.h>
+#include <sound/soc-dapm.h>
+
+#define AC100_ADC_APC_CTRL_ADCR_EN_OFF                          15
+#define AC100_ADC_APC_CTRL_ADCR_EN_MASK                         BIT(15)
+#define AC100_ADC_APC_CTRL_ADCR_EN_DISABLED                     0
+#define AC100_ADC_APC_CTRL_ADCR_EN_ENABLED                      BIT(15)
+#define AC100_ADC_APC_CTRL_ADCR_GAIN_OFF                        12
+#define AC100_ADC_APC_CTRL_ADCR_GAIN(v)                         (((v) & 0x7) << 12)
+#define AC100_ADC_APC_CTRL_ADCL_EN_OFF                          11
+#define AC100_ADC_APC_CTRL_ADCL_EN_MASK                         BIT(11)
+#define AC100_ADC_APC_CTRL_ADCL_EN_DISABLED                     0
+#define AC100_ADC_APC_CTRL_ADCL_EN_ENABLED                      BIT(11)
+#define AC100_ADC_APC_CTRL_ADCL_GAIN_OFF                        8
+#define AC100_ADC_APC_CTRL_ADCL_GAIN(v)                         (((v) & 0x7) << 8)
+#define AC100_ADC_APC_CTRL_MBIAS_EN_OFF                         7
+#define AC100_ADC_APC_CTRL_MBIAS_EN_MASK                        BIT(7)
+#define AC100_ADC_APC_CTRL_MBIAS_EN_DISABLED                    0
+#define AC100_ADC_APC_CTRL_MBIAS_EN_ENABLED                     BIT(7)
+#define AC100_ADC_APC_CTRL_MMIC_BIAS_CHOPPER_EN_OFF             6
+#define AC100_ADC_APC_CTRL_MMIC_BIAS_CHOPPER_EN_MASK            BIT(6)
+#define AC100_ADC_APC_CTRL_MMIC_BIAS_CHOPPER_EN_DISABLED        0
+#define AC100_ADC_APC_CTRL_MMIC_BIAS_CHOPPER_EN_ENABLED         BIT(6)
+#define AC100_ADC_APC_CTRL_MMIC_BIAS_CHOPPER_CKS_OFF            4
+#define AC100_ADC_APC_CTRL_MMIC_BIAS_CHOPPER_CKS_MASK           GENMASK(5, 4)
+#define AC100_ADC_APC_CTRL_MMIC_BIAS_CHOPPER_CKS_250K           (0x0 << 4)
+#define AC100_ADC_APC_CTRL_MMIC_BIAS_CHOPPER_CKS_500K           (0x1 << 4)
+#define AC100_ADC_APC_CTRL_MMIC_BIAS_CHOPPER_CKS_1M             (0x2 << 4)
+#define AC100_ADC_APC_CTRL_MMIC_BIAS_CHOPPER_CKS_2M             (0x3 << 4)
+#define AC100_ADC_APC_CTRL_HBIAS_MODE_OFF                       2
+#define AC100_ADC_APC_CTRL_HBIAS_MODE_MASK                      BIT(2)
+#define AC100_ADC_APC_CTRL_HBIAS_MODE_LOAD                      0
+#define AC100_ADC_APC_CTRL_HBIAS_MODE_HBIAS_EN                  BIT(2)
+#define AC100_ADC_APC_CTRL_HBIAS_EN_OFF                         1
+#define AC100_ADC_APC_CTRL_HBIAS_EN_MASK                        BIT(1)
+#define AC100_ADC_APC_CTRL_HBIAS_EN_DISABLED                    0
+#define AC100_ADC_APC_CTRL_HBIAS_EN_ENABLED                     BIT(1)
+#define AC100_ADC_APC_CTRL_HBIAS_ADC_EN_OFF                     0
+#define AC100_ADC_APC_CTRL_HBIAS_ADC_EN_MASK                    BIT(0)
+#define AC100_ADC_APC_CTRL_HBIAS_ADC_EN_DISABLED                0
+#define AC100_ADC_APC_CTRL_HBIAS_ADC_EN_ENABLED                 BIT(0)
+
+#define AC100_ADC_SRC_ADCR_MIC1_BOOST_OFF                       13
+#define AC100_ADC_SRC_ADCR_MIC1_BOOST_MASK                      BIT(13)
+#define AC100_ADC_SRC_ADCR_MIC1_BOOST_DISABLED                  0
+#define AC100_ADC_SRC_ADCR_MIC1_BOOST_ENABLED                   BIT(13)
+#define AC100_ADC_SRC_ADCR_MIC2_BOOST_OFF                       12
+#define AC100_ADC_SRC_ADCR_MIC2_BOOST_MASK                      BIT(12)
+#define AC100_ADC_SRC_ADCR_MIC2_BOOST_DISABLED                  0
+#define AC100_ADC_SRC_ADCR_MIC2_BOOST_ENABLED                   BIT(12)
+#define AC100_ADC_SRC_ADCR_LINEINL_LINEINR_OFF                  11
+#define AC100_ADC_SRC_ADCR_LINEINL_LINEINR_MASK                 BIT(11)
+#define AC100_ADC_SRC_ADCR_LINEINL_LINEINR_DISABLED             0
+#define AC100_ADC_SRC_ADCR_LINEINL_LINEINR_ENABLED              BIT(11)
+#define AC100_ADC_SRC_ADCR_LINEINR_OFF                          10
+#define AC100_ADC_SRC_ADCR_LINEINR_MASK                         BIT(10)
+#define AC100_ADC_SRC_ADCR_LINEINR_DISABLED                     0
+#define AC100_ADC_SRC_ADCR_LINEINR_ENABLED                      BIT(10)
+#define AC100_ADC_SRC_ADCR_AUXINR_OFF                           9
+#define AC100_ADC_SRC_ADCR_AUXINR_MASK                          BIT(9)
+#define AC100_ADC_SRC_ADCR_AUXINR_DISABLED                      0
+#define AC100_ADC_SRC_ADCR_AUXINR_ENABLED                       BIT(9)
+#define AC100_ADC_SRC_ADCR_ROUTMIX_OFF                          8
+#define AC100_ADC_SRC_ADCR_ROUTMIX_MASK                         BIT(8)
+#define AC100_ADC_SRC_ADCR_ROUTMIX_DISABLED                     0
+#define AC100_ADC_SRC_ADCR_ROUTMIX_ENABLED                      BIT(8)
+#define AC100_ADC_SRC_ADCR_LOUTMIX_OFF                          7
+#define AC100_ADC_SRC_ADCR_LOUTMIX_MASK                         BIT(7)
+#define AC100_ADC_SRC_ADCR_LOUTMIX_DISABLED                     0
+#define AC100_ADC_SRC_ADCR_LOUTMIX_ENABLED                      BIT(7)
+#define AC100_ADC_SRC_ADCL_MIC1_BOOST_OFF                       6
+#define AC100_ADC_SRC_ADCL_MIC1_BOOST_MASK                      BIT(6)
+#define AC100_ADC_SRC_ADCL_MIC1_BOOST_DISABLED                  0
+#define AC100_ADC_SRC_ADCL_MIC1_BOOST_ENABLED                   BIT(6)
+#define AC100_ADC_SRC_ADCL_MIC2_BOOST_OFF                       5
+#define AC100_ADC_SRC_ADCL_MIC2_BOOST_MASK                      BIT(5)
+#define AC100_ADC_SRC_ADCL_MIC2_BOOST_DISABLED                  0
+#define AC100_ADC_SRC_ADCL_MIC2_BOOST_ENABLED                   BIT(5)
+#define AC100_ADC_SRC_ADCL_LINEINL_LINEINR_OFF                  4
+#define AC100_ADC_SRC_ADCL_LINEINL_LINEINR_MASK                 BIT(4)
+#define AC100_ADC_SRC_ADCL_LINEINL_LINEINR_DISABLED             0
+#define AC100_ADC_SRC_ADCL_LINEINL_LINEINR_ENABLED              BIT(4)
+#define AC100_ADC_SRC_ADCL_LINEINL_OFF                          3
+#define AC100_ADC_SRC_ADCL_LINEINL_MASK                         BIT(3)
+#define AC100_ADC_SRC_ADCL_LINEINL_DISABLED                     0
+#define AC100_ADC_SRC_ADCL_LINEINL_ENABLED                      BIT(3)
+#define AC100_ADC_SRC_ADCL_AUXINL_OFF                           2
+#define AC100_ADC_SRC_ADCL_AUXINL_MASK                          BIT(2)
+#define AC100_ADC_SRC_ADCL_AUXINL_DISABLED                      0
+#define AC100_ADC_SRC_ADCL_AUXINL_ENABLED                       BIT(2)
+#define AC100_ADC_SRC_ADCL_LOUTMIX_OFF                          1
+#define AC100_ADC_SRC_ADCL_LOUTMIX_MASK                         BIT(1)
+#define AC100_ADC_SRC_ADCL_LOUTMIX_DISABLED                     0
+#define AC100_ADC_SRC_ADCL_LOUTMIX_ENABLED                      BIT(1)
+#define AC100_ADC_SRC_ADCL_ROUTMIX_OFF                          0
+#define AC100_ADC_SRC_ADCL_ROUTMIX_MASK                         BIT(0)
+#define AC100_ADC_SRC_ADCL_ROUTMIX_DISABLED                     0
+#define AC100_ADC_SRC_ADCL_ROUTMIX_ENABLED                      BIT(0)
+
+#define AC100_ADC_SRC_BST_CTRL_MIC1AMPEN_OFF                    15
+#define AC100_ADC_SRC_BST_CTRL_MIC1AMPEN_MASK                   BIT(15)
+#define AC100_ADC_SRC_BST_CTRL_MIC1AMPEN_DISABLED               0
+#define AC100_ADC_SRC_BST_CTRL_MIC1AMPEN_ENABLED                BIT(15)
+#define AC100_ADC_SRC_BST_CTRL_MIC1BOOST_OFF                    12
+#define AC100_ADC_SRC_BST_CTRL_MIC1BOOST(v)                     (((v) & 0x7) << 12)
+#define AC100_ADC_SRC_BST_CTRL_MIC2AMPEN_OFF                    11
+#define AC100_ADC_SRC_BST_CTRL_MIC2AMPEN_MASK                   BIT(11)
+#define AC100_ADC_SRC_BST_CTRL_MIC2AMPEN_DISABLED               0
+#define AC100_ADC_SRC_BST_CTRL_MIC2AMPEN_ENABLED                BIT(11)
+#define AC100_ADC_SRC_BST_CTRL_MIC2BOOST_OFF                    8
+#define AC100_ADC_SRC_BST_CTRL_MIC2BOOST(v)                     (((v) & 0x7) << 8)
+#define AC100_ADC_SRC_BST_CTRL_MIC2SLT_OFF                      7
+#define AC100_ADC_SRC_BST_CTRL_MIC2SLT_MASK                     BIT(7)
+#define AC100_ADC_SRC_BST_CTRL_MIC2SLT_MIC2                     0
+#define AC100_ADC_SRC_BST_CTRL_MIC2SLT_MIC3                     BIT(7)
+#define AC100_ADC_SRC_BST_CTRL_LINEIN_DIFF_PREG_OFF             4
+#define AC100_ADC_SRC_BST_CTRL_LINEIN_DIFF_PREG(v)              (((v) & 0x7) << 4)
+#define AC100_ADC_SRC_BST_CTRL_AXI_PREG_OFF                     0
+#define AC100_ADC_SRC_BST_CTRL_AXI_PREG(v)                      ((v) & 0x7)
+
+#define AC100_OUT_MXR_DAC_A_CTRL_DAC_AR_EN_OFF                  15
+#define AC100_OUT_MXR_DAC_A_CTRL_DAC_AR_EN_MASK                 BIT(15)
+#define AC100_OUT_MXR_DAC_A_CTRL_DAC_AR_EN_DISABLED             0
+#define AC100_OUT_MXR_DAC_A_CTRL_DAC_AR_EN_ENABLED              BIT(15)
+#define AC100_OUT_MXR_DAC_A_CTRL_DAC_AL_EN_OFF                  14
+#define AC100_OUT_MXR_DAC_A_CTRL_DAC_AL_EN_MASK                 BIT(14)
+#define AC100_OUT_MXR_DAC_A_CTRL_DAC_AL_EN_DISABLED             0
+#define AC100_OUT_MXR_DAC_A_CTRL_DAC_AL_EN_ENABLED              BIT(14)
+#define AC100_OUT_MXR_DAC_A_CTRL_AR_MIX_EN_OFF                  13
+#define AC100_OUT_MXR_DAC_A_CTRL_AR_MIX_EN_MASK                 BIT(13)
+#define AC100_OUT_MXR_DAC_A_CTRL_AR_MIX_EN_DISABLED             0
+#define AC100_OUT_MXR_DAC_A_CTRL_AR_MIX_EN_ENABLED              BIT(13)
+#define AC100_OUT_MXR_DAC_A_CTRL_AL_MIX_EN_OFF                  12
+#define AC100_OUT_MXR_DAC_A_CTRL_AL_MIX_EN_MASK                 BIT(12)
+#define AC100_OUT_MXR_DAC_A_CTRL_AL_MIX_EN_DISABLED             0
+#define AC100_OUT_MXR_DAC_A_CTRL_AL_MIX_EN_ENABLED              BIT(12)
+#define AC100_OUT_MXR_DAC_A_CTRL_HP_DCRM_EN_OFF                 8
+#define AC100_OUT_MXR_DAC_A_CTRL_HP_DCRM_EN(v)                  (((v) & 0xf) << 8)
+
+#define AC100_OUT_MXR_SRC_RMIX_MIC1_BOOST_OFF                   13
+#define AC100_OUT_MXR_SRC_RMIX_MIC1_BOOST_MASK                  BIT(13)
+#define AC100_OUT_MXR_SRC_RMIX_MIC1_BOOST_DISABLED              0
+#define AC100_OUT_MXR_SRC_RMIX_MIC1_BOOST_ENABLED               BIT(13)
+#define AC100_OUT_MXR_SRC_RMIX_MIC2_BOOST_OFF                   12
+#define AC100_OUT_MXR_SRC_RMIX_MIC2_BOOST_MASK                  BIT(12)
+#define AC100_OUT_MXR_SRC_RMIX_MIC2_BOOST_DISABLED              0
+#define AC100_OUT_MXR_SRC_RMIX_MIC2_BOOST_ENABLED               BIT(12)
+#define AC100_OUT_MXR_SRC_RMIX_LINEINL_LINEINR_OFF              11
+#define AC100_OUT_MXR_SRC_RMIX_LINEINL_LINEINR_MASK             BIT(11)
+#define AC100_OUT_MXR_SRC_RMIX_LINEINL_LINEINR_DISABLED         0
+#define AC100_OUT_MXR_SRC_RMIX_LINEINL_LINEINR_ENABLED          BIT(11)
+#define AC100_OUT_MXR_SRC_RMIX_LINEINR_OFF                      10
+#define AC100_OUT_MXR_SRC_RMIX_LINEINR_MASK                     BIT(10)
+#define AC100_OUT_MXR_SRC_RMIX_LINEINR_DISABLED                 0
+#define AC100_OUT_MXR_SRC_RMIX_LINEINR_ENABLED                  BIT(10)
+#define AC100_OUT_MXR_SRC_RMIX_AUXINR_OFF                       9
+#define AC100_OUT_MXR_SRC_RMIX_AUXINR_MASK                      BIT(9)
+#define AC100_OUT_MXR_SRC_RMIX_AUXINR_DISABLED                  0
+#define AC100_OUT_MXR_SRC_RMIX_AUXINR_ENABLED                   BIT(9)
+#define AC100_OUT_MXR_SRC_RMIX_DACR_OFF                         8
+#define AC100_OUT_MXR_SRC_RMIX_DACR_MASK                        BIT(8)
+#define AC100_OUT_MXR_SRC_RMIX_DACR_DISABLED                    0
+#define AC100_OUT_MXR_SRC_RMIX_DACR_ENABLED                     BIT(8)
+#define AC100_OUT_MXR_SRC_RMIX_DACL_OFF                         7
+#define AC100_OUT_MXR_SRC_RMIX_DACL_MASK                        BIT(7)
+#define AC100_OUT_MXR_SRC_RMIX_DACL_DISABLED                    0
+#define AC100_OUT_MXR_SRC_RMIX_DACL_ENABLED                     BIT(7)
+#define AC100_OUT_MXR_SRC_LMIX_MIC1_BOOST_OFF                   6
+#define AC100_OUT_MXR_SRC_LMIX_MIC1_BOOST_MASK                  BIT(6)
+#define AC100_OUT_MXR_SRC_LMIX_MIC1_BOOST_DISABLED              0
+#define AC100_OUT_MXR_SRC_LMIX_MIC1_BOOST_ENABLED               BIT(6)
+#define AC100_OUT_MXR_SRC_LMIX_MIC2_BOOST_OFF                   5
+#define AC100_OUT_MXR_SRC_LMIX_MIC2_BOOST_MASK                  BIT(5)
+#define AC100_OUT_MXR_SRC_LMIX_MIC2_BOOST_DISABLED              0
+#define AC100_OUT_MXR_SRC_LMIX_MIC2_BOOST_ENABLED               BIT(5)
+#define AC100_OUT_MXR_SRC_LMIX_LINEINL_LINEINR_OFF              4
+#define AC100_OUT_MXR_SRC_LMIX_LINEINL_LINEINR_MASK             BIT(4)
+#define AC100_OUT_MXR_SRC_LMIX_LINEINL_LINEINR_DISABLED         0
+#define AC100_OUT_MXR_SRC_LMIX_LINEINL_LINEINR_ENABLED          BIT(4)
+#define AC100_OUT_MXR_SRC_LMIX_LINEINL_OFF                      3
+#define AC100_OUT_MXR_SRC_LMIX_LINEINL_MASK                     BIT(3)
+#define AC100_OUT_MXR_SRC_LMIX_LINEINL_DISABLED                 0
+#define AC100_OUT_MXR_SRC_LMIX_LINEINL_ENABLED                  BIT(3)
+#define AC100_OUT_MXR_SRC_LMIX_AUXINL_OFF                       2
+#define AC100_OUT_MXR_SRC_LMIX_AUXINL_MASK                      BIT(2)
+#define AC100_OUT_MXR_SRC_LMIX_AUXINL_DISABLED                  0
+#define AC100_OUT_MXR_SRC_LMIX_AUXINL_ENABLED                   BIT(2)
+#define AC100_OUT_MXR_SRC_LMIX_DACL_OFF                         1
+#define AC100_OUT_MXR_SRC_LMIX_DACL_MASK                        BIT(1)
+#define AC100_OUT_MXR_SRC_LMIX_DACL_DISABLED                    0
+#define AC100_OUT_MXR_SRC_LMIX_DACL_ENABLED                     BIT(1)
+#define AC100_OUT_MXR_SRC_LMIX_DACR_OFF                         0
+#define AC100_OUT_MXR_SRC_LMIX_DACR_MASK                        BIT(0)
+#define AC100_OUT_MXR_SRC_LMIX_DACR_DISABLED                    0
+#define AC100_OUT_MXR_SRC_LMIX_DACR_ENABLED                     BIT(0)
+
+#define AC100_OUT_MXR_SRC_BST_HMICBIAS_VOLTAGE_OFF              14
+#define AC100_OUT_MXR_SRC_BST_HMICBIAS_VOLTAGE_MASK             GENMASK(15, 14)
+#define AC100_OUT_MXR_SRC_BST_HMICBIAS_VOLTAGE_1_88V            (0x0 << 14)
+#define AC100_OUT_MXR_SRC_BST_HMICBIAS_VOLTAGE_2_09V            (0x1 << 14)
+#define AC100_OUT_MXR_SRC_BST_HMICBIAS_VOLTAGE_2_33V            (0x2 << 14)
+#define AC100_OUT_MXR_SRC_BST_HMICBIAS_VOLTAGE_2_50V            (0x3 << 14)
+#define AC100_OUT_MXR_SRC_BST_MMICBIAS_VOLTAGE_OFF              12
+#define AC100_OUT_MXR_SRC_BST_MMICBIAS_VOLTAGE_MASK             GENMASK(13, 12)
+#define AC100_OUT_MXR_SRC_BST_MMICBIAS_VOLTAGE_1_88V            (0x0 << 12)
+#define AC100_OUT_MXR_SRC_BST_MMICBIAS_VOLTAGE_2_09V            (0x1 << 12)
+#define AC100_OUT_MXR_SRC_BST_MMICBIAS_VOLTAGE_2_33V            (0x2 << 12)
+#define AC100_OUT_MXR_SRC_BST_MMICBIAS_VOLTAGE_2_50V            (0x3 << 12)
+#define AC100_OUT_MXR_SRC_BST_AX_GAIN_OFF                       9
+#define AC100_OUT_MXR_SRC_BST_AX_GAIN(v)                        (((v) & 0x7) << 9)
+#define AC100_OUT_MXR_SRC_BST_MIC1_GAIN_OFF                     6
+#define AC100_OUT_MXR_SRC_BST_MIC1_GAIN(v)                      (((v) & 0x7) << 6)
+#define AC100_OUT_MXR_SRC_BST_MIC2_GAIN_OFF                     3
+#define AC100_OUT_MXR_SRC_BST_MIC2_GAIN(v)                      (((v) & 0x7) << 3)
+#define AC100_OUT_MXR_SRC_BST_LINEIN_GAIN_OFF                   0
+#define AC100_OUT_MXR_SRC_BST_LINEIN_GAIN(v)                    ((v) & 0x7)
+
+#define AC100_HPOUT_CTRL_RIGHT_SRC_OFF                          15
+#define AC100_HPOUT_CTRL_RIGHT_SRC_MASK                         BIT(15)
+#define AC100_HPOUT_CTRL_RIGHT_SRC_DACR                         0
+#define AC100_HPOUT_CTRL_RIGHT_SRC_RAMIX                        BIT(15)
+#define AC100_HPOUT_CTRL_LEFT_SRC_OFF                           14
+#define AC100_HPOUT_CTRL_LEFT_SRC_MASK                          BIT(14)
+#define AC100_HPOUT_CTRL_LEFT_SRC_DACL                          0
+#define AC100_HPOUT_CTRL_LEFT_SRC_LAMIX                         BIT(14)
+#define AC100_HPOUT_CTRL_RIGHT_PA_MUTE_OFF                      13
+#define AC100_HPOUT_CTRL_RIGHT_PA_MUTE_MASK                     BIT(13)
+#define AC100_HPOUT_CTRL_RIGHT_PA_MUTE_MUTE                     0
+#define AC100_HPOUT_CTRL_RIGHT_PA_MUTE_NOT_MUTE                 BIT(13)
+#define AC100_HPOUT_CTRL_LEFT_PA_MUTE_OFF                       12
+#define AC100_HPOUT_CTRL_LEFT_PA_MUTE_MASK                      BIT(12)
+#define AC100_HPOUT_CTRL_LEFT_PA_MUTE_MUTE                      0
+#define AC100_HPOUT_CTRL_LEFT_PA_MUTE_NOT_MUTE                  BIT(12)
+#define AC100_HPOUT_CTRL_PA_EN_OFF                              11
+#define AC100_HPOUT_CTRL_PA_EN_MASK                             BIT(11)
+#define AC100_HPOUT_CTRL_PA_EN_DISABLED                         0
+#define AC100_HPOUT_CTRL_PA_EN_ENABLED                          BIT(11)
+#define AC100_HPOUT_CTRL_VOLUME_OFF                             4
+#define AC100_HPOUT_CTRL_VOLUME(v)                              (((v) & 0x3f) << 4)
+#define AC100_HPOUT_CTRL_STARTUP_DELAY_OFF                      2
+#define AC100_HPOUT_CTRL_STARTUP_DELAY_MASK                     GENMASK(3, 2)
+#define AC100_HPOUT_CTRL_STARTUP_DELAY_4ms                      (0x0 << 2)
+#define AC100_HPOUT_CTRL_STARTUP_DELAY_8ms                      (0x1 << 2)
+#define AC100_HPOUT_CTRL_STARTUP_DELAY_16ms                     (0x2 << 2)
+#define AC100_HPOUT_CTRL_STARTUP_DELAY_32ms                     (0x3 << 2)
+#define AC100_HPOUT_CTRL_OUTPUT_CURRENT_OFF                     0
+#define AC100_HPOUT_CTRL_OUTPUT_CURRENT(v)                      ((v) & 0x3)
+
+#define AC100_ERPOUT_CTRL_RAMP_TIME_OFF                         11
+#define AC100_ERPOUT_CTRL_RAMP_TIME_MASK                        GENMASK(12, 11)
+#define AC100_ERPOUT_CTRL_RAMP_TIME_256ms                       (0x0 << 11)
+#define AC100_ERPOUT_CTRL_RAMP_TIME_512ms                       (0x1 << 11)
+#define AC100_ERPOUT_CTRL_RAMP_TIME_640ms                       (0x2 << 11)
+#define AC100_ERPOUT_CTRL_RAMP_TIME_768ms                       (0x3 << 11)
+#define AC100_ERPOUT_CTRL_OUT_CURRENT_OFF                       9
+#define AC100_ERPOUT_CTRL_OUT_CURRENT(v)                        (((v) & 0x3) << 9)
+#define AC100_ERPOUT_CTRL_INPUT_SOURCE_OFF                      7
+#define AC100_ERPOUT_CTRL_INPUT_SOURCE_MASK                     GENMASK(8, 7)
+#define AC100_ERPOUT_CTRL_INPUT_SOURCE_DACR                     (0x0 << 7)
+#define AC100_ERPOUT_CTRL_INPUT_SOURCE_DACL                     (0x1 << 7)
+#define AC100_ERPOUT_CTRL_INPUT_SOURCE_RAMIX                    (0x2 << 7)
+#define AC100_ERPOUT_CTRL_INPUT_SOURCE_LAMIX                    (0x3 << 7)
+#define AC100_ERPOUT_CTRL_MUTE_OFF                              6
+#define AC100_ERPOUT_CTRL_MUTE_MASK                             BIT(6)
+#define AC100_ERPOUT_CTRL_MUTE_MUTE                             0
+#define AC100_ERPOUT_CTRL_MUTE_NOT_MUTE                         BIT(6)
+#define AC100_ERPOUT_CTRL_PA_EN_OFF                             5
+#define AC100_ERPOUT_CTRL_PA_EN_MASK                            BIT(5)
+#define AC100_ERPOUT_CTRL_PA_EN_DISABLED                        0
+#define AC100_ERPOUT_CTRL_PA_EN_ENABLED                         BIT(5)
+#define AC100_ERPOUT_CTRL_VOLUME_OFF                            0
+#define AC100_ERPOUT_CTRL_VOLUME(v)                             ((v) & 0x1f)
+
+#define AC100_SPKOUT_CTRL_RIGHT_SRC_OFF                         12
+#define AC100_SPKOUT_CTRL_RIGHT_SRC_MASK                        BIT(12)
+#define AC100_SPKOUT_CTRL_RIGHT_SRC_MIXR                        0
+#define AC100_SPKOUT_CTRL_RIGHT_SRC_MIXL_MIXR                   BIT(12)
+#define AC100_SPKOUT_CTRL_RIGHT_INV_EN_OFF                      11
+#define AC100_SPKOUT_CTRL_RIGHT_INV_EN_MASK                     BIT(11)
+#define AC100_SPKOUT_CTRL_RIGHT_INV_EN_DISABLED                 0
+#define AC100_SPKOUT_CTRL_RIGHT_INV_EN_ENABLED                  BIT(11)
+#define AC100_SPKOUT_CTRL_RIGHT_EN_OFF                          9
+#define AC100_SPKOUT_CTRL_RIGHT_EN_MASK                         BIT(9)
+#define AC100_SPKOUT_CTRL_RIGHT_EN_DISABLED                     0
+#define AC100_SPKOUT_CTRL_RIGHT_EN_ENABLED                      BIT(9)
+#define AC100_SPKOUT_CTRL_LEFT_SRC_OFF                          8
+#define AC100_SPKOUT_CTRL_LEFT_SRC_MASK                         BIT(8)
+#define AC100_SPKOUT_CTRL_LEFT_SRC_MIXL                         0
+#define AC100_SPKOUT_CTRL_LEFT_SRC_MIXL_MIXR                    BIT(8)
+#define AC100_SPKOUT_CTRL_LEFT_INV_EN_OFF                       7
+#define AC100_SPKOUT_CTRL_LEFT_INV_EN_MASK                      BIT(7)
+#define AC100_SPKOUT_CTRL_LEFT_INV_EN_DISABLED                  0
+#define AC100_SPKOUT_CTRL_LEFT_INV_EN_ENABLED                   BIT(7)
+#define AC100_SPKOUT_CTRL_LEFT_EN_OFF                           5
+#define AC100_SPKOUT_CTRL_LEFT_EN_MASK                          BIT(5)
+#define AC100_SPKOUT_CTRL_LEFT_EN_DISABLED                      0
+#define AC100_SPKOUT_CTRL_LEFT_EN_ENABLED                       BIT(5)
+#define AC100_SPKOUT_CTRL_VOLUME_OFF                            0
+#define AC100_SPKOUT_CTRL_VOLUME(v)                             ((v) & 0x1f)
+
+#define AC100_LINEOUT_CTRL_LINEOUT_GAIN_OFF                     5
+#define AC100_LINEOUT_CTRL_LINEOUT_GAIN(v)                      (((v) & 0x7) << 5)
+#define AC100_LINEOUT_CTRL_LINEOUT_EN_OFF                       4
+#define AC100_LINEOUT_CTRL_LINEOUT_EN_MASK                      BIT(4)
+#define AC100_LINEOUT_CTRL_LINEOUT_EN_DISABLED                  0
+#define AC100_LINEOUT_CTRL_LINEOUT_EN_ENABLED                   BIT(4)
+#define AC100_LINEOUT_CTRL_LINEOUT_S0_OFF                       3
+#define AC100_LINEOUT_CTRL_LINEOUT_S0_MASK                      BIT(3)
+#define AC100_LINEOUT_CTRL_LINEOUT_S0_MUTE                      0
+#define AC100_LINEOUT_CTRL_LINEOUT_S0_ON                        BIT(3)
+#define AC100_LINEOUT_CTRL_LINEOUT_S1_OFF                       2
+#define AC100_LINEOUT_CTRL_LINEOUT_S1_MASK                      BIT(2)
+#define AC100_LINEOUT_CTRL_LINEOUT_S1_MUTE                      0
+#define AC100_LINEOUT_CTRL_LINEOUT_S1_ON                        BIT(2)
+#define AC100_LINEOUT_CTRL_LINEOUT_S2_OFF                       1
+#define AC100_LINEOUT_CTRL_LINEOUT_S2_MASK                      BIT(1)
+#define AC100_LINEOUT_CTRL_LINEOUT_S2_MUTE                      0
+#define AC100_LINEOUT_CTRL_LINEOUT_S2_ON                        BIT(1)
+#define AC100_LINEOUT_CTRL_LINEOUT_S3_OFF                       0
+#define AC100_LINEOUT_CTRL_LINEOUT_S3_MASK                      BIT(0)
+#define AC100_LINEOUT_CTRL_LINEOUT_S3_MUTE                      0
+#define AC100_LINEOUT_CTRL_LINEOUT_S3_ON                        BIT(0)
+
+#define AC100_ADDA_TUNE1_ZERO_CROSSOVER_EN_OFF                  8
+#define AC100_ADDA_TUNE1_ZERO_CROSSOVER_EN_MASK                 BIT(8)
+#define AC100_ADDA_TUNE1_ZERO_CROSSOVER_EN_DIS                  0
+#define AC100_ADDA_TUNE1_ZERO_CROSSOVER_EN_EN                   BIT(8)
+#define AC100_ADDA_TUNE1_ZERO_CROSSOVER_TIME_OFF                7
+#define AC100_ADDA_TUNE1_ZERO_CROSSOVER_TIME                    BIT(7)
+
+struct ac100_codec {
+	struct device *dev;
+	struct snd_soc_component component;
+};
+
+/* ADC mixer controls */
+static const struct snd_kcontrol_new ac100_codec_adc_mixer_controls[] = {
+	SOC_DAPM_DOUBLE("Mic1 Capture Switch",
+			AC100_ADC_SRC,
+			AC100_ADC_SRC_ADCL_MIC1_BOOST_OFF,
+			AC100_ADC_SRC_ADCR_MIC1_BOOST_OFF, 1, 0),
+	SOC_DAPM_DOUBLE("Mic2 Capture Switch",
+			AC100_ADC_SRC,
+			AC100_ADC_SRC_ADCL_MIC2_BOOST_OFF,
+			AC100_ADC_SRC_ADCR_MIC2_BOOST_OFF, 1, 0),
+	SOC_DAPM_DOUBLE("Line In Differential Capture Switch",
+			AC100_ADC_SRC,
+			AC100_ADC_SRC_ADCL_LINEINL_LINEINR_OFF,
+			AC100_ADC_SRC_ADCR_LINEINL_LINEINR_OFF, 1, 0),
+	SOC_DAPM_DOUBLE("Line In Capture Switch",
+			AC100_ADC_SRC,
+			AC100_ADC_SRC_ADCL_LINEINL_OFF,
+			AC100_ADC_SRC_ADCR_LINEINR_OFF, 1, 0),
+	SOC_DAPM_DOUBLE("Aux In Capture Switch",
+			AC100_ADC_SRC,
+			AC100_ADC_SRC_ADCL_AUXINL_OFF,
+			AC100_ADC_SRC_ADCR_AUXINR_OFF, 1, 0),
+	SOC_DAPM_DOUBLE("Mixer Capture Switch",
+			AC100_ADC_SRC,
+			AC100_ADC_SRC_ADCL_LOUTMIX_OFF,
+			AC100_ADC_SRC_ADCR_ROUTMIX_OFF, 1, 0),
+	SOC_DAPM_DOUBLE("Mixer Reversed Capture Switch",
+			AC100_ADC_SRC,
+			AC100_ADC_SRC_ADCL_ROUTMIX_OFF,
+			AC100_ADC_SRC_ADCR_LOUTMIX_OFF, 1, 0),
+};
+
+/* Output mixer controls */
+static const struct snd_kcontrol_new ac100_codec_mixer_controls[] = {
+	SOC_DAPM_DOUBLE("Mic1 Playback Switch",
+			AC100_OUT_MXR_SRC,
+			AC100_OUT_MXR_SRC_LMIX_MIC1_BOOST_OFF,
+			AC100_OUT_MXR_SRC_RMIX_MIC1_BOOST_OFF, 1, 0),
+	SOC_DAPM_DOUBLE("Mic2 Playback Switch",
+			AC100_OUT_MXR_SRC,
+			AC100_OUT_MXR_SRC_LMIX_MIC2_BOOST_OFF,
+			AC100_OUT_MXR_SRC_RMIX_MIC2_BOOST_OFF, 1, 0),
+	SOC_DAPM_DOUBLE("Line In Differential Playback Switch",
+			AC100_OUT_MXR_SRC,
+			AC100_OUT_MXR_SRC_LMIX_LINEINL_LINEINR_OFF,
+			AC100_OUT_MXR_SRC_RMIX_LINEINL_LINEINR_OFF, 1, 0),
+	SOC_DAPM_DOUBLE("Line In Playback Switch",
+			AC100_OUT_MXR_SRC,
+			AC100_OUT_MXR_SRC_LMIX_LINEINL_OFF,
+			AC100_OUT_MXR_SRC_RMIX_LINEINR_OFF, 1, 0),
+	SOC_DAPM_DOUBLE("Aux In Playback Switch",
+			AC100_OUT_MXR_SRC,
+			AC100_OUT_MXR_SRC_LMIX_AUXINL_OFF,
+			AC100_OUT_MXR_SRC_RMIX_AUXINR_OFF, 1, 0),
+	SOC_DAPM_DOUBLE("DAC Playback Switch",
+			AC100_OUT_MXR_SRC,
+			AC100_OUT_MXR_SRC_LMIX_DACL_OFF,
+			AC100_OUT_MXR_SRC_RMIX_DACR_OFF, 1, 0),
+	SOC_DAPM_DOUBLE("DAC Reversed Playback Switch",
+			AC100_OUT_MXR_SRC,
+			AC100_OUT_MXR_SRC_LMIX_DACR_OFF,
+			AC100_OUT_MXR_SRC_RMIX_DACL_OFF, 1, 0),
+};
+
+static const DECLARE_TLV_DB_SCALE(ac100_codec_out_mixer_pregain_scale,
+				  -450, 150, 0);
+
+static const DECLARE_TLV_DB_RANGE(ac100_codec_mic_gain_scale,
+	0, 0, TLV_DB_SCALE_ITEM(0, 0, 0),
+	1, 7, TLV_DB_SCALE_ITEM(3000, 300, 0),
+);
+
+static const DECLARE_TLV_DB_SCALE(ac100_codec_pre_gain_scale,
+				  -1200, 300, 0);
+
+static const DECLARE_TLV_DB_RANGE(ac100_codec_earpiece_vol_scale,
+	0, 1, TLV_DB_SCALE_ITEM(TLV_DB_GAIN_MUTE, 0, 1),
+	2, 31, TLV_DB_SCALE_ITEM(-4350, 150, 0),
+);
+
+static const DECLARE_TLV_DB_SCALE(ac100_codec_lineout_vol_scale, -450, 150, 0);
+
+static const DECLARE_TLV_DB_SCALE(ac100_codec_hp_vol_scale, -6300, 100, 1);
+
+static const char *ac100_codec_hp_pa_delay_texts[] = {
+	"4ms", "8ms", "16ms", "32ms"
+};
+
+static SOC_ENUM_SINGLE_DECL(ac100_codec_hp_pa_delay_enum,
+			    AC100_HPOUT_CTRL,
+			    AC100_HPOUT_CTRL_STARTUP_DELAY_OFF,
+			    ac100_codec_hp_pa_delay_texts);
+
+static const char *ac100_codec_hp_pa_cur_texts[] = {
+	"low", "mid", "higher", "highest"
+};
+
+static SOC_ENUM_SINGLE_DECL(ac100_codec_hp_pa_cur_enum,
+			    AC100_HPOUT_CTRL,
+			    AC100_HPOUT_CTRL_OUTPUT_CURRENT_OFF,
+			    ac100_codec_hp_pa_cur_texts);
+
+static SOC_ENUM_SINGLE_DECL(ac100_codec_ep_pa_cur_enum,
+			    AC100_ERPOUT_CTRL,
+			    AC100_ERPOUT_CTRL_OUT_CURRENT_OFF,
+			    ac100_codec_hp_pa_cur_texts);
+
+static const char *ac100_codec_ep_pa_ramp_time_texts[] = {
+	"256ms", "512ms", "640ms", "768ms"
+};
+
+static SOC_ENUM_SINGLE_DECL(ac100_codec_ep_pa_ramp_time_enum,
+			    AC100_ERPOUT_CTRL,
+			    AC100_ERPOUT_CTRL_RAMP_TIME_OFF,
+			    ac100_codec_ep_pa_ramp_time_texts);
+
+static const char *ac100_codec_mic_bv_texts[] = {
+	"1.88V", "2.09V", "2.33V", "2.5V"
+};
+
+static SOC_ENUM_SINGLE_DECL(ac100_codec_mic1_bv_enum,
+			    AC100_OUT_MXR_SRC_BST,
+			    AC100_OUT_MXR_SRC_BST_MMICBIAS_VOLTAGE_OFF,
+			    ac100_codec_mic_bv_texts);
+
+static SOC_ENUM_SINGLE_DECL(ac100_codec_mic2_bv_enum,
+			    AC100_OUT_MXR_SRC_BST,
+			    AC100_OUT_MXR_SRC_BST_HMICBIAS_VOLTAGE_OFF,
+			    ac100_codec_mic_bv_texts);
+
+/* volume / mute controls */
+static const struct snd_kcontrol_new ac100_codec_controls[] = {
+	/* Microphone Amp boost gain */
+	SOC_SINGLE_TLV("Mic1 Boost Volume", AC100_ADC_SRC_BST_CTRL,
+		       AC100_ADC_SRC_BST_CTRL_MIC1BOOST_OFF, 0x7, 0,
+		       ac100_codec_mic_gain_scale),
+
+	SOC_SINGLE_TLV("Mic2 Boost Volume", AC100_ADC_SRC_BST_CTRL,
+		       AC100_ADC_SRC_BST_CTRL_MIC2BOOST_OFF, 0x7, 0,
+		       ac100_codec_mic_gain_scale),
+
+	SOC_SINGLE_TLV("Line In Pre-Gain Volume", AC100_ADC_SRC_BST_CTRL,
+		       AC100_ADC_SRC_BST_CTRL_LINEIN_DIFF_PREG_OFF, 0x7, 0,
+		       ac100_codec_pre_gain_scale),
+
+	SOC_SINGLE_TLV("Aux In Pre-Gain Volume", AC100_ADC_SRC_BST_CTRL,
+		       AC100_ADC_SRC_BST_CTRL_AXI_PREG_OFF, 0x7, 0,
+		       ac100_codec_pre_gain_scale),
+
+	/* ADC */
+	SOC_DOUBLE_TLV("ADC Gain Capture Volume", AC100_ADC_APC_CTRL,
+		       AC100_ADC_APC_CTRL_ADCL_GAIN_OFF,
+		       AC100_ADC_APC_CTRL_ADCR_GAIN_OFF, 0x7, 0,
+		       ac100_codec_out_mixer_pregain_scale),
+
+	/* Mixer pre-gain */
+	SOC_SINGLE_TLV("Mic1 Playback Volume", AC100_OUT_MXR_SRC_BST,
+		       AC100_OUT_MXR_SRC_BST_MIC1_GAIN_OFF,
+		       0x7, 0, ac100_codec_out_mixer_pregain_scale),
+
+	SOC_SINGLE_TLV("Mic2 Playback Volume", AC100_OUT_MXR_SRC_BST,
+		       AC100_OUT_MXR_SRC_BST_MIC2_GAIN_OFF,
+		       0x7, 0, ac100_codec_out_mixer_pregain_scale),
+
+	SOC_SINGLE_TLV("Line In Playback Volume", AC100_OUT_MXR_SRC_BST,
+		       AC100_OUT_MXR_SRC_BST_LINEIN_GAIN_OFF,
+		       0x7, 0, ac100_codec_out_mixer_pregain_scale),
+
+	SOC_SINGLE_TLV("Aux In Playback Volume", AC100_OUT_MXR_SRC_BST,
+		       AC100_OUT_MXR_SRC_BST_AX_GAIN_OFF,
+		       0x7, 0, ac100_codec_out_mixer_pregain_scale),
+
+	SOC_SINGLE_TLV("Headphone Playback Volume",
+		       AC100_HPOUT_CTRL,
+		       AC100_HPOUT_CTRL_VOLUME_OFF, 0x3f, 0,
+		       ac100_codec_hp_vol_scale),
+
+	SOC_SINGLE_TLV("Earpiece Playback Volume",
+		       AC100_ERPOUT_CTRL,
+		       AC100_ERPOUT_CTRL_VOLUME_OFF, 0x1f, 0,
+		       ac100_codec_earpiece_vol_scale),
+
+	SOC_SINGLE_TLV("Speaker Playback Volume",
+		       AC100_SPKOUT_CTRL,
+		       AC100_SPKOUT_CTRL_VOLUME_OFF, 0x1f, 0,
+		       ac100_codec_earpiece_vol_scale),
+
+	SOC_SINGLE_TLV("Line Out Playback Volume",
+		       AC100_LINEOUT_CTRL,
+		       AC100_LINEOUT_CTRL_LINEOUT_GAIN_OFF, 0x7, 0,
+		       ac100_codec_lineout_vol_scale),
+
+	SOC_ENUM("Headphone Amplifier Startup Delay",
+		 ac100_codec_hp_pa_delay_enum),
+	SOC_ENUM("Headphone Amplifier Current", ac100_codec_hp_pa_cur_enum),
+
+	SOC_ENUM("Earpiece Amplifier Ramp Time",
+		 ac100_codec_ep_pa_ramp_time_enum),
+	SOC_ENUM("Earpiece Amplifier Current", ac100_codec_ep_pa_cur_enum),
+
+	SOC_ENUM("Mic1 Bias Voltage", ac100_codec_mic1_bv_enum),
+	SOC_ENUM("Mic2 Bias Voltage", ac100_codec_mic2_bv_enum),
+};
+
+/* Headphone */
+
+static const char * const ac100_codec_hp_src_enum_text[] = {
+	"DAC", "Mixer",
+};
+
+static SOC_ENUM_DOUBLE_DECL(ac100_codec_hp_src_enum,
+			    AC100_HPOUT_CTRL,
+			    AC100_HPOUT_CTRL_LEFT_SRC_OFF,
+			    AC100_HPOUT_CTRL_RIGHT_SRC_OFF,
+			    ac100_codec_hp_src_enum_text);
+
+static const struct snd_kcontrol_new ac100_codec_hp_src[] = {
+	SOC_DAPM_ENUM("Headphone Source Playback Route",
+		      ac100_codec_hp_src_enum),
+};
+
+static const struct snd_kcontrol_new ac100_codec_hp_switch =
+	SOC_DAPM_DOUBLE("Headphone Playback Switch",
+			AC100_HPOUT_CTRL,
+			AC100_HPOUT_CTRL_LEFT_PA_MUTE_OFF,
+			AC100_HPOUT_CTRL_RIGHT_PA_MUTE_OFF, 1, 0);
+
+/* Earpiece */
+
+static const struct snd_kcontrol_new ac100_codec_earpiece_switch =
+	SOC_DAPM_SINGLE("Playback Switch",
+			AC100_ERPOUT_CTRL,
+			AC100_ERPOUT_CTRL_MUTE_OFF, 1, 0);
+
+static const char * const ac100_codec_earpiece_src_enum_text[] = {
+	"DACR", "DACL", "Right Mixer", "Left Mixer",
+};
+
+static SOC_ENUM_SINGLE_DECL(ac100_codec_earpiece_src_enum,
+			    AC100_ERPOUT_CTRL,
+			    AC100_ERPOUT_CTRL_INPUT_SOURCE_OFF,
+			    ac100_codec_earpiece_src_enum_text);
+
+static const struct snd_kcontrol_new ac100_codec_earpiece_src[] = {
+	SOC_DAPM_ENUM("Earpiece Source Playback Route",
+		      ac100_codec_earpiece_src_enum),
+};
+
+/* Speaker */
+
+static const char * const ac100_codec_spk_src_enum_text[] = {
+	"Stereo", "Mono",
+};
+
+static SOC_ENUM_DOUBLE_DECL(ac100_codec_spk_src_enum,
+			    AC100_SPKOUT_CTRL,
+			    AC100_SPKOUT_CTRL_LEFT_SRC_OFF,
+			    AC100_SPKOUT_CTRL_RIGHT_SRC_OFF,
+			    ac100_codec_spk_src_enum_text);
+
+static const struct snd_kcontrol_new ac100_codec_spk_src[] = {
+	SOC_DAPM_ENUM("Speaker Source Playback Route",
+		      ac100_codec_spk_src_enum),
+};
+
+static const struct snd_kcontrol_new ac100_codec_spk_switch =
+	SOC_DAPM_DOUBLE("Speaker Playback Switch",
+			AC100_SPKOUT_CTRL,
+			AC100_SPKOUT_CTRL_LEFT_EN_OFF,
+			AC100_SPKOUT_CTRL_RIGHT_EN_OFF, 1, 0);
+
+static const struct snd_kcontrol_new ac100_codec_spk_inv_switch =
+	SOC_DAPM_DOUBLE("Speaker Invert Switch",
+			AC100_SPKOUT_CTRL,
+			AC100_SPKOUT_CTRL_LEFT_INV_EN_OFF,
+			AC100_SPKOUT_CTRL_RIGHT_INV_EN_OFF, 1, 0);
+
+/* Line Out */
+
+static const struct snd_kcontrol_new ac100_codec_lineout_mixer_controls[] = {
+	SOC_DAPM_SINGLE("Mic1 Playback Switch",
+			AC100_LINEOUT_CTRL,
+			AC100_LINEOUT_CTRL_LINEOUT_S0_OFF, 1, 0),
+	SOC_DAPM_SINGLE("Mic2 Playback Switch",
+			AC100_LINEOUT_CTRL,
+			AC100_LINEOUT_CTRL_LINEOUT_S1_OFF, 1, 0),
+	SOC_DAPM_SINGLE("Right Mixer Playback Switch",
+			AC100_LINEOUT_CTRL,
+			AC100_LINEOUT_CTRL_LINEOUT_S2_OFF, 1, 0),
+	SOC_DAPM_SINGLE("Left Mixer Playback Switch",
+			AC100_LINEOUT_CTRL,
+			AC100_LINEOUT_CTRL_LINEOUT_S3_OFF, 1, 0),
+};
+
+static const struct snd_kcontrol_new ac100_codec_lineout_switch =
+	SOC_DAPM_SINGLE("Playback Switch",
+			AC100_LINEOUT_CTRL,
+			AC100_LINEOUT_CTRL_LINEOUT_EN_OFF, 1, 0);
+
+/* Mic2 Boost Source */
+
+static const char * const ac100_codec_mic2boost_src_enum_text[] = {
+	"Mic2", "Mic3",
+};
+
+static SOC_ENUM_SINGLE_DECL(ac100_codec_mic2boost_src_enum,
+			    AC100_ADC_SRC_BST_CTRL,
+			    AC100_ADC_SRC_BST_CTRL_MIC2SLT_OFF,
+			    ac100_codec_mic2boost_src_enum_text);
+
+static const struct snd_kcontrol_new ac100_codec_mic2boost_src[] = {
+	SOC_DAPM_ENUM("Mic2 Source Capture Route",
+		      ac100_codec_mic2boost_src_enum),
+};
+
+/* This is done to remove the headphone buffer DC offset. */
+static int ac100_codec_hp_power(struct snd_soc_dapm_widget *w,
+				struct snd_kcontrol *k, int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	unsigned int val = SND_SOC_DAPM_EVENT_ON(event) ? 0xf : 0;
+
+	// zero cross detection
+	if (SND_SOC_DAPM_EVENT_OFF(event)) {
+		snd_soc_component_update_bits(component,
+					      AC100_ADDA_TUNE1,
+					      AC100_ADDA_TUNE1_ZERO_CROSSOVER_EN_MASK,
+					      AC100_ADDA_TUNE1_ZERO_CROSSOVER_EN_EN);
+	} else {
+		snd_soc_component_update_bits(component,
+					      AC100_ADDA_TUNE1,
+					      AC100_ADDA_TUNE1_ZERO_CROSSOVER_EN_MASK,
+					      AC100_ADDA_TUNE1_ZERO_CROSSOVER_EN_DIS);
+	}
+
+	snd_soc_component_update_bits(component, AC100_OUT_MXR_DAC_A_CTRL,
+				      AC100_OUT_MXR_DAC_A_CTRL_HP_DCRM_EN(0xf),
+				      AC100_OUT_MXR_DAC_A_CTRL_HP_DCRM_EN(val));
+	return 0;
+}
+
+static const struct snd_soc_dapm_widget ac100_codec_widgets[] = {
+	/* DAC */
+	SND_SOC_DAPM_DAC("Left DAC", NULL, AC100_OUT_MXR_DAC_A_CTRL,
+			 AC100_OUT_MXR_DAC_A_CTRL_DAC_AL_EN_OFF, 0),
+	SND_SOC_DAPM_DAC("Right DAC", NULL, AC100_OUT_MXR_DAC_A_CTRL,
+			 AC100_OUT_MXR_DAC_A_CTRL_DAC_AR_EN_OFF, 0),
+
+	/* ADC */
+	SND_SOC_DAPM_ADC("Left ADC", NULL, AC100_ADC_APC_CTRL,
+			 AC100_ADC_APC_CTRL_ADCL_EN_OFF, 0),
+	SND_SOC_DAPM_ADC("Right ADC", NULL, AC100_ADC_APC_CTRL,
+			 AC100_ADC_APC_CTRL_ADCR_EN_OFF, 0),
+
+	/*
+	 * Due to this component and the codec belonging to separate DAPM
+	 * contexts, we need to manually link the above widgets to their
+	 * stream widgets at the card level.
+	 */
+
+        /* Headphones */
+
+	SND_SOC_DAPM_REGULATOR_SUPPLY("cpvdd", 0, 0),
+	SND_SOC_DAPM_MUX("Left Headphone Source",
+			 SND_SOC_NOPM, 0, 0, ac100_codec_hp_src),
+	SND_SOC_DAPM_MUX("Right Headphone Source",
+			 SND_SOC_NOPM, 0, 0, ac100_codec_hp_src),
+	SND_SOC_DAPM_SWITCH("Left Headphone Switch",
+			    SND_SOC_NOPM, 0, 0, &ac100_codec_hp_switch),
+	SND_SOC_DAPM_SWITCH("Right Headphone Switch",
+			    SND_SOC_NOPM, 0, 0, &ac100_codec_hp_switch),
+	SND_SOC_DAPM_OUT_DRV("Left Headphone Amp",
+			     SND_SOC_NOPM, 0, 0, NULL, 0),
+	SND_SOC_DAPM_OUT_DRV("Right Headphone Amp",
+			     SND_SOC_NOPM, 0, 0, NULL, 0),
+	SND_SOC_DAPM_SUPPLY("Headphone Amp", AC100_HPOUT_CTRL,
+			    AC100_HPOUT_CTRL_PA_EN_OFF, 0,
+			    ac100_codec_hp_power,
+			    SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_PRE_PMD),
+	SND_SOC_DAPM_OUTPUT("HP"),
+
+        /* Earpiece */
+
+	SND_SOC_DAPM_MUX("Earpiece Source Playback Route",
+			 SND_SOC_NOPM, 0, 0, ac100_codec_earpiece_src),
+	SND_SOC_DAPM_SWITCH("Earpiece",
+			    SND_SOC_NOPM, 0, 0, &ac100_codec_earpiece_switch),
+	SND_SOC_DAPM_OUT_DRV("Earpiece Amp", AC100_ERPOUT_CTRL,
+			     AC100_ERPOUT_CTRL_PA_EN_OFF, 0, NULL, 0),
+	SND_SOC_DAPM_OUTPUT("EARPIECE"),
+
+	/* Speaker */
+
+	SND_SOC_DAPM_MUX("Left Speaker Source",
+			 SND_SOC_NOPM, 0, 0, ac100_codec_spk_src),
+	SND_SOC_DAPM_MUX("Right Speaker Source",
+			 SND_SOC_NOPM, 0, 0, ac100_codec_spk_src),
+	SND_SOC_DAPM_SWITCH("Left Speaker Switch",
+			    SND_SOC_NOPM, 0, 0, &ac100_codec_spk_switch),
+	SND_SOC_DAPM_SWITCH("Right Speaker Switch",
+			    SND_SOC_NOPM, 0, 0, &ac100_codec_spk_switch),
+	SND_SOC_DAPM_SWITCH("Left Speaker Invert Switch",
+			    SND_SOC_NOPM, 0, 0, &ac100_codec_spk_inv_switch),
+	SND_SOC_DAPM_SWITCH("Right Speaker Invert Switch",
+			    SND_SOC_NOPM, 0, 0, &ac100_codec_spk_inv_switch),
+	SND_SOC_DAPM_OUTPUT("SPKOUTL"),
+	SND_SOC_DAPM_OUTPUT("SPKOUTR"),
+
+	/* Line Out */
+
+	SND_SOC_DAPM_MIXER("Line Out Mixer", SND_SOC_NOPM, 0, 0,
+			   ac100_codec_lineout_mixer_controls,
+			   ARRAY_SIZE(ac100_codec_lineout_mixer_controls)),
+	SND_SOC_DAPM_SWITCH("Line Out",
+			    SND_SOC_NOPM, 0, 0, &ac100_codec_lineout_switch),
+	SND_SOC_DAPM_OUTPUT("LINEOUT"),
+
+	/* Microphone 1 */
+
+	SND_SOC_DAPM_INPUT("MIC1"),
+	SND_SOC_DAPM_SUPPLY("MBIAS", AC100_ADC_APC_CTRL,
+			    AC100_ADC_APC_CTRL_MBIAS_EN_OFF,
+			    0, NULL, 0),
+	SND_SOC_DAPM_PGA("Mic1 Amplifier", AC100_ADC_SRC_BST_CTRL,
+			 AC100_ADC_SRC_BST_CTRL_MIC1AMPEN_OFF, 0, NULL, 0),
+
+        /* Microphone 2 and 3 */
+
+	SND_SOC_DAPM_INPUT("MIC2"),
+	SND_SOC_DAPM_INPUT("MIC3"),
+	SND_SOC_DAPM_MUX("Mic2 Amplifier Source",
+			 SND_SOC_NOPM, 0, 0, ac100_codec_mic2boost_src),
+	SND_SOC_DAPM_SUPPLY("HBIAS", AC100_ADC_APC_CTRL,
+			    AC100_ADC_APC_CTRL_HBIAS_EN_OFF,
+			    0, NULL, 0),
+	SND_SOC_DAPM_PGA("Mic2 Amplifier", AC100_ADC_SRC_BST_CTRL,
+			 AC100_ADC_SRC_BST_CTRL_MIC2AMPEN_OFF, 0, NULL, 0),
+
+	/* Line input */
+
+	SND_SOC_DAPM_INPUT("LINEIN"),
+
+	/* Aux input */
+
+	SND_SOC_DAPM_INPUT("AUXIN"),
+
+	/* Output mixers */
+	SND_SOC_DAPM_MIXER("Left Mixer", AC100_OUT_MXR_DAC_A_CTRL,
+			   AC100_OUT_MXR_DAC_A_CTRL_AL_MIX_EN_OFF, 0,
+			   ac100_codec_mixer_controls,
+			   ARRAY_SIZE(ac100_codec_mixer_controls)),
+	SND_SOC_DAPM_MIXER("Right Mixer", AC100_OUT_MXR_DAC_A_CTRL,
+			   AC100_OUT_MXR_DAC_A_CTRL_AR_MIX_EN_OFF, 0,
+			   ac100_codec_mixer_controls,
+			   ARRAY_SIZE(ac100_codec_mixer_controls)),
+
+	/* Input mixers */
+	SND_SOC_DAPM_MIXER("Left ADC Mixer", SND_SOC_NOPM, 0, 0,
+			   ac100_codec_adc_mixer_controls,
+			   ARRAY_SIZE(ac100_codec_adc_mixer_controls)),
+	SND_SOC_DAPM_MIXER("Right ADC Mixer", SND_SOC_NOPM, 0, 0,
+			   ac100_codec_adc_mixer_controls,
+			   ARRAY_SIZE(ac100_codec_adc_mixer_controls)),
+};
+
+static const struct snd_soc_dapm_route ac100_codec_routes[] = {
+	/* Microphone Routes */
+	{ "Mic1 Amplifier", NULL, "MIC1"},
+	{ "Mic2 Amplifier", NULL, "Mic2 Amplifier Source"},
+	{ "Mic2 Amplifier Source", "Mic2", "MIC2" },
+	{ "Mic2 Amplifier Source", "Mic3", "MIC3" },
+
+	/* Mixer Routes */
+	{ "Left Mixer", "Mic1 Playback Switch", "Mic1 Amplifier" },
+	{ "Left Mixer", "Mic2 Playback Switch", "Mic2 Amplifier" },
+	{ "Left Mixer", "Line In Differential Playback Switch", "LINEIN" },
+	{ "Left Mixer", "Line In Playback Switch", "LINEIN" },
+	{ "Left Mixer", "Aux In Playback Switch", "AUXIN" },
+	{ "Left Mixer", "DAC Playback Switch", "Left DAC" },
+	{ "Left Mixer", "DAC Reversed Playback Switch", "Right DAC" },
+
+	{ "Right Mixer", "Mic1 Playback Switch", "Mic1 Amplifier" },
+	{ "Right Mixer", "Mic2 Playback Switch", "Mic2 Amplifier" },
+	{ "Right Mixer", "Line In Differential Playback Switch", "LINEIN" },
+	{ "Right Mixer", "Line In Playback Switch", "LINEIN" },
+	{ "Right Mixer", "Aux In Playback Switch", "AUXIN" },
+	{ "Right Mixer", "DAC Playback Switch", "Right DAC" },
+	{ "Right Mixer", "DAC Reversed Playback Switch", "Left DAC" },
+
+	/* ADC Mixer Routes */
+	{ "Left ADC Mixer", "Mic1 Capture Switch", "Mic1 Amplifier" },
+	{ "Left ADC Mixer", "Mic2 Capture Switch", "Mic2 Amplifier" },
+	{ "Left ADC Mixer", "Line In Differential Capture Switch", "LINEIN" },
+	{ "Left ADC Mixer", "Line In Capture Switch", "LINEIN" },
+	{ "Left ADC Mixer", "Aux In Capture Switch", "AUXIN" },
+	{ "Left ADC Mixer", "Mixer Capture Switch", "Left Mixer" },
+	{ "Left ADC Mixer", "Mixer Reversed Capture Switch", "Right Mixer" },
+
+	{ "Right ADC Mixer", "Mic1 Capture Switch", "Mic1 Amplifier" },
+	{ "Right ADC Mixer", "Mic2 Capture Switch", "Mic2 Amplifier" },
+	{ "Right ADC Mixer", "Line In Differential Capture Switch", "LINEIN" },
+	{ "Right ADC Mixer", "Line In Capture Switch", "LINEIN" },
+	{ "Right ADC Mixer", "Aux In Capture Switch", "AUXIN" },
+	{ "Right ADC Mixer", "Mixer Capture Switch", "Right Mixer" },
+	{ "Right ADC Mixer", "Mixer Reversed Capture Switch", "Left Mixer" },
+
+	/* ADC Routes */
+	{ "Left ADC", NULL, "Left ADC Mixer" },
+	{ "Right ADC", NULL, "Right ADC Mixer" },
+
+	/* Headphone Routes */
+	{ "Left Headphone Source", "DAC", "Left DAC" },
+	{ "Left Headphone Source", "Mixer", "Left Mixer" },
+	{ "Left Headphone Switch", "Headphone Playback Switch", "Left Headphone Source" },
+	{ "Left Headphone Amp", NULL, "Left Headphone Switch" },
+	{ "Left Headphone Amp", NULL, "Headphone Amp" },
+	{ "HP", NULL, "Left Headphone Amp" },
+
+	{ "Right Headphone Source", "DAC", "Right DAC" },
+	{ "Right Headphone Source", "Mixer", "Right Mixer" },
+	{ "Right Headphone Switch", "Headphone Playback Switch", "Right Headphone Source" },
+	{ "Right Headphone Amp", NULL, "Right Headphone Switch" },
+	{ "Right Headphone Amp", NULL, "Headphone Amp" },
+	{ "HP", NULL, "Right Headphone Amp" },
+
+	{ "Headphone Amp", NULL, "cpvdd" },
+
+	/* Speaker Routes */
+	{ "Left Speaker Source", "Stereo", "Left Mixer" },
+	{ "Left Speaker Source", "Mono", "Right Mixer" },
+	{ "Left Speaker Source", "Mono", "Left Mixer" },
+	{ "Left Speaker Switch", "Speaker Playback Switch", "Left Speaker Source" },
+	{ "SPKOUTL", NULL, "Left Speaker Switch" },
+
+	{ "Right Speaker Source", "Stereo", "Right Mixer" },
+	{ "Right Speaker Source", "Mono", "Right Mixer" },
+	{ "Right Speaker Source", "Mono", "Left Mixer" },
+	{ "Right Speaker Switch", "Speaker Playback Switch", "Right Speaker Source" },
+	{ "SPKOUTR", NULL, "Right Speaker Switch" },
+
+	/* Earpiece Routes */
+	{ "Earpiece Source Playback Route", "DACR", "Right DAC" },
+	{ "Earpiece Source Playback Route", "DACL", "Left DAC" },
+	{ "Earpiece Source Playback Route", "Right Mixer", "Right Mixer" },
+	{ "Earpiece Source Playback Route", "Left Mixer", "Left Mixer" },
+	{ "Earpiece", "Playback Switch", "Earpiece Source Playback Route" },
+	{ "Earpiece Amp", NULL, "Earpiece" },
+	{ "EARPIECE", NULL, "Earpiece Amp" },
+
+	/* Line-out Routes */
+	{ "Line Out", "Playback Switch", "Line Out Mixer" },
+	{ "Line Out Mixer", "Mic1 Playback Switch", "Mic1 Amplifier" },
+	{ "Line Out Mixer", "Mic2 Playback Switch", "Mic2 Amplifier" },
+	{ "Line Out Mixer", "Right Mixer Playback Switch", "Right Mixer" },
+	{ "Line Out Mixer", "Left Mixer Playback Switch", "Left Mixer" },
+	{ "LINEOUT", NULL, "Line Out" },
+};
+
+static int ac100_codec_set_bias_level(struct snd_soc_component *component,
+				      enum snd_soc_bias_level level)
+{
+	if (level == SND_SOC_BIAS_OFF) {
+		pr_err("XX: idle bias off\n");
+	}
+
+	return 0;
+}
+
+static const struct snd_soc_component_driver ac100_codec_analog_cmpnt_drv = {
+	.controls		= ac100_codec_controls,
+	.num_controls		= ARRAY_SIZE(ac100_codec_controls),
+	.dapm_widgets		= ac100_codec_widgets,
+	.num_dapm_widgets	= ARRAY_SIZE(ac100_codec_widgets),
+	.dapm_routes		= ac100_codec_routes,
+	.num_dapm_routes	= ARRAY_SIZE(ac100_codec_routes),
+	.set_bias_level		= ac100_codec_set_bias_level,
+};
+
+static int ac100_codec_probe(struct platform_device *pdev)
+{
+	struct ac100_dev *ac100 = dev_get_drvdata(pdev->dev.parent);
+	struct ac100_codec *codec;
+	int ret = 0;
+
+	codec = devm_kzalloc(&pdev->dev, sizeof(*codec), GFP_KERNEL);
+	if (!codec)
+		return -ENOMEM;
+
+	codec->dev = &pdev->dev;
+	platform_set_drvdata(pdev, codec);
+
+	snd_soc_component_init_regmap(&codec->component, ac100->regmap);
+
+	ret = snd_soc_component_initialize(&codec->component,
+					   &ac100_codec_analog_cmpnt_drv,
+					   &pdev->dev);
+	if (ret < 0)
+		return ret;
+
+	ret = snd_soc_add_component(&codec->component, NULL, 0);
+	if (ret) {
+		dev_err(&pdev->dev,
+			"Failed to register codec component (%d)\n", ret);
+		return ret;
+	}
+
+	return ret;
+}
+
+static int ac100_codec_remove(struct platform_device *pdev)
+{
+	snd_soc_unregister_component(&pdev->dev);
+
+	/*
+	 * We do not call snd_soc_component_exit_regmap, because regmap
+	 * is still owned by the mfd device.
+	 */
+	return 0;
+}
+
+static const struct of_device_id ac100_codec_of_match[] = {
+	{ .compatible = "x-powers,ac100-codec-analog" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, ac100_codec_of_match);
+
+static struct platform_driver ac100_codec_driver = {
+	.driver = {
+		.name = "ac100-codec-analog",
+		.of_match_table = ac100_codec_of_match,
+	},
+	.probe = ac100_codec_probe,
+	.remove = ac100_codec_remove,
+};
+module_platform_driver(ac100_codec_driver);
+
+MODULE_DESCRIPTION("X-Powers AC100 codec driver");
+MODULE_AUTHOR("Ondrej Jirman <megous@megous.com>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:ac100-codec");
diff -Nuar -r --no-dereference linux-5.15.139/sound/soc/sunxi/Kconfig linux/sound/soc/sunxi/Kconfig
--- linux-5.15.139/sound/soc/sunxi/Kconfig	2023-11-20 18:08:30.000000000 +0800
+++ linux/sound/soc/sunxi/Kconfig	2024-01-03 16:06:25.935131000 +0800
@@ -16,12 +16,25 @@
 	depends on MACH_SUN8I || (ARM64 && ARCH_SUNXI) || COMPILE_TEST
 	depends on COMMON_CLK
 	select REGMAP_MMIO
+	select MFD_AC100
 	help
 	  This option enables the digital part of the internal audio codec for
-	  Allwinner sun8i SoC (and particularly A33).
+	  Allwinner sun8i SoC (and particularly A33). It also supports digital
+	  part of X-Powers AC100.
 
 	  Say Y or M if you want to add sun8i digital audio codec support.
 
+config SND_AC100_CODEC
+	tristate "Allwinner (X-Powers) AC100 audio codec (analog part)"
+	depends on OF
+	depends on MACH_SUN8I || COMPILE_TEST
+	select MFD_AC100
+	help
+	  This option enables the audio codec support for Allwinner (X-Powers)
+	  AC100 chip.
+
+	  Say Y or M if you want to add AC100 audio codec support.
+
 config SND_SUN8I_CODEC_ANALOG
 	tristate "Allwinner sun8i Codec Analog Controls Support"
 	depends on MACH_SUN8I || (ARM64 && ARCH_SUNXI) || COMPILE_TEST
@@ -56,6 +69,14 @@
 	  Say Y or M to add support for the S/PDIF audio block in the Allwinner
 	  A10 and affiliated SoCs.
 
+config SND_SUN9I_HDMI_AUDIO
+	tristate "Allwinner sun9i HDMI Audio Sound Card"
+	depends on OF
+	depends on SND_SUN4I_I2S
+	help
+	  Say Y or M to add support for the HDMI Audio sound card for Allwinner
+	  SoCs with DW-HDMI core.
+
 config SND_SUN8I_ADDA_PR_REGMAP
 	tristate
 	select REGMAP
diff -Nuar -r --no-dereference linux-5.15.139/sound/soc/sunxi/sun4i-codec.c linux/sound/soc/sunxi/sun4i-codec.c
--- linux-5.15.139/sound/soc/sunxi/sun4i-codec.c	2023-11-20 18:08:30.000000000 +0800
+++ linux/sound/soc/sunxi/sun4i-codec.c	2024-01-03 16:06:25.935131000 +0800
@@ -5,6 +5,7 @@
  * Copyright 2015 Maxime Ripard <maxime.ripard@free-electrons.com>
  * Copyright 2015 Adam Sampson <ats@offog.org>
  * Copyright 2016 Chen-Yu Tsai <wens@csie.org>
+ * Copyright 2021 gryzun <gryzun_an@rambler.ru>
  *
  * Based on the Allwinner SDK driver, released under the GPL.
  */
@@ -676,6 +677,16 @@
 };
 
 /*** sun4i Codec ***/
+
+static const char *adcis_text[] = {"Line In", "FM In", "Mic1 Mono", "Mic2 Mono",
+			"Mic1,Mic2", "Mic1+2 Mono", "MIX Out", "Line,Mic1"};
+
+static SOC_ENUM_SINGLE_DECL(adcis_mixer, SUN4I_CODEC_ADC_ACTL,
+					SUN4I_CODEC_ADC_ACTL_ADCIS, adcis_text);
+
+static const struct snd_kcontrol_new sun4i_codec_mux_controls =
+	SOC_DAPM_ENUM("Capture Source Capture Route", adcis_mixer);
+
 static const struct snd_kcontrol_new sun4i_codec_pa_mute =
 	SOC_DAPM_SINGLE("Switch", SUN4I_CODEC_DAC_ACTL,
 			SUN4I_CODEC_DAC_ACTL_PA_MUTE, 1, 0);
@@ -689,6 +700,8 @@
 			    0);
 static DECLARE_TLV_DB_SCALE(sun4i_codec_micin_loopback_gain_scale, -450, 150,
 			    0);
+static DECLARE_TLV_DB_SCALE(sun4i_codec_capture_gain_scale, -450, 150,
+			    0);
 static DECLARE_TLV_DB_RANGE(sun4i_codec_micin_preamp_gain_scale,
 			    0, 0, TLV_DB_SCALE_ITEM(0, 0, 0),
 			    1, 7, TLV_DB_SCALE_ITEM(3500, 300, 0));
@@ -742,6 +755,9 @@
 	SOC_SINGLE_TLV("Mic2 Boost Volume", SUN7I_CODEC_AC_MIC_PHONE_CAL,
 		       SUN7I_CODEC_AC_MIC_PHONE_CAL_PREG2, 7, 0,
 		       sun7i_codec_micin_preamp_gain_scale),
+	SOC_SINGLE_TLV("Capture Boost Capture Volume", SUN4I_CODEC_ADC_ACTL,
+		       SUN4I_CODEC_ADC_ACTL_VADCG, 7, 0,
+		       sun4i_codec_capture_gain_scale),
 };
 
 static const struct snd_kcontrol_new sun4i_codec_mixer_controls[] = {
@@ -820,6 +836,13 @@
 	SND_SOC_DAPM_PGA("MIC2 Pre-Amplifier", SUN4I_CODEC_ADC_ACTL,
 			 SUN4I_CODEC_ADC_ACTL_PREG2EN, 0, NULL, 0),
 
+	/* ADC Mux */
+	SND_SOC_DAPM_MUX("Right Capture Source Capture Route", SND_SOC_NOPM, 0, 0,
+		&sun4i_codec_mux_controls),
+
+	SND_SOC_DAPM_MUX("Left Capture Source Capture Route", SND_SOC_NOPM, 0, 0,
+		&sun4i_codec_mux_controls),
+
 	/* Power Amplifier */
 	SND_SOC_DAPM_MIXER("Power Amplifier", SUN4I_CODEC_ADC_ACTL,
 			   SUN4I_CODEC_ADC_ACTL_PA_EN, 0,
@@ -848,6 +871,30 @@
 	{ "Right ADC", NULL, "ADC" },
 	{ "Right DAC", NULL, "DAC" },
 
+	/* Left Mux Capture Routes */
+	{ "Left Capture Source Capture Route", "Mic1 Mono", "MIC1 Pre-Amplifier" },
+	{ "Left Capture Source Capture Route", "Mic2 Mono", "MIC2 Pre-Amplifier" },
+	{ "Left Capture Source Capture Route", "Line In", "Line Left" },
+	{ "Left Capture Source Capture Route", "FM In", "FM Left" },
+	{ "Left Capture Source Capture Route", "MIX Out", "Left Mixer" },
+	{ "Left Capture Source Capture Route", "Mic1,Mic2", "MIC1 Pre-Amplifier" },
+	{ "Left Capture Source Capture Route", "Mic1+2 Mono", "MIC1 Pre-Amplifier" },
+	{ "Left Capture Source Capture Route", "Mic1+2 Mono", "MIC2 Pre-Amplifier" },
+	{ "Left Capture Source Capture Route", "Line,Mic1", "Line Left" },
+	{ "Left ADC", NULL, "Left Capture Source Capture Route" },
+
+	/* Right Mux Capture Routes */
+	{ "Right Capture Source Capture Route", "Mic1 Mono", "MIC1 Pre-Amplifier" },
+	{ "Right Capture Source Capture Route", "Mic2 Mono", "MIC2 Pre-Amplifier" },
+	{ "Right Capture Source Capture Route", "Line In", "Line Right" },
+	{ "Right Capture Source Capture Route", "FM In", "FM Right" },
+	{ "Right Capture Source Capture Route", "MIX Out", "Right Mixer" },
+	{ "Right Capture Source Capture Route", "Mic1,Mic2", "MIC2 Pre-Amplifier" },
+	{ "Right Capture Source Capture Route", "Mic1+2 Mono", "MIC1 Pre-Amplifier" },
+	{ "Right Capture Source Capture Route", "Mic1+2 Mono", "MIC2 Pre-Amplifier" },
+	{ "Right Capture Source Capture Route", "Line,Mic1", "MIC1 Pre-Amplifier" },
+	{ "Right ADC", NULL, "Right Capture Source Capture Route" },
+
 	/* Right Mixer Routes */
 	{ "Right Mixer", NULL, "Mixer Enable" },
 	{ "Right Mixer", "Right Mixer Left DAC Playback Switch", "Left DAC" },
@@ -877,14 +924,10 @@
 	{ "HP Left", NULL, "Power Amplifier Mute" },
 
 	/* Mic1 Routes */
-	{ "Left ADC", NULL, "MIC1 Pre-Amplifier" },
-	{ "Right ADC", NULL, "MIC1 Pre-Amplifier" },
 	{ "MIC1 Pre-Amplifier", NULL, "Mic1"},
 	{ "Mic1", NULL, "VMIC" },
 
 	/* Mic2 Routes */
-	{ "Left ADC", NULL, "MIC2 Pre-Amplifier" },
-	{ "Right ADC", NULL, "MIC2 Pre-Amplifier" },
 	{ "MIC2 Pre-Amplifier", NULL, "Mic2"},
 	{ "Mic2", NULL, "VMIC" },
 };
@@ -1507,6 +1550,45 @@
 	return card;
 };
 
+static struct snd_soc_card *sun8i_r40_codec_create_card(struct device *dev)
+{
+	struct snd_soc_card *card;
+	int ret;
+
+	card = devm_kzalloc(dev, sizeof(*card), GFP_KERNEL);
+	if (!card)
+		return ERR_PTR(-ENOMEM);
+
+	aux_dev.dlc.of_node = of_parse_phandle(dev->of_node,
+						 "allwinner,codec-analog-controls",
+						 0);
+	if (!aux_dev.dlc.of_node) {
+		dev_err(dev, "Can't find analog controls for codec.\n");
+		return ERR_PTR(-EINVAL);
+	}
+
+	card->dai_link = sun4i_codec_create_link(dev, &card->num_links);
+	if (!card->dai_link)
+		return ERR_PTR(-ENOMEM);
+
+	card->dev		= dev;
+	card->owner		= THIS_MODULE;
+	card->name		= "R40 Audio Codec";
+	card->dapm_widgets	= sun6i_codec_card_dapm_widgets;
+	card->num_dapm_widgets	= ARRAY_SIZE(sun6i_codec_card_dapm_widgets);
+	card->dapm_routes	= sun8i_codec_card_routes;
+	card->num_dapm_routes	= ARRAY_SIZE(sun8i_codec_card_routes);
+	card->aux_dev		= &aux_dev;
+	card->num_aux_devs	= 1;
+	card->fully_routed	= true;
+
+	ret = snd_soc_of_parse_audio_routing(card, "allwinner,audio-routing");
+	if (ret)
+		dev_warn(dev, "failed to parse audio-routing: %d\n", ret);
+
+	return card;
+};
+
 static struct snd_soc_card *sun8i_v3s_codec_create_card(struct device *dev)
 {
 	struct snd_soc_card *card;
@@ -1581,6 +1663,13 @@
 	.max_register	= SUN8I_H3_CODEC_ADC_DBG,
 };
 
+static const struct regmap_config sun8i_r40_codec_regmap_config = {
+	.reg_bits	= 32,
+	.reg_stride	= 4,
+	.val_bits	= 32,
+	.max_register	= SUN8I_H3_CODEC_ADC_DBG,
+};
+
 static const struct regmap_config sun8i_v3s_codec_regmap_config = {
 	.reg_bits	= 32,
 	.reg_stride	= 4,
@@ -1651,6 +1740,21 @@
 	.has_reset	= true,
 };
 
+static const struct sun4i_codec_quirks sun8i_r40_codec_quirks = {
+	.regmap_config	= &sun8i_r40_codec_regmap_config,
+	/*
+	 * TODO Share the codec structure with A23 for now.
+	 * This should be split out when adding digital audio
+	 * processing support for the H3.
+	 */
+	.codec		= &sun8i_a23_codec_codec,
+	.create_card	= sun8i_r40_codec_create_card,
+	.reg_adc_fifoc	= REG_FIELD(SUN6I_CODEC_ADC_FIFOC, 0, 31),
+	.reg_dac_txdata	= SUN8I_H3_CODEC_DAC_TXDATA,
+	.reg_adc_rxdata	= SUN6I_CODEC_ADC_RXDATA,
+	.has_reset	= true,
+};
+
 static const struct sun4i_codec_quirks sun8i_v3s_codec_quirks = {
 	.regmap_config	= &sun8i_v3s_codec_regmap_config,
 	/*
@@ -1687,6 +1791,10 @@
 		.data = &sun8i_h3_codec_quirks,
 	},
 	{
+		.compatible = "allwinner,sun8i-r40-codec",
+		.data = &sun8i_r40_codec_quirks,
+	},
+	{
 		.compatible = "allwinner,sun8i-v3s-codec",
 		.data = &sun8i_v3s_codec_quirks,
 	},
@@ -1826,7 +1934,7 @@
 
 	ret = snd_soc_register_card(card);
 	if (ret) {
-		dev_err(&pdev->dev, "Failed to register our card\n");
+		dev_err_probe(&pdev->dev, ret, "Failed to register our card\n");
 		goto err_assert_reset;
 	}
 
diff -Nuar -r --no-dereference linux-5.15.139/sound/soc/sunxi/sun50i-codec-analog.c linux/sound/soc/sunxi/sun50i-codec-analog.c
--- linux-5.15.139/sound/soc/sunxi/sun50i-codec-analog.c	2023-11-20 18:08:30.000000000 +0800
+++ linux/sound/soc/sunxi/sun50i-codec-analog.c	2024-01-03 16:06:25.935131000 +0800
@@ -116,8 +116,20 @@
 #define SUN50I_ADDA_HS_MBIAS_CTRL	0x0e
 #define SUN50I_ADDA_HS_MBIAS_CTRL_MMICBIASEN	7
 
+#define SUN50I_ADDA_MDET_CTRL		0x1c
+#define SUN50I_ADDA_MDET_CTRL_SELDETADC_FS	4
+#define SUN50I_ADDA_MDET_CTRL_SELDETADC_DB	2
+#define SUN50I_ADDA_MDET_CTRL_SELDETADC_BF	0
+
 #define SUN50I_ADDA_JACK_MIC_CTRL	0x1d
+#define SUN50I_ADDA_JACK_MIC_CTRL_JACKDETEN	7
+#define SUN50I_ADDA_JACK_MIC_CTRL_INNERRESEN	6
 #define SUN50I_ADDA_JACK_MIC_CTRL_HMICBIASEN	5
+#define SUN50I_ADDA_JACK_MIC_CTRL_MICADCEN	4
+
+struct sun50i_codec_analog {
+	bool	internal_bias_resistor;
+};
 
 /* mixer controls */
 static const struct snd_kcontrol_new sun50i_a64_codec_mixer_controls[] = {
@@ -296,6 +308,19 @@
 			SUN50I_ADDA_EARPIECE_CTRL1_ESPPA_MUTE, 1, 0),
 };
 
+static int sun50i_codec_hbias_event(struct snd_soc_dapm_widget *w,
+				    struct snd_kcontrol *kcontrol, int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	u32 value = !!SND_SOC_DAPM_EVENT_ON(event);
+
+	regmap_update_bits(component->regmap, SUN50I_ADDA_JACK_MIC_CTRL,
+			   BIT(SUN50I_ADDA_JACK_MIC_CTRL_MICADCEN),
+			   value << SUN50I_ADDA_JACK_MIC_CTRL_MICADCEN);
+
+	return 0;
+}
+
 static const struct snd_soc_dapm_widget sun50i_a64_codec_widgets[] = {
 	/* DAC */
 	SND_SOC_DAPM_DAC("Left DAC", NULL, SUN50I_ADDA_MIX_DAC_CTRL,
@@ -367,7 +392,8 @@
 	/* Microphone Bias */
 	SND_SOC_DAPM_SUPPLY("HBIAS", SUN50I_ADDA_JACK_MIC_CTRL,
 			    SUN50I_ADDA_JACK_MIC_CTRL_HMICBIASEN,
-			    0, NULL, 0),
+			    0, sun50i_codec_hbias_event,
+			    SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_PRE_PMD),
 
 	/* Mic input path */
 	SND_SOC_DAPM_PGA("Mic2 Amplifier", SUN50I_ADDA_MIC2_CTRL,
@@ -471,17 +497,57 @@
 	{ "EARPIECE", NULL, "Earpiece Amp" },
 };
 
-static int sun50i_a64_codec_suspend(struct snd_soc_component *component)
+static int sun50i_a64_codec_probe(struct snd_soc_component *component)
 {
-	return regmap_update_bits(component->regmap, SUN50I_ADDA_HP_CTRL,
-				  BIT(SUN50I_ADDA_HP_CTRL_PA_CLK_GATE),
-				  BIT(SUN50I_ADDA_HP_CTRL_PA_CLK_GATE));
+	struct sun50i_codec_analog *codec = snd_soc_component_get_drvdata(component);
+
+	regmap_update_bits(component->regmap, SUN50I_ADDA_JACK_MIC_CTRL,
+			   BIT(SUN50I_ADDA_JACK_MIC_CTRL_INNERRESEN),
+			   codec->internal_bias_resistor <<
+				SUN50I_ADDA_JACK_MIC_CTRL_INNERRESEN);
+
+	/* Select sample interval of the ADC sample to 32ms */
+	regmap_update_bits(component->regmap, SUN50I_ADDA_MDET_CTRL,
+			   0x7 << SUN50I_ADDA_MDET_CTRL_SELDETADC_FS |
+			   0x3 << SUN50I_ADDA_MDET_CTRL_SELDETADC_BF,
+			   0x3 << SUN50I_ADDA_MDET_CTRL_SELDETADC_FS |
+			   0x3 << SUN50I_ADDA_MDET_CTRL_SELDETADC_BF);
+
+	return 0;
 }
 
-static int sun50i_a64_codec_resume(struct snd_soc_component *component)
+static int sun50i_a64_codec_set_bias_level(struct snd_soc_component *component,
+					   enum snd_soc_bias_level level)
 {
-	return regmap_update_bits(component->regmap, SUN50I_ADDA_HP_CTRL,
-				  BIT(SUN50I_ADDA_HP_CTRL_PA_CLK_GATE), 0);
+	struct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);
+	int hbias;
+
+	switch (level) {
+	case SND_SOC_BIAS_OFF:
+		regmap_update_bits(component->regmap, SUN50I_ADDA_JACK_MIC_CTRL,
+				   BIT(SUN50I_ADDA_JACK_MIC_CTRL_JACKDETEN) |
+				   BIT(SUN50I_ADDA_JACK_MIC_CTRL_MICADCEN), 0);
+
+		regmap_update_bits(component->regmap, SUN50I_ADDA_HP_CTRL,
+				   BIT(SUN50I_ADDA_HP_CTRL_PA_CLK_GATE),
+				   BIT(SUN50I_ADDA_HP_CTRL_PA_CLK_GATE));
+		break;
+	case SND_SOC_BIAS_STANDBY:
+		regmap_update_bits(component->regmap, SUN50I_ADDA_HP_CTRL,
+				   BIT(SUN50I_ADDA_HP_CTRL_PA_CLK_GATE), 0);
+
+		hbias = snd_soc_dapm_get_pin_status(dapm, "HBIAS");
+		regmap_update_bits(component->regmap, SUN50I_ADDA_JACK_MIC_CTRL,
+				   BIT(SUN50I_ADDA_JACK_MIC_CTRL_JACKDETEN) |
+				   BIT(SUN50I_ADDA_JACK_MIC_CTRL_MICADCEN),
+				   BIT(SUN50I_ADDA_JACK_MIC_CTRL_JACKDETEN) |
+				   hbias << SUN50I_ADDA_JACK_MIC_CTRL_MICADCEN);
+		break;
+	default:
+		break;
+	}
+
+	return 0;
 }
 
 static const struct snd_soc_component_driver sun50i_codec_analog_cmpnt_drv = {
@@ -491,8 +557,10 @@
 	.num_dapm_widgets	= ARRAY_SIZE(sun50i_a64_codec_widgets),
 	.dapm_routes		= sun50i_a64_codec_routes,
 	.num_dapm_routes	= ARRAY_SIZE(sun50i_a64_codec_routes),
-	.suspend		= sun50i_a64_codec_suspend,
-	.resume			= sun50i_a64_codec_resume,
+	.probe			= sun50i_a64_codec_probe,
+	.set_bias_level		= sun50i_a64_codec_set_bias_level,
+	.idle_bias_on		= true,
+	.suspend_bias_off	= true,
 };
 
 static const struct of_device_id sun50i_codec_analog_of_match[] = {
@@ -505,9 +573,19 @@
 
 static int sun50i_codec_analog_probe(struct platform_device *pdev)
 {
+	struct sun50i_codec_analog *codec;
 	struct regmap *regmap;
 	void __iomem *base;
 
+	codec = devm_kzalloc(&pdev->dev, sizeof(*codec), GFP_KERNEL);
+	if (!codec)
+		return -ENOMEM;
+
+	codec->internal_bias_resistor = of_property_read_bool(pdev->dev.of_node,
+					"allwinner,internal-bias-resistor");
+
+	platform_set_drvdata(pdev, codec);
+
 	base = devm_platform_ioremap_resource(pdev, 0);
 	if (IS_ERR(base)) {
 		dev_err(&pdev->dev, "Failed to map the registers\n");
diff -Nuar -r --no-dereference linux-5.15.139/sound/soc/sunxi/sun8i-codec-analog.c linux/sound/soc/sunxi/sun8i-codec-analog.c
--- linux-5.15.139/sound/soc/sunxi/sun8i-codec-analog.c	2023-11-20 18:08:30.000000000 +0800
+++ linux/sound/soc/sunxi/sun8i-codec-analog.c	2024-01-03 16:06:25.935131000 +0800
@@ -686,6 +686,14 @@
 	.has_mic2	= true,
 };
 
+static const struct sun8i_codec_analog_quirks sun8i_r40_quirks = {
+	.has_headphone	= true,
+	.has_hmic	= true,
+	.has_linein	= true,
+	.has_mbias	= true,
+	.has_mic2	= true,
+};
+
 static int sun8i_codec_analog_add_mixer(struct snd_soc_component *cmpnt,
 					const struct sun8i_codec_analog_quirks *quirks)
 {
@@ -729,8 +737,12 @@
 }
 
 static const struct sun8i_codec_analog_quirks sun8i_v3s_quirks = {
-	.has_headphone	= true,
-	.has_hmic	= true,
+	.has_headphone  = true,
+	.has_hmic       = true,
+	.has_linein     = true,
+	.has_lineout    = true,
+	.has_mbias      = true,
+	.has_mic2       = true,
 };
 
 static int sun8i_codec_analog_cmpnt_probe(struct snd_soc_component *cmpnt)
@@ -810,6 +822,10 @@
 		.data = &sun8i_h3_quirks,
 	},
 	{
+		.compatible = "allwinner,sun8i-r40-codec-analog",
+		.data = &sun8i_r40_quirks,
+	},
+	{
 		.compatible = "allwinner,sun8i-v3s-codec-analog",
 		.data = &sun8i_v3s_quirks,
 	},
diff -Nuar -r --no-dereference linux-5.15.139/sound/soc/sunxi/sun9i-hdmi-audio.c linux/sound/soc/sunxi/sun9i-hdmi-audio.c
--- linux-5.15.139/sound/soc/sunxi/sun9i-hdmi-audio.c	1970-01-01 08:00:00.000000000 +0800
+++ linux/sound/soc/sunxi/sun9i-hdmi-audio.c	2024-01-03 16:06:25.935131000 +0800
@@ -0,0 +1,180 @@
+// SPDX-License-Identifier: GPL-2.0
+//
+// sun9i hdmi audio sound card
+//
+// Copyright (C) 2021 Jernej Skrabec <jernej.skrabec@gmail.com>
+
+#include <linux/module.h>
+#include <linux/of_platform.h>
+
+#include <sound/soc.h>
+#include <sound/soc-dai.h>
+
+static int sun9i_hdmi_audio_hw_params(struct snd_pcm_substream *substream,
+				      struct snd_pcm_hw_params *params)
+{
+	struct snd_soc_pcm_runtime *rtd = asoc_substream_to_rtd(substream);
+	unsigned int mclk;
+
+	mclk = params_rate(params) * 128;
+
+	return snd_soc_dai_set_sysclk(asoc_rtd_to_cpu(rtd, 0), 0, mclk,
+				      SND_SOC_CLOCK_OUT);
+}
+
+static const struct snd_soc_ops sun9i_hdmi_audio_ops = {
+	.hw_params = sun9i_hdmi_audio_hw_params,
+};
+
+static int sun9i_hdmi_audio_dai_init(struct snd_soc_pcm_runtime *rtd)
+{
+	int ret;
+
+	/* TODO: switch to custom api once it's implemented in sun4i-i2s */
+	ret = snd_soc_dai_set_tdm_slot(asoc_rtd_to_cpu(rtd, 0), 0, 0, 2, 32);
+	if (ret) {
+		dev_err(asoc_rtd_to_cpu(rtd, 0)->dev,
+			"setting tdm link slots failed\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int sun9i_hdmi_audio_parse_dai(struct device_node *node,
+				      struct snd_soc_dai_link_component *dlc)
+{
+	struct of_phandle_args args;
+	int ret;
+
+	if (!node)
+		return 0;
+
+	ret = of_parse_phandle_with_args(node, "sound-dai",
+					 "#sound-dai-cells", 0, &args);
+	if (ret)
+		return ret;
+
+	ret = snd_soc_get_dai_name(&args, &dlc->dai_name);
+	if (ret < 0) {
+		of_node_put(args.np);
+
+		return ret;
+	}
+
+	dlc->of_node = args.np;
+
+	return 0;
+}
+
+static int sun9i_hdmi_audio_probe(struct platform_device *pdev)
+{
+	struct snd_soc_dai_link_component *dlc;
+	struct device *dev = &pdev->dev;
+	struct snd_soc_dai_link *link;
+	struct snd_soc_card *card;
+	struct device_node *child;
+	int ret;
+
+	card = devm_kzalloc(dev, sizeof(*card), GFP_KERNEL);
+	if (!card)
+		return -ENOMEM;
+
+	link = devm_kzalloc(dev, sizeof(*link), GFP_KERNEL);
+	if (!link)
+		return -ENOMEM;
+
+	dlc = devm_kzalloc(dev, sizeof(*dlc) * 3, GFP_KERNEL);
+	if (!dlc)
+		return -ENOMEM;
+
+	child = of_get_child_by_name(dev->of_node, "codec");
+	if (!child)
+		return -ENODEV;
+
+	ret = sun9i_hdmi_audio_parse_dai(child, &dlc[1]);
+	of_node_put(child);
+	if (ret)
+		return ret;
+
+	child = of_get_child_by_name(dev->of_node, "cpu");
+	if (!child) {
+		ret = -ENODEV;
+		goto out_err;
+	}
+
+	ret = sun9i_hdmi_audio_parse_dai(child, &dlc[0]);
+	of_node_put(child);
+	if (ret)
+		goto out_err;
+
+	dlc[2].of_node = dlc[0].of_node;
+
+	platform_set_drvdata(pdev, card);
+
+	link->cpus = &dlc[0];
+	link->codecs = &dlc[1];
+	link->platforms = &dlc[2];
+
+	link->num_cpus = 1;
+	link->num_codecs = 1;
+	link->num_platforms = 1;
+
+	link->playback_only = 1;
+
+	link->name = "SUN9I-HDMI";
+	link->stream_name = "SUN9I-HDMI PCM";
+
+	link->dai_fmt = SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_IF | SND_SOC_DAIFMT_CBS_CFS;
+
+	link->ops = &sun9i_hdmi_audio_ops;
+	link->init = sun9i_hdmi_audio_dai_init;
+
+	card->dai_link = link;
+	card->num_links = 1;
+	card->owner = THIS_MODULE;
+	card->dev = dev;
+	card->name = "sun9i-hdmi";
+
+	ret = devm_snd_soc_register_card(dev, card);
+	if (ret)
+		goto out_err;
+
+	return 0;
+
+out_err:
+	of_node_put(dlc[0].of_node);
+	of_node_put(dlc[1].of_node);
+
+	return ret;
+}
+
+static int sun9i_hdmi_audio_remove(struct platform_device *pdev)
+{
+	struct snd_soc_card *card = platform_get_drvdata(pdev);
+
+	of_node_put(card->dai_link->cpus->of_node);
+	of_node_put(card->dai_link->codecs->of_node);
+
+	return 0;
+}
+
+static const struct of_device_id sun9i_hdmi_audio_match[] = {
+	{ .compatible = "allwinner,sun9i-a80-hdmi-audio" },
+	{}
+};
+MODULE_DEVICE_TABLE(of, sun9i_hdmi_audio_match);
+
+static struct platform_driver sun9i_hdmi_audio_driver = {
+	.probe = sun9i_hdmi_audio_probe,
+	.remove = sun9i_hdmi_audio_remove,
+	.driver = {
+		.name = "sun9i-hdmi-audio",
+		.of_match_table = sun9i_hdmi_audio_match,
+	},
+};
+module_platform_driver(sun9i_hdmi_audio_driver);
+
+MODULE_DESCRIPTION("sun9i HDMI Audio Sound Card");
+MODULE_AUTHOR("Jernej Skrabec <jernej.skrabec@gmail.com>");
+MODULE_LICENSE("GPL v2");
diff -Nuar -r --no-dereference linux-5.15.139/sound/soc/sunxi/sun8i-codec.c linux/sound/soc/sunxi/sun8i-codec.c
--- linux-5.15.139/sound/soc/sunxi/sun8i-codec.c	2023-11-20 18:08:30.000000000 +0800
+++ linux/sound/soc/sunxi/sun8i-codec.c	2024-01-03 16:06:25.935131000 +0800
@@ -12,15 +12,22 @@
 #include <linux/module.h>
 #include <linux/delay.h>
 #include <linux/clk.h>
+#include <linux/input.h>
 #include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/mutex.h>
 #include <linux/of_device.h>
 #include <linux/pm_runtime.h>
 #include <linux/regmap.h>
+#include <linux/regulator/consumer.h>
 #include <linux/log2.h>
+#include <linux/mfd/ac100.h>
 
+#include <sound/jack.h>
 #include <sound/pcm_params.h>
 #include <sound/soc.h>
 #include <sound/soc-dapm.h>
+#include <sound/tlv.h>
 
 #define SUN8I_SYSCLK_CTL				0x00c
 #define SUN8I_SYSCLK_CTL_AIF1CLK_ENA			11
@@ -72,6 +79,12 @@
 #define SUN8I_AIF1_MXR_SRC_AD0R_MXR_SRC_AIF2DACR	10
 #define SUN8I_AIF1_MXR_SRC_AD0R_MXR_SRC_ADCR		9
 #define SUN8I_AIF1_MXR_SRC_AD0R_MXR_SRC_AIF2DACL	8
+#define SUN8I_AIF1_VOL_CTRL1				0x050
+#define SUN8I_AIF1_VOL_CTRL1_AD0L_VOL			8
+#define SUN8I_AIF1_VOL_CTRL1_AD0R_VOL			0
+#define SUN8I_AIF1_VOL_CTRL3				0x058
+#define SUN8I_AIF1_VOL_CTRL3_DA0L_VOL			8
+#define SUN8I_AIF1_VOL_CTRL3_DA0R_VOL			0
 #define SUN8I_AIF2_ADCDAT_CTRL				0x084
 #define SUN8I_AIF2_ADCDAT_CTRL_AIF2_ADCL_ENA		15
 #define SUN8I_AIF2_ADCDAT_CTRL_AIF2_ADCR_ENA		14
@@ -91,6 +104,12 @@
 #define SUN8I_AIF2_MXR_SRC_ADCR_MXR_SRC_AIF1DA1R	10
 #define SUN8I_AIF2_MXR_SRC_ADCR_MXR_SRC_AIF2DACL	9
 #define SUN8I_AIF2_MXR_SRC_ADCR_MXR_SRC_ADCR		8
+#define SUN8I_AIF2_VOL_CTRL1				0x090
+#define SUN8I_AIF2_VOL_CTRL1_ADCL_VOL			8
+#define SUN8I_AIF2_VOL_CTRL1_ADCR_VOL			0
+#define SUN8I_AIF2_VOL_CTRL2				0x098
+#define SUN8I_AIF2_VOL_CTRL2_DACL_VOL			8
+#define SUN8I_AIF2_VOL_CTRL2_DACR_VOL			0
 #define SUN8I_AIF3_CLK_CTRL_AIF3_CLK_SRC_AIF1		(0x0 << 0)
 #define SUN8I_AIF3_CLK_CTRL_AIF3_CLK_SRC_AIF2		(0x1 << 0)
 #define SUN8I_AIF3_CLK_CTRL_AIF3_CLK_SRC_AIF1CLK	(0x2 << 0)
@@ -102,8 +121,31 @@
 #define SUN8I_ADC_DIG_CTRL_ENAD				15
 #define SUN8I_ADC_DIG_CTRL_ADOUT_DTS			2
 #define SUN8I_ADC_DIG_CTRL_ADOUT_DLY			1
+#define SUN8I_ADC_VOL_CTRL				0x104
+#define SUN8I_ADC_VOL_CTRL_ADCL_VOL			8
+#define SUN8I_ADC_VOL_CTRL_ADCR_VOL			0
+#define SUN8I_HMIC_CTRL1				0x110
+#define SUN8I_HMIC_CTRL1_HMIC_M				12
+#define SUN8I_HMIC_CTRL1_HMIC_N				8
+#define SUN8I_HMIC_CTRL1_MDATA_THRESHOLD_DB		5
+#define SUN8I_HMIC_CTRL1_JACK_OUT_IRQ_EN		4
+#define SUN8I_HMIC_CTRL1_JACK_IN_IRQ_EN			3
+#define SUN8I_HMIC_CTRL1_HMIC_DATA_IRQ_EN		0
+#define SUN8I_HMIC_CTRL2				0x114
+#define SUN8I_HMIC_CTRL2_HMIC_SAMPLE			14
+#define SUN8I_HMIC_CTRL2_HMIC_MDATA_THRESHOLD		8
+#define SUN8I_HMIC_CTRL2_HMIC_SF			6
+#define SUN8I_HMIC_STS					0x118
+#define SUN8I_HMIC_STS_MDATA_DISCARD			13
+#define SUN8I_HMIC_STS_HMIC_DATA			8
+#define SUN8I_HMIC_STS_JACK_OUT_IRQ_ST			4
+#define SUN8I_HMIC_STS_JACK_IN_IRQ_ST			3
+#define SUN8I_HMIC_STS_HMIC_DATA_IRQ_ST			0
 #define SUN8I_DAC_DIG_CTRL				0x120
 #define SUN8I_DAC_DIG_CTRL_ENDA				15
+#define SUN8I_DAC_VOL_CTRL				0x124
+#define SUN8I_DAC_VOL_CTRL_DACL_VOL			8
+#define SUN8I_DAC_VOL_CTRL_DACR_VOL			0
 #define SUN8I_DAC_MXR_SRC				0x130
 #define SUN8I_DAC_MXR_SRC_DACL_MXR_SRC_AIF1DA0L		15
 #define SUN8I_DAC_MXR_SRC_DACL_MXR_SRC_AIF1DA1L		14
@@ -124,6 +166,16 @@
 #define SUN8I_AIF_CLK_CTRL_WORD_SIZ_MASK	GENMASK(5, 4)
 #define SUN8I_AIF_CLK_CTRL_DATA_FMT_MASK	GENMASK(3, 2)
 #define SUN8I_AIF3_CLK_CTRL_AIF3_CLK_SRC_MASK	GENMASK(1, 0)
+#define SUN8I_HMIC_CTRL1_HMIC_M_MASK		GENMASK(15, 12)
+#define SUN8I_HMIC_CTRL1_HMIC_N_MASK		GENMASK(11, 8)
+#define SUN8I_HMIC_CTRL1_MDATA_THRESHOLD_DB_MASK GENMASK(6, 5)
+#define SUN8I_HMIC_CTRL2_HMIC_SAMPLE_MASK	GENMASK(15, 14)
+#define SUN8I_HMIC_CTRL2_HMIC_SF_MASK		GENMASK(7, 6)
+#define SUN8I_HMIC_STS_HMIC_DATA_MASK		GENMASK(12, 8)
+
+#define SUN8I_CODEC_BUTTONS	(SND_JACK_BTN_0|\
+				 SND_JACK_BTN_1|\
+				 SND_JACK_BTN_2)
 
 #define SUN8I_CODEC_PASSTHROUGH_SAMPLE_RATE 48000
 
@@ -158,17 +210,42 @@
 };
 
 struct sun8i_codec_quirks {
-	bool legacy_widgets	: 1;
-	bool lrck_inversion	: 1;
+	bool	bus_clock	: 1;
+	bool	jack_detection	: 1;
+	bool	legacy_widgets	: 1;
+	bool	lrck_inversion	: 1;
 };
 
+enum {
+	SUN8I_JACK_STATUS_DISCONNECTED,
+	SUN8I_JACK_STATUS_WAITING_HBIAS,
+	SUN8I_JACK_STATUS_CONNECTED,
+};
+
+#define AC100_NUM_SUPPLIES 4
+
 struct sun8i_codec {
 	struct regmap			*regmap;
+	struct snd_soc_card		*card;
+	struct clk			*clk_bus;
 	struct clk			*clk_module;
 	const struct sun8i_codec_quirks	*quirks;
 	struct sun8i_codec_aif		aifs[SUN8I_CODEC_NAIFS];
+	struct snd_soc_jack		jack;
+	struct delayed_work		jack_work;
+	int				jack_irq;
+	int				jack_status;
+	int				jack_last_sample;
+	int				jack_last_btn;
+	ktime_t				jack_hbias_ready;
+	int				jack_type;
+	int				last_hmic_irq;
+	struct mutex			jack_mutex;
 	unsigned int			sysclk_rate;
 	int				sysclk_refcnt;
+
+	struct regmap			*ac100_regmap;
+	struct regulator_bulk_data	supplies[AC100_NUM_SUPPLIES];
 };
 
 static struct snd_soc_dai_driver sun8i_codec_dais[];
@@ -178,6 +255,14 @@
 	struct sun8i_codec *scodec = dev_get_drvdata(dev);
 	int ret;
 
+	if (scodec->clk_bus) {
+		ret = clk_prepare_enable(scodec->clk_bus);
+		if (ret) {
+			dev_err(dev, "Failed to enable the bus clock\n");
+			return ret;
+		}
+	}
+
 	regcache_cache_only(scodec->regmap, false);
 
 	ret = regcache_sync(scodec->regmap);
@@ -196,6 +281,9 @@
 	regcache_cache_only(scodec->regmap, true);
 	regcache_mark_dirty(scodec->regmap);
 
+	if (scodec->clk_bus)
+		clk_disable_unprepare(scodec->clk_bus);
+
 	return 0;
 }
 
@@ -561,6 +649,7 @@
 			   SUN8I_AIF_CLK_CTRL_BCLK_DIV_MASK,
 			   bclk_div << SUN8I_AIF_CLK_CTRL_BCLK_DIV);
 
+	if (!scodec->ac100_regmap) {
 	/*
 	 * SYSCLK rate
 	 *
@@ -582,6 +671,7 @@
 	if (!aif->open_streams)
 		scodec->sysclk_refcnt++;
 	scodec->sysclk_rate = sysclk_rate;
+	}
 
 	aif->lrck_div_order = lrck_div_order;
 	aif->sample_rate = sample_rate;
@@ -600,8 +690,11 @@
 	if (aif->open_streams != BIT(substream->stream))
 		goto done;
 
-	clk_rate_exclusive_put(scodec->clk_module);
-	scodec->sysclk_refcnt--;
+	if (!scodec->ac100_regmap) {
+		clk_rate_exclusive_put(scodec->clk_module);
+		scodec->sysclk_refcnt--;
+	}
+
 	aif->lrck_div_order = 0;
 	aif->sample_rate = 0;
 
@@ -696,6 +789,41 @@
 	},
 };
 
+static const DECLARE_TLV_DB_SCALE(sun8i_codec_vol_scale, -12000, 75, 1);
+
+static const struct snd_kcontrol_new sun8i_codec_controls[] = {
+	SOC_DOUBLE_TLV("AIF1 AD0 Capture Volume",
+		       SUN8I_AIF1_VOL_CTRL1,
+		       SUN8I_AIF1_VOL_CTRL1_AD0L_VOL,
+		       SUN8I_AIF1_VOL_CTRL1_AD0R_VOL,
+		       0xc0, 0, sun8i_codec_vol_scale),
+	SOC_DOUBLE_TLV("AIF1 DA0 Playback Volume",
+		       SUN8I_AIF1_VOL_CTRL3,
+		       SUN8I_AIF1_VOL_CTRL3_DA0L_VOL,
+		       SUN8I_AIF1_VOL_CTRL3_DA0R_VOL,
+		       0xc0, 0, sun8i_codec_vol_scale),
+	SOC_DOUBLE_TLV("AIF2 ADC Capture Volume",
+		       SUN8I_AIF2_VOL_CTRL1,
+		       SUN8I_AIF2_VOL_CTRL1_ADCL_VOL,
+		       SUN8I_AIF2_VOL_CTRL1_ADCR_VOL,
+		       0xc0, 0, sun8i_codec_vol_scale),
+	SOC_DOUBLE_TLV("AIF2 DAC Playback Volume",
+		       SUN8I_AIF2_VOL_CTRL2,
+		       SUN8I_AIF2_VOL_CTRL2_DACL_VOL,
+		       SUN8I_AIF2_VOL_CTRL2_DACR_VOL,
+		       0xc0, 0, sun8i_codec_vol_scale),
+	SOC_DOUBLE_TLV("ADC Capture Volume",
+		       SUN8I_ADC_VOL_CTRL,
+		       SUN8I_ADC_VOL_CTRL_ADCL_VOL,
+		       SUN8I_ADC_VOL_CTRL_ADCR_VOL,
+		       0xc0, 0, sun8i_codec_vol_scale),
+	SOC_DOUBLE_TLV("DAC Playback Volume",
+		       SUN8I_DAC_VOL_CTRL,
+		       SUN8I_DAC_VOL_CTRL_DACL_VOL,
+		       SUN8I_DAC_VOL_CTRL_DACR_VOL,
+		       0xc0, 0, sun8i_codec_vol_scale),
+};
+
 static int sun8i_codec_aif_event(struct snd_soc_dapm_widget *w,
 				 struct snd_kcontrol *kcontrol, int event)
 {
@@ -839,8 +967,6 @@
 
 static const struct snd_soc_dapm_widget sun8i_codec_dapm_widgets[] = {
 	/* System Clocks */
-	SND_SOC_DAPM_CLOCK_SUPPLY("mod"),
-
 	SND_SOC_DAPM_SUPPLY("AIF1CLK",
 			    SUN8I_SYSCLK_CTL,
 			    SUN8I_SYSCLK_CTL_AIF1CLK_ENA, 0, NULL, 0),
@@ -1001,8 +1127,6 @@
 
 static const struct snd_soc_dapm_route sun8i_codec_dapm_routes[] = {
 	/* Clock Routes */
-	{ "AIF1CLK", NULL, "mod" },
-
 	{ "SYSCLK", NULL, "AIF1CLK" },
 
 	{ "CLK AIF1", NULL, "AIF1CLK" },
@@ -1172,12 +1296,103 @@
 	{ "AIF1 Slot 0 Right", NULL, "DACR" },
 };
 
+static const struct snd_soc_dapm_widget sun8i_codec_dapm_widgets_sun8i[] = {
+	SND_SOC_DAPM_CLOCK_SUPPLY("mod"),
+};
+
+static const struct snd_soc_dapm_route sun8i_codec_dapm_routes_sun8i[] = {
+	{ "AIF1CLK", NULL, "mod" },
+};
+
+static struct snd_soc_jack_pin sun8i_codec_jack_pins[] = {
+	{
+		.pin	= "Headphone Jack",
+		.mask	= SND_JACK_HEADPHONE,
+	},
+	{
+		.pin	= "Headset Microphone",
+		.mask	= SND_JACK_MICROPHONE,
+	},
+};
+
+static int sun8i_codec_jack_init(struct sun8i_codec *scodec)
+{
+	int pins = 0;
+	int type = 0;
+	int i, ret;
+
+	for (i = 0; i < ARRAY_SIZE(sun8i_codec_jack_pins); ++i) {
+		struct snd_soc_jack_pin *pin = &sun8i_codec_jack_pins[i];
+		struct snd_soc_dapm_widget *w;
+
+		for_each_card_widgets(scodec->card, w) {
+			if (!strcmp(pin->pin, w->name)) {
+				pins |= BIT(i);
+				type |= pin->mask;
+				break;
+			}
+		}
+	}
+
+	if (!type)
+		return 0;
+
+	if (type & SND_JACK_MICROPHONE)
+		type |= SUN8I_CODEC_BUTTONS;
+
+	ret = snd_soc_card_jack_new(scodec->card, "Headset Jack", type,
+				    &scodec->jack, NULL, 0);
+	if (ret)
+		return ret;
+
+	for (i = 0; i < ARRAY_SIZE(sun8i_codec_jack_pins); ++i) {
+		struct snd_soc_jack_pin *pin = &sun8i_codec_jack_pins[i];
+
+		if (pins & BIT(i)) {
+			ret = snd_soc_jack_add_pins(&scodec->jack, 1, pin);
+			if (ret)
+				return ret;
+		}
+	}
+
+	if (type & SND_JACK_MICROPHONE) {
+		struct snd_jack *jack = scodec->jack.jack;
+
+		snd_jack_set_key(jack, SND_JACK_BTN_0, KEY_PLAYPAUSE);
+		snd_jack_set_key(jack, SND_JACK_BTN_1, KEY_VOLUMEUP);
+		snd_jack_set_key(jack, SND_JACK_BTN_2, KEY_VOLUMEDOWN);
+	}
+
+	scodec->jack_type = type;
+
+	return 0;
+}
+
+static int ac100_codec_component_probe(struct snd_soc_component *component);
+
 static int sun8i_codec_component_probe(struct snd_soc_component *component)
 {
 	struct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);
 	struct sun8i_codec *scodec = snd_soc_component_get_drvdata(component);
 	int ret;
 
+	if (scodec->ac100_regmap)
+                return ac100_codec_component_probe(component);
+
+	ret = snd_soc_dapm_new_controls(dapm,
+					sun8i_codec_dapm_widgets_sun8i,
+					ARRAY_SIZE(sun8i_codec_dapm_widgets_sun8i));
+	if (ret)
+		return ret;
+
+	ret = snd_soc_dapm_add_routes(dapm,
+				      sun8i_codec_dapm_routes_sun8i,
+				      ARRAY_SIZE(sun8i_codec_dapm_routes_sun8i));
+	if (ret)
+		return ret;
+
+	scodec->card = component->card;
+
 	/* Add widgets for backward compatibility with old device trees. */
 	if (scodec->quirks->legacy_widgets) {
 		ret = snd_soc_dapm_new_controls(dapm, sun8i_codec_legacy_widgets,
@@ -1211,39 +1426,457 @@
 	/* Program the default sample rate. */
 	sun8i_codec_update_sample_rate(scodec);
 
+	if (scodec->quirks->jack_detection) {
+		ret = sun8i_codec_jack_init(scodec);
+		if (ret)
+			return ret;
+	}
+
+	if (scodec->jack_type) {
+		int irq_mask = BIT(SUN8I_HMIC_CTRL1_JACK_OUT_IRQ_EN) |
+			       BIT(SUN8I_HMIC_CTRL1_JACK_IN_IRQ_EN);
+
+		/* Reserved value required for jack IRQs to trigger. */
+		regmap_write(scodec->regmap, SUN8I_HMIC_CTRL1,
+				   0xf << SUN8I_HMIC_CTRL1_HMIC_N |
+				   0x0 << SUN8I_HMIC_CTRL1_MDATA_THRESHOLD_DB |
+				   0x4 << SUN8I_HMIC_CTRL1_HMIC_M);
+
+		/* Sample the ADC at 128 Hz; bypass smooth filter. */
+		regmap_write(scodec->regmap, SUN8I_HMIC_CTRL2,
+				   0x0 << SUN8I_HMIC_CTRL2_HMIC_SAMPLE |
+				   0x17 << SUN8I_HMIC_CTRL2_HMIC_MDATA_THRESHOLD |
+				   0x0 << SUN8I_HMIC_CTRL2_HMIC_SF);
+
+		/* Do not discard any MDATA, enable user written MDATA threshold. */
+		regmap_write(scodec->regmap, SUN8I_HMIC_STS, 0);
+
+		regmap_update_bits(scodec->regmap, SUN8I_HMIC_CTRL1,
+				   irq_mask, irq_mask);
+
+		enable_irq(scodec->jack_irq);
+	}
+
 	return 0;
 }
 
+static void sun8i_codec_component_remove(struct snd_soc_component *component)
+{
+	struct sun8i_codec *scodec = snd_soc_component_get_drvdata(component);
+
+	if (scodec->jack_type) {
+		int irq_mask = BIT(SUN8I_HMIC_CTRL1_JACK_OUT_IRQ_EN) |
+			       BIT(SUN8I_HMIC_CTRL1_JACK_IN_IRQ_EN)  |
+			       BIT(SUN8I_HMIC_CTRL1_HMIC_DATA_IRQ_EN);
+
+		disable_irq(scodec->jack_irq);
+		cancel_delayed_work_sync(&scodec->jack_work);
+
+		regmap_update_bits(scodec->regmap, SUN8I_HMIC_CTRL1,
+				   irq_mask, 0);
+	}
+}
+
 static const struct snd_soc_component_driver sun8i_soc_component = {
+	.controls		= sun8i_codec_controls,
+	.num_controls		= ARRAY_SIZE(sun8i_codec_controls),
 	.dapm_widgets		= sun8i_codec_dapm_widgets,
 	.num_dapm_widgets	= ARRAY_SIZE(sun8i_codec_dapm_widgets),
 	.dapm_routes		= sun8i_codec_dapm_routes,
 	.num_dapm_routes	= ARRAY_SIZE(sun8i_codec_dapm_routes),
 	.probe			= sun8i_codec_component_probe,
+	.remove			= sun8i_codec_component_remove,
 	.idle_bias_on		= 1,
+	.suspend_bias_off	= 1,
 	.endianness		= 1,
 	.non_legacy_dai_naming	= 1,
 };
 
-static const struct regmap_config sun8i_codec_regmap_config = {
+static bool sun8i_codec_volatile_reg(struct device *dev, unsigned int reg)
+{
+	return reg == SUN8I_HMIC_STS;
+}
+
+static struct regmap_config sun8i_codec_regmap_config = {
 	.reg_bits	= 32,
 	.reg_stride	= 4,
 	.val_bits	= 32,
+	.volatile_reg	= sun8i_codec_volatile_reg,
 	.max_register	= SUN8I_DAC_MXR_SRC,
 
 	.cache_type	= REGCACHE_FLAT,
 };
 
+static void sun8i_codec_set_hmic_bias(struct sun8i_codec *scodec, bool enable)
+{
+	struct snd_soc_dapm_context *dapm = &scodec->card->dapm;
+	int irq_mask = BIT(SUN8I_HMIC_CTRL1_HMIC_DATA_IRQ_EN);
+
+	if (enable)
+		snd_soc_dapm_force_enable_pin(dapm, "HBIAS");
+	else
+		snd_soc_dapm_disable_pin(dapm, "HBIAS");
+	snd_soc_dapm_sync(dapm);
+
+	dev_dbg(scodec->card->dev, "HMIC bias %s\n", enable ? "on" : "off");
+
+	regmap_update_bits(scodec->regmap, SUN8I_HMIC_CTRL1,
+			   irq_mask, enable ? irq_mask : 0);
+}
+
+static void sun8i_codec_jack_work(struct work_struct *work)
+{
+	struct sun8i_codec *scodec = container_of(work, struct sun8i_codec,
+						  jack_work.work);
+	unsigned int mdata;
+	int type;
+
+	mutex_lock(&scodec->jack_mutex);
+
+	if (scodec->jack_status == SUN8I_JACK_STATUS_DISCONNECTED) {
+		if (scodec->last_hmic_irq != SUN8I_HMIC_STS_JACK_IN_IRQ_ST)
+			goto out_unlock;
+
+		scodec->jack_last_sample = -1;
+		scodec->jack_last_btn = 0;
+
+		if (scodec->jack_type & SND_JACK_MICROPHONE) {
+			/*
+			 * If we were in disconnected state, we just enable HBIAS and
+			 * wait 500ms before reading initial HDATA value.
+			 */
+			scodec->jack_hbias_ready = ktime_add_ms(ktime_get(), 600);
+			scodec->jack_status = SUN8I_JACK_STATUS_WAITING_HBIAS;
+			sun8i_codec_set_hmic_bias(scodec, true);
+			queue_delayed_work(system_power_efficient_wq,
+					   &scodec->jack_work,
+					   msecs_to_jiffies(610));
+		} else {
+			type = SND_JACK_HEADPHONE;
+			snd_soc_jack_report(&scodec->jack, 0, scodec->jack_type);
+			scodec->jack_status = SUN8I_JACK_STATUS_CONNECTED;
+		}
+	} else if (scodec->jack_status == SUN8I_JACK_STATUS_WAITING_HBIAS) {
+		/*
+		 * If we're waiting for HBIAS to stabilize, and we get plug-out
+		 * interrupt and nothing more for > 100ms, just cancel the
+		 * initialization.
+		 */
+		if (scodec->last_hmic_irq == SUN8I_HMIC_STS_JACK_OUT_IRQ_ST) {
+			scodec->jack_status = SUN8I_JACK_STATUS_DISCONNECTED;
+			sun8i_codec_set_hmic_bias(scodec, false);
+			goto out_unlock;
+		}
+
+		/*
+		 * If we're not done waiting for things to stabilize, wait more.
+		 */
+		if (!ktime_after(ktime_get(), scodec->jack_hbias_ready)) {
+			s64 msecs = ktime_ms_delta(scodec->jack_hbias_ready, ktime_get());
+
+			queue_delayed_work(system_power_efficient_wq,
+					   &scodec->jack_work,
+					   msecs_to_jiffies(msecs + 10));
+			goto out_unlock;
+		}
+
+		/*
+		 * Everything is stabilized, determine jack type and report it.
+		 */
+		regmap_read(scodec->regmap, SUN8I_HMIC_STS, &mdata);
+		mdata &= SUN8I_HMIC_STS_HMIC_DATA_MASK;
+		mdata >>= SUN8I_HMIC_STS_HMIC_DATA;
+
+		regmap_write(scodec->regmap, SUN8I_HMIC_STS, 0);
+
+		if (mdata < 0x10) {
+			type = SND_JACK_HEADPHONE;
+
+			sun8i_codec_set_hmic_bias(scodec, false);
+		} else {
+			type = SND_JACK_HEADSET;
+
+			/* Set MDATA threshold for triggering DATA interrupts
+			 * slightly bellow the initial value read at connection
+			 * time. This assumes that user is not pressing a button
+			 * when connecting the jack cable. It's an unlinkely
+			 * situation, unless the person has 3 hands or more.
+			 */
+			/*
+			pr_err("jack: new mdata threshold: %#x\n", mdata);
+			regmap_write(scodec->regmap, SUN8I_HMIC_CTRL2,
+					   0x0 << SUN8I_HMIC_CTRL2_HMIC_SAMPLE |
+					   (mdata - 3) << SUN8I_HMIC_CTRL2_HMIC_MDATA_THRESHOLD |
+					   0x0 << SUN8I_HMIC_CTRL2_HMIC_SF);
+			   */
+		}
+
+		snd_soc_jack_report(&scodec->jack, type, scodec->jack_type);
+		scodec->jack_status = SUN8I_JACK_STATUS_CONNECTED;
+
+		pr_err("jack: plug-in reported\n");
+	} else if (scodec->jack_status == SUN8I_JACK_STATUS_CONNECTED) {
+		if (scodec->last_hmic_irq == SUN8I_HMIC_STS_JACK_OUT_IRQ_ST) {
+			scodec->jack_status = SUN8I_JACK_STATUS_DISCONNECTED;
+			if (scodec->jack_type & SND_JACK_MICROPHONE)
+				sun8i_codec_set_hmic_bias(scodec, false);
+
+			snd_soc_jack_report(&scodec->jack, 0, scodec->jack_type);
+			pr_err("jack: plug-out reported\n");
+		}
+	}
+
+out_unlock:
+	mutex_unlock(&scodec->jack_mutex);
+}
+
+static irqreturn_t sun8i_codec_jack_irq(int irq, void *dev_id)
+{
+	struct sun8i_codec *scodec = dev_id;
+	unsigned int status;
+
+	mutex_lock(&scodec->jack_mutex);
+
+	regmap_read(scodec->regmap, SUN8I_HMIC_STS, &status);
+	regmap_write(scodec->regmap, SUN8I_HMIC_STS, status);
+
+	if (status & BIT(SUN8I_HMIC_STS_JACK_OUT_IRQ_ST)) {
+		pr_err("jack: irq plug-out\n");
+
+		scodec->last_hmic_irq = SUN8I_HMIC_STS_JACK_OUT_IRQ_ST;
+		queue_delayed_work(system_power_efficient_wq,
+				   &scodec->jack_work,
+				   msecs_to_jiffies(100));
+	} else if (status & BIT(SUN8I_HMIC_STS_JACK_IN_IRQ_ST)) {
+		pr_err("jack: irq plug-in\n");
+
+		scodec->last_hmic_irq = SUN8I_HMIC_STS_JACK_IN_IRQ_ST;
+		queue_delayed_work(system_power_efficient_wq,
+				   &scodec->jack_work,
+				   msecs_to_jiffies(100));
+	} else if (status & BIT(SUN8I_HMIC_STS_HMIC_DATA_IRQ_ST)) {
+		if (scodec->jack_status == SUN8I_JACK_STATUS_CONNECTED) {
+			unsigned int value;
+			int type = SND_JACK_HEADSET;
+			int btn_chg = 0;
+
+			regmap_read(scodec->regmap, SUN8I_HMIC_STS, &value);
+			value  &= SUN8I_HMIC_STS_HMIC_DATA_MASK;
+			value >>= SUN8I_HMIC_STS_HMIC_DATA;
+
+			if (value < 0x2)
+				type |= SND_JACK_BTN_0;
+			else if (value < 0x7)
+				type |= SND_JACK_BTN_1;
+			else if (value < 0x10)
+				type |= SND_JACK_BTN_2;
+
+			if (scodec->jack_last_sample >= 0 && scodec->jack_last_sample == value) {
+				btn_chg = (scodec->jack_last_btn ^ type) & 0x7000;
+				scodec->jack_last_btn = type;
+
+				//XXX: temporary for debugging
+				if (btn_chg) {
+					if (btn_chg & SND_JACK_BTN_0)
+						pr_err("jack: key_%spress BTN_0 (%#x)\n", type & SND_JACK_BTN_0 ? "" : "de", value);
+					if (btn_chg & SND_JACK_BTN_1)
+						pr_err("jack: key_%spress BTN_1 (%#x)\n", type & SND_JACK_BTN_1 ? "" : "de", value);
+					if (btn_chg & SND_JACK_BTN_2)
+						pr_err("jack: key_%spress BTN_2 (%#x)\n", type & SND_JACK_BTN_2 ? "" : "de", value);
+				}
+
+				snd_soc_jack_report(&scodec->jack, type, scodec->jack_type);
+			}
+
+			scodec->jack_last_sample = value;
+		}
+	} else {
+		mutex_unlock(&scodec->jack_mutex);
+		return IRQ_NONE;
+	}
+
+	mutex_unlock(&scodec->jack_mutex);
+	return IRQ_HANDLED;
+}
+
+/* AC100 Codec Support (digital parts) */
+
+static int sun8i_codec_ac100_regmap_read(void *context, unsigned int reg, unsigned int *val)
+{
+	struct sun8i_codec *scodec = context;
+
+	return regmap_read(scodec->ac100_regmap, reg / 4, val);
+}
+
+static int sun8i_codec_ac100_regmap_write(void *context, unsigned int reg, unsigned int val)
+{
+	struct sun8i_codec *scodec = context;
+
+	return regmap_write(scodec->ac100_regmap, reg / 4, val);
+}
+
+static struct regmap_bus sun8i_codec_ac100_regmap_bus = {
+	.reg_write = sun8i_codec_ac100_regmap_write,
+	.reg_read = sun8i_codec_ac100_regmap_read,
+};
+
+static const char *const ac100_supply_names[AC100_NUM_SUPPLIES] = {
+	"LDOIN",
+	"AVCC",
+	"VDDIO1",
+	"VDDIO2",
+};
+
+#define AC100_SYSCLK_CTRL_PLLCLK_ENA_OFF                        15
+#define AC100_SYSCLK_CTRL_PLLCLK_ENA_MASK                       BIT(15)
+#define AC100_SYSCLK_CTRL_PLLCLK_ENA_DISABLED                   0
+#define AC100_SYSCLK_CTRL_PLLCLK_ENA_ENABLED                    BIT(15)
+#define AC100_SYSCLK_CTRL_PLLCLK_SRC_OFF                        12
+#define AC100_SYSCLK_CTRL_PLLCLK_SRC_MASK                       GENMASK(13, 12)
+#define AC100_SYSCLK_CTRL_PLLCLK_SRC_MCLK1                      (0x0 << 12)
+#define AC100_SYSCLK_CTRL_PLLCLK_SRC_MCLK2                      (0x1 << 12)
+#define AC100_SYSCLK_CTRL_PLLCLK_SRC_BCLK1                      (0x2 << 12)
+#define AC100_SYSCLK_CTRL_PLLCLK_SRC_BCLK2                      (0x3 << 12)
+#define AC100_SYSCLK_CTRL_I2S1CLK_ENA_OFF                       11
+#define AC100_SYSCLK_CTRL_I2S1CLK_ENA_MASK                      BIT(11)
+#define AC100_SYSCLK_CTRL_I2S1CLK_ENA_DISABLED                  0
+#define AC100_SYSCLK_CTRL_I2S1CLK_ENA_ENABLED                   BIT(11)
+#define AC100_SYSCLK_CTRL_I2S1CLK_SRC_OFF                       8
+#define AC100_SYSCLK_CTRL_I2S1CLK_SRC_MASK                      GENMASK(9, 8)
+#define AC100_SYSCLK_CTRL_I2S1CLK_SRC_MCLK1                     (0x0 << 8)
+#define AC100_SYSCLK_CTRL_I2S1CLK_SRC_MCLK2                     (0x1 << 8)
+#define AC100_SYSCLK_CTRL_I2S1CLK_SRC_PLL                       (0x2 << 8)
+#define AC100_SYSCLK_CTRL_I2S2CLK_ENA_OFF                       7
+#define AC100_SYSCLK_CTRL_I2S2CLK_ENA_MASK                      BIT(7)
+#define AC100_SYSCLK_CTRL_I2S2CLK_ENA_DISABLED                  0
+#define AC100_SYSCLK_CTRL_I2S2CLK_ENA_ENABLED                   BIT(7)
+#define AC100_SYSCLK_CTRL_I2S2CLK_SRC_OFF                       4
+#define AC100_SYSCLK_CTRL_I2S2CLK_SRC_MASK                      GENMASK(5, 4)
+#define AC100_SYSCLK_CTRL_I2S2CLK_SRC_MCLK1                     (0x0 << 4)
+#define AC100_SYSCLK_CTRL_I2S2CLK_SRC_MCLK2                     (0x1 << 4)
+#define AC100_SYSCLK_CTRL_I2S2CLK_SRC_PLL                       (0x2 << 4)
+#define AC100_SYSCLK_CTRL_SYSCLK_ENA_OFF                        3
+#define AC100_SYSCLK_CTRL_SYSCLK_ENA_MASK                       BIT(3)
+#define AC100_SYSCLK_CTRL_SYSCLK_ENA_DISABLED                   0
+#define AC100_SYSCLK_CTRL_SYSCLK_ENA_ENABLED                    BIT(3)
+#define AC100_SYSCLK_CTRL_SYSCLK_SRC_OFF                        0
+#define AC100_SYSCLK_CTRL_SYSCLK_SRC_MASK                       BIT(0)
+#define AC100_SYSCLK_CTRL_SYSCLK_SRC_I2S1CLK                    0
+#define AC100_SYSCLK_CTRL_SYSCLK_SRC_I2S2CLK                    BIT(0)
+
+
+static int ac100_codec_component_probe(struct snd_soc_component *component)
+{
+	struct sun8i_codec *scodec = snd_soc_component_get_drvdata(component);
+
+        // The system clock(SYSCLK) of AC100 must be 512*fs(fs=48KHz or 44.1KHz)
+
+        // Source clocks from the SoC
+
+        regmap_update_bits(scodec->ac100_regmap, AC100_SYSCLK_CTRL,
+                            AC100_SYSCLK_CTRL_I2S1CLK_SRC_MASK,
+                            AC100_SYSCLK_CTRL_I2S1CLK_SRC_MCLK1);
+        regmap_update_bits(scodec->ac100_regmap, AC100_SYSCLK_CTRL,
+                            AC100_SYSCLK_CTRL_I2S2CLK_SRC_MASK,
+                            AC100_SYSCLK_CTRL_I2S2CLK_SRC_MCLK1);
+        regmap_update_bits(scodec->ac100_regmap, AC100_SYSCLK_CTRL,
+                            AC100_SYSCLK_CTRL_SYSCLK_SRC_MASK,
+                            AC100_SYSCLK_CTRL_SYSCLK_SRC_I2S1CLK);
+
+	/* Program the default sample rate. */
+	sun8i_codec_update_sample_rate(scodec);
+
+        return 0;
+}
+
+static int sun8i_codec_probe_ac100(struct platform_device *pdev)
+{
+	struct ac100_dev *ac100 = dev_get_drvdata(pdev->dev.parent);
+	struct device* dev = &pdev->dev;
+	struct sun8i_codec *scodec;
+	int ret, i;
+
+	scodec = devm_kzalloc(dev, sizeof(*scodec), GFP_KERNEL);
+	if (!scodec)
+		return -ENOMEM;
+
+	scodec->quirks = of_device_get_match_data(&pdev->dev);
+	scodec->ac100_regmap = ac100->regmap;
+
+	platform_set_drvdata(pdev, scodec);
+
+	// caching is done by the MFD regmap
+	sun8i_codec_regmap_config.cache_type = REGCACHE_NONE;
+
+	// we need to create a custom regmap_bus that will map reads/writes to the MFD regmap
+	scodec->regmap = __regmap_lockdep_wrapper(__devm_regmap_init,
+		 "ac100-regmap-codec", dev,
+		  &sun8i_codec_ac100_regmap_bus, scodec,
+		  &sun8i_codec_regmap_config);
+	if (IS_ERR(scodec->regmap)) {
+		dev_err(dev, "Failed to create our regmap\n");
+		return PTR_ERR(scodec->regmap);
+	}
+
+	for (i = 0; i < ARRAY_SIZE(scodec->supplies); i++)
+		scodec->supplies[i].supply = ac100_supply_names[i];
+
+        ret = devm_regulator_bulk_get(dev, ARRAY_SIZE(scodec->supplies),
+                                      scodec->supplies);
+        if (ret != 0) {
+              if (ret != -EPROBE_DEFER)
+                       dev_err(dev, "Failed to request supplies: %d\n", ret);
+                return ret;
+        }
+
+	ret = regulator_bulk_enable(ARRAY_SIZE(scodec->supplies),
+				    scodec->supplies);
+	if (ret != 0) {
+		dev_err(dev, "Failed to enable supplies: %d\n", ret);
+		return ret;
+	}
+
+	ret = devm_snd_soc_register_component(dev, &sun8i_soc_component,
+					      sun8i_codec_dais,
+					      ARRAY_SIZE(sun8i_codec_dais));
+	if (ret) {
+		dev_err(dev, "Failed to register codec\n");
+		goto err_disable_reg;
+	}
+
+	return ret;
+
+err_disable_reg:
+	regulator_bulk_disable(ARRAY_SIZE(scodec->supplies),
+			       scodec->supplies);
+	return ret;
+}
+
 static int sun8i_codec_probe(struct platform_device *pdev)
 {
 	struct sun8i_codec *scodec;
 	void __iomem *base;
 	int ret;
 
+	if (of_device_is_compatible(pdev->dev.of_node, "x-powers,ac100-codec"))
+		return sun8i_codec_probe_ac100(pdev);
+
 	scodec = devm_kzalloc(&pdev->dev, sizeof(*scodec), GFP_KERNEL);
 	if (!scodec)
 		return -ENOMEM;
 
+	scodec->quirks = of_device_get_match_data(&pdev->dev);
+
+	platform_set_drvdata(pdev, scodec);
+
+	if (scodec->quirks->bus_clock) {
+		scodec->clk_bus = devm_clk_get(&pdev->dev, "bus");
+		if (IS_ERR(scodec->clk_bus)) {
+			dev_err(&pdev->dev, "Failed to get the bus clock\n");
+			return PTR_ERR(scodec->clk_bus);
+		}
+	}
+
 	scodec->clk_module = devm_clk_get(&pdev->dev, "mod");
 	if (IS_ERR(scodec->clk_module)) {
 		dev_err(&pdev->dev, "Failed to get the module clock\n");
@@ -1256,17 +1889,31 @@
 		return PTR_ERR(base);
 	}
 
-	scodec->regmap = devm_regmap_init_mmio_clk(&pdev->dev, "bus", base,
-						   &sun8i_codec_regmap_config);
+	scodec->regmap = devm_regmap_init_mmio(&pdev->dev, base,
+					       &sun8i_codec_regmap_config);
 	if (IS_ERR(scodec->regmap)) {
 		dev_err(&pdev->dev, "Failed to create our regmap\n");
 		return PTR_ERR(scodec->regmap);
 	}
 
-	scodec->quirks = of_device_get_match_data(&pdev->dev);
+	if (scodec->quirks->jack_detection) {
+		scodec->jack_irq = platform_get_irq(pdev, 0);
+		if (scodec->jack_irq < 0)
+			return scodec->jack_irq;
+
+		irq_set_status_flags(scodec->jack_irq, IRQ_NOAUTOEN);
+		ret = devm_request_threaded_irq(&pdev->dev, scodec->jack_irq,
+						NULL, sun8i_codec_jack_irq,
+						IRQF_ONESHOT,
+						dev_name(&pdev->dev), scodec);
+		if (ret)
+			return ret;
 
-	platform_set_drvdata(pdev, scodec);
+		INIT_DELAYED_WORK(&scodec->jack_work, sun8i_codec_jack_work);
+		mutex_init(&scodec->jack_mutex);
+	}
 
+	regcache_cache_only(scodec->regmap, true);
 	pm_runtime_enable(&pdev->dev);
 	if (!pm_runtime_enabled(&pdev->dev)) {
 		ret = sun8i_codec_runtime_resume(&pdev->dev);
@@ -1296,6 +1943,14 @@
 
 static int sun8i_codec_remove(struct platform_device *pdev)
 {
+	struct sun8i_codec *scodec = dev_get_drvdata(&pdev->dev);
+
+	if (scodec->ac100_regmap) {
+		regulator_bulk_disable(ARRAY_SIZE(scodec->supplies),
+				       scodec->supplies);
+		return 0;
+	}
+
 	pm_runtime_disable(&pdev->dev);
 	if (!pm_runtime_status_suspended(&pdev->dev))
 		sun8i_codec_runtime_suspend(&pdev->dev);
@@ -1304,16 +1959,23 @@
 }
 
 static const struct sun8i_codec_quirks sun8i_a33_quirks = {
+	.bus_clock	= true,
 	.legacy_widgets	= true,
 	.lrck_inversion	= true,
 };
 
 static const struct sun8i_codec_quirks sun50i_a64_quirks = {
+	.bus_clock	= true,
+	.jack_detection	= true,
+};
+
+static const struct sun8i_codec_quirks ac100_quirks = {
 };
 
 static const struct of_device_id sun8i_codec_of_match[] = {
 	{ .compatible = "allwinner,sun8i-a33-codec", .data = &sun8i_a33_quirks },
 	{ .compatible = "allwinner,sun50i-a64-codec", .data = &sun50i_a64_quirks },
+	{ .compatible = "x-powers,ac100-codec", .data = &ac100_quirks },
 	{}
 };
 MODULE_DEVICE_TABLE(of, sun8i_codec_of_match);
diff -Nuar -r --no-dereference linux-5.15.139/sound/soc/codecs/ec25.c linux/sound/soc/codecs/ec25.c
--- linux-5.15.139/sound/soc/codecs/ec25.c	1970-01-01 08:00:00.000000000 +0800
+++ linux/sound/soc/codecs/ec25.c	2024-01-03 16:06:25.935131000 +0800
@@ -0,0 +1,95 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+#include <linux/module.h>
+#include <sound/soc.h>
+
+static const struct snd_soc_dapm_widget ec25_dapm_widgets[] = {
+	SND_SOC_DAPM_OUTPUT("AOUT"),
+	SND_SOC_DAPM_INPUT("AIN"),
+};
+
+static const struct snd_soc_dapm_route ec25_dapm_routes[] = {
+	{ "AOUT", NULL, "Playback" },
+	{ "AOUT", NULL, "Wideband Playback" },
+	{ "Capture", NULL, "AIN" },
+	{ "Wideband Capture", NULL, "AIN" },
+};
+
+static const struct snd_soc_component_driver ec25_component_driver = {
+	.dapm_widgets		= ec25_dapm_widgets,
+	.num_dapm_widgets	= ARRAY_SIZE(ec25_dapm_widgets),
+	.dapm_routes		= ec25_dapm_routes,
+	.num_dapm_routes	= ARRAY_SIZE(ec25_dapm_routes),
+	.endianness		= 1,
+	.non_legacy_dai_naming	= 1,
+};
+
+static struct snd_soc_dai_driver ec25_dais[] = {
+	{
+		.name = "ec25",
+		.capture = {
+			.stream_name	= "Capture",
+			.channels_min	= 1,
+			.channels_max	= 1,
+			.rates		= SNDRV_PCM_RATE_8000,
+			.formats	= SNDRV_PCM_FMTBIT_S16_LE,
+		},
+		.playback = {
+			.stream_name	= "Playback",
+			.channels_min	= 1,
+			.channels_max	= 1,
+			.rates		= SNDRV_PCM_RATE_8000,
+			.formats	= SNDRV_PCM_FMTBIT_S16_LE,
+		},
+		.symmetric_rate = 1,
+		.symmetric_channels = 1,
+		.symmetric_sample_bits = 1,
+	},
+	{
+		.name = "ec25-wb",
+		.capture = {
+			.stream_name	= "Wideband Capture",
+			.channels_min	= 1,
+			.channels_max	= 1,
+			.rates		= SNDRV_PCM_RATE_16000,
+			.formats	= SNDRV_PCM_FMTBIT_S16_LE,
+		},
+		.playback = {
+			.stream_name	= "Wideband Playback",
+			.channels_min	= 1,
+			.channels_max	= 1,
+			.rates		= SNDRV_PCM_RATE_16000,
+			.formats	= SNDRV_PCM_FMTBIT_S16_LE,
+		},
+		.symmetric_rate = 1,
+		.symmetric_channels = 1,
+		.symmetric_sample_bits = 1,
+	},
+};
+
+static int ec25_codec_probe(struct platform_device *pdev)
+{
+	return devm_snd_soc_register_component(&pdev->dev, &ec25_component_driver,
+					       ec25_dais, ARRAY_SIZE(ec25_dais));
+}
+
+static const struct of_device_id ec25_codec_of_match[] = {
+	{ .compatible = "quectel,ec25", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, ec25_codec_of_match);
+
+static struct platform_driver ec25_codec_driver = {
+	.driver	= {
+		.name		= "ec25",
+		.of_match_table	= of_match_ptr(ec25_codec_of_match),
+	},
+	.probe	= ec25_codec_probe,
+};
+
+module_platform_driver(ec25_codec_driver);
+
+MODULE_DESCRIPTION("ASoC ec25 driver");
+MODULE_AUTHOR("Samuel Holland <samuel@sholland.org>");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:ec25");
diff -Nuar -r --no-dereference linux-5.15.139/sound/soc/codecs/acx00.h linux/sound/soc/codecs/acx00.h
--- linux-5.15.139/sound/soc/codecs/acx00.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/sound/soc/codecs/acx00.h	2024-01-03 16:06:25.935131000 +0800
@@ -0,0 +1,356 @@
+/*
+ * sound\soc\codecs\acx00.h
+ * (C) Copyright 2012-2016
+ * Allwinner Technology Co., Ltd. <www.allwinnertech.com>
+ * Wolfgang Huang <huangjinhui@allwinnertech.com>
+ *
+ * some simple description for this code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+
+#ifndef __ACX00_H_
+#define __ACX00_H_
+
+/* ACX00 register offset list */
+#define AC_SYS_CLK_CTL		0x2000
+#define AC_SYS_MOD_RST		0x2002
+#define AC_SYS_SR_CTL		0x2004
+/* Left blank */
+#define AC_I2S_CTL		0x2100
+#define AC_I2S_CLK		0x2102
+#define AC_I2S_FMT0		0x2104
+/* Left blank */
+#define AC_I2S_FMT1		0x2108
+/* Left blank */
+#define AC_I2S_MIXER_SRC	0x2114
+#define AC_I2S_MIXER_GAIN	0x2116
+#define AC_I2S_DAC_VOL		0x2118
+#define AC_I2S_ADC_VOL		0x211A
+/* Left blank */
+#define AC_DAC_CTL		0x2200
+#define AC_DAC_MIXER_SRC	0x2202
+#define AC_DAC_MIXER_GAIN	0x2204
+/* Left blank */
+#define AC_OUT_MIXER_CTL	0x2220
+#define AC_OUT_MIXER_SRC	0x2222
+#define AC_LINEOUT_CTL		0x2224
+/* Left blank */
+#define AC_ADC_CTL		0x2300
+/* Left blank */
+#define AC_MICBIAS_CTL		0x2310
+/* Left blank */
+#define AC_ADC_MIC_CTL		0x2320
+#define AC_ADC_MIXER_SRC	0x2322
+/* Left blank */
+#define AC_BIAS_CTL		0x232A
+#define AC_ANALOG_PROF_CTL	0x232C
+/* Left blank */
+#define AC_ADC_DAPL_CTRL	0x2500
+#define AC_ADC_DAPR_CTRL	0x2502
+#define AC_ADC_DAPLSTA		0x2504
+#define AC_ADC_DAPRSTA		0x2506
+#define AC_ADC_DAP_LTL		0x2508
+#define AC_ADC_DAP_RTL		0x250A
+#define AC_ADC_DAP_LHAC		0x250C
+#define AC_ADC_DAP_LLAC		0x250E
+#define AC_ADC_DAP_RHAC		0x2510
+#define AC_ADC_DAP_RLAC		0x2512
+#define AC_ADC_DAP_LDT		0x2514
+#define AC_ADC_DAP_LAT		0x2516
+#define AC_ADC_DAP_RDT		0x2518
+#define AC_ADC_DAP_RAT		0x251A
+#define AC_ADC_DAP_NTH		0x251C
+#define AC_ADC_DAP_LHNAC	0x251E
+#define AC_ADC_DAP_LLNAC	0x2520
+#define AC_ADC_DAP_RHNAC	0x2522
+#define AC_ADC_DAP_RLNAC	0x2524
+#define AC_ADC_DAP_HHPFC	0x2526
+#define AC_ADC_DAP_LHPFC	0x2528
+#define AC_ADC_DAP_OPT		0x252A
+/* Left blank */
+#define AC_AGC_SEL		0x2480
+/* Left blank */
+#define AC_ADC_DAPL_CTRL	0x2500
+#define AC_ADC_DAPR_CTRL	0x2502
+#define AC_ADC_DAPLSTA		0x2504
+#define AC_ADC_DAPRSTA		0x2506
+#define AC_ADC_DAP_LTL		0x2508
+#define AC_ADC_DAP_RTL		0x250A
+#define AC_ADC_DAP_LHAC		0x250C
+#define AC_ADC_DAP_LLAC		0x250E
+#define AC_ADC_DAP_RHAC		0x2510
+#define AC_ADC_DAP_RLAC		0x2512
+#define AC_ADC_DAP_LDT		0x2514
+#define AC_ADC_DAP_LAT		0x2516
+#define AC_ADC_DAP_RDT		0x2518
+#define AC_ADC_DAP_RAT		0x251A
+#define AC_ADC_DAP_NTH		0x251C
+#define AC_ADC_DAP_LHNAC	0x251E
+#define AC_ADC_DAP_LLNAC	0x2520
+#define AC_ADC_DAP_RHNAC	0x2522
+#define AC_ADC_DAP_RLNAC	0x2524
+#define AC_ADC_DAP_HHPFC	0x2526
+#define AC_ADC_DAP_LHPFC	0x2528
+#define AC_ADC_DAP_OPT		0x252A
+/* Left blank */
+#define AC_DRC_SEL		0x2f80
+/* Left blank */
+#define AC_DRC_CHAN_CTRL	0x3000
+#define AC_DRC_HHPFC		0x3002
+#define AC_DRC_LHPFC		0x3004
+#define AC_DRC_CTRL		0x3006
+#define AC_DRC_LPFHAT		0x3008
+#define AC_DRC_LPFLAT		0x300A
+#define AC_DRC_RPFHAT		0x300C
+#define AC_DRC_RPFLAT		0x300E
+#define AC_DRC_LPFHRT		0x3010
+#define AC_DRC_LPFLRT		0x3012
+#define AC_DRC_RPFHRT		0x3014
+#define AC_DRC_RPFLRT		0x3016
+#define AC_DRC_LRMSHAT		0x3018
+#define AC_DRC_LRMSLAT		0x301A
+#define AC_DRC_RRMSHAT		0x301C
+#define AC_DRC_RRMSLAT		0x301E
+#define AC_DRC_HCT		0x3020
+#define AC_DRC_LCT		0x3022
+#define AC_DRC_HKC		0x3024
+#define AC_DRC_LKC		0x3026
+#define AC_DRC_HOPC		0x3028
+#define AC_DRC_LOPC		0x302A
+#define AC_DRC_HLT		0x302C
+#define AC_DRC_LLT		0x302E
+#define AC_DRC_HKI		0x3030
+#define AC_DRC_LKI		0x3032
+#define AC_DRC_HOPL		0x3034
+#define AC_DRC_LOPL		0x3036
+#define AC_DRC_HET		0x3038
+#define AC_DRC_LET		0x303A
+#define AC_DRC_HKE		0x303C
+#define AC_DRC_LKE		0x303E
+#define AC_DRC_HOPE		0x3040
+#define AC_DRC_LOPE		0x3042
+#define AC_DRC_HKN		0x3044
+#define AC_DRC_LKN		0x3046
+#define AC_DRC_SFHAT		0x3048
+#define AC_DRC_SFLAT		0x304A
+#define AC_DRC_SFHRT		0x304C
+#define AC_DRC_SFLRT		0x304E
+#define AC_DRC_MXGHS		0x3050
+#define AC_DRC_MXGLS		0x3052
+#define AC_DRC_MNGHS		0x3054
+#define AC_DRC_MNGLS		0x3056
+#define AC_DRC_EPSHC		0x3058
+#define AC_DRC_EPSLC		0x305A
+#define AC_DRC_OPT		0x305C
+#define AC_DRC_HPFHGAIN		0x305E
+#define AC_DRC_HPFLGAIN		0x3060
+#define AC_DRC_BISTCR		0x3100
+#define AC_DRC_BISTST		0x3102
+
+/* AC_SYS_CLK_CTL : 0x2000 */
+#define SYS_CLK_I2S		15
+#define SYS_CLK_AGC		7
+#define SYS_CLK_DRC		6
+#define SYS_CLK_ADC		3
+#define SYS_CLK_DAC		2
+
+/* AC_SYS_MOD_RST : 0x2002 */
+#define MOD_RST_I2S		15
+#define MOD_RST_AGC		7
+#define MOD_RST_DRC		6
+#define MOD_RST_ADC		3
+#define MOD_RST_DAC		2
+
+/* AC_SYS_SR_CTL : 0x2004 */
+#define SYS_SR_BIT		0
+#define SYS_SR_MASK		0xF
+#define SYS_SR_BIT_0		0	/* 8000 */
+#define SYS_SR_BIT_1		1	/* 11025 */
+#define SYS_SR_BIT_2		2	/* 12000 */
+#define SYS_SR_BIT_3		3	/* 16000 */
+#define SYS_SR_BIT_4		4	/* 22050 */
+#define SYS_SR_BIT_5		5	/* 24000 */
+#define SYS_SR_BIT_6		6	/* 32000 */
+#define SYS_SR_BIT_7		7	/* 44100 */
+#define SYS_SR_BIT_8		8	/* 48000 */
+#define SYS_SR_BIT_9		9	/* 96000 */
+#define SYS_SR_BIT_10		10	/* 192000 */
+
+/* AC_I2S_CTL : 0x2100 */
+#define I2S_SDO0_EN		3
+#define I2S_TX_EN		2
+#define I2S_RX_EN		1
+#define I2S_GEN			0
+
+/* AC_I2S_CLK : 0x2102 */
+#define I2S_BCLK_OUT		15
+#define I2S_LRCK_OUT		14
+#define I2S_BLCK_DIV		10
+#define I2S_LRCK_PERIOD		0
+/* BCLK DIV Define */
+#define I2S_BCLK_DIV_MASK	0xF
+#define I2S_BCLK_DIV_1		1
+#define I2S_BCLK_DIV_2		2
+#define I2S_BCLK_DIV_3		3
+#define I2S_BCLK_DIV_4		4
+#define I2S_BCLK_DIV_5		5
+#define I2S_BCLK_DIV_6		6
+#define I2S_BCLK_DIV_7		7
+#define I2S_BCLK_DIV_8		8
+#define I2S_BCLK_DIV_9		9
+#define I2S_BCLK_DIV_10		10
+#define I2S_BCLK_DIV_11		11
+#define I2S_BCLK_DIV_12		12
+#define I2S_BCLK_DIV_13		13
+#define I2S_BCLK_DIV_14		14
+#define I2S_BCLK_DIV_15		15
+#define I2S_LRCK_PERIOD_MASK	0x3FF
+
+/* AC_I2S_FMT0 : 0x2104 */
+#define I2S_FMT_MODE		14
+#define I2S_FMT_TX_OFFSET	10
+#define I2S_FMT_RX_OFFSET	8
+#define I2S_FMT_SAMPLE		4
+#define I2S_FMT_SLOT_WIDTH	1
+#define I2S_FMT_LOOP		0
+
+/* AC_I2S_FMT1 : 0x2108 */
+#define I2S_FMT_BCLK_POLAR	15
+#define I2S_FMT_LRCK_POLAR	14
+#define I2S_FMT_EDGE_TRANSFER	13
+#define I2S_FMT_RX_MLS		11
+#define I2S_FMT_TX_MLS		10
+#define I2S_FMT_EXTEND		9
+#define I2S_FMT_LRCK_WIDTH	4	/* PCM long/short Frame */
+#define I2S_MFT_RX_PDM		2
+#define I2S_FMT_TX_PDM		0
+
+/* AC_I2S_MIXER_SRC : 0x2114 */
+#define I2S_MIXERL_SRC_DAC	13
+#define I2S_MIXERL_SRC_ADC	12
+#define I2S_MIXERR_SRC_DAC	9
+#define I2S_MIXERR_SRC_ADC	8
+
+/* AC_I2S_MIXER_GAIN : 0x2116 */
+#define I2S_MIXERL_GAIN_DAC	13
+#define I2S_MIXERL_GAIN_ADC	12
+#define I2S_MIXERR_GAIN_DAC	9
+#define I2S_MIXERR_GAIN_ADC	8
+
+
+/* AC_I2S_DAC_VOL : 0x2118 */
+#define I2S_DACL_VOL		8
+#define I2S_DACR_VOL		0
+
+/* AC_I2S_ADC_VOL : 0x211A */
+#define I2S_ADCL_VOL		8
+#define I2S_ADCR_VOL		0
+
+/* AC_DAC_CTL : 0x2200 */
+#define DAC_CTL_DAC_EN		15
+#define DAC_CTL_HPF_EN		14
+#define DAC_CTL_FIR			13
+#define DAC_CTL_MODQU		8
+
+/* AC_DAC_MIXER_SRC : 0x2202 */
+#define DAC_MIXERL_SRC_DAC	13
+#define DAC_MIXERL_SRC_ADC	12
+#define DAC_MIXERR_SRC_DAC	9
+#define DAC_MIXERR_SRC_ADC	8
+
+/* AC_DAC_MIXER_GAIN : 0x2204 */
+#define DAC_MIXERL_GAIN_DAC	13
+#define DAC_MIXERL_GAIN_ADC	12
+#define DAC_MIXERR_GAIN_DAC	9
+#define DAC_MIXERR_GAIN_ADC	8
+
+/* AC_OUT_MIXER_CTL : 0x2220 */
+#define OUT_MIXER_DACR_EN	15
+#define OUT_MIXER_DACL_EN	14
+#define OUT_MIXER_RMIX_EN	13
+#define OUT_MIXER_LMIX_EN	12
+#define OUT_MIXER_LINE_VOL	8
+#define OUT_MIXER_MIC1_VOL	4
+#define OUT_MIXER_MIC2_VOL	0
+
+/* AC_OUT_MIXER_SRC : 0x2222 */
+#define OUT_MIXERR_SRC_MIC1	14
+#define OUT_MIXERR_SRC_MIC2	13
+#define OUT_MIXERR_SRC_PHPN	12
+#define OUT_MIXERR_SRC_PHP	11
+#define OUT_MIXERR_SRC_LINER	10
+#define OUT_MIXERR_SRC_DACR	9
+#define OUT_MIXERR_SRC_DACL	8
+#define OUT_MIXERL_SRC_MIC1	6
+#define OUT_MIXERL_SRC_MIC2	5
+#define OUT_MIXERL_SRC_PHPN	4
+#define OUT_MIXERL_SRC_PHN	3
+#define OUT_MIXERL_SRC_LINEL	2
+#define OUT_MIXERL_SRC_DACL	1
+#define OUT_MIXERL_SRC_DACR	0
+
+/* AC_LINEOUT_CTL : 0x2224 */
+#define LINEOUT_EN		15
+#define LINEL_SRC_EN		14
+#define LINER_SRC_EN		13
+#define LINEL_SRC		12
+#define LINER_SRC		11
+/* ramp just skip */
+#define LINE_SLOPE_SEL		8
+#define LINE_ANTI_TIME		5
+#define LINEOUT_VOL			0
+
+/* AC_ADC_CTL : 0x2300 */
+#define ADC_EN			15
+#define ADC_ENDM		14
+#define ADC_FIR			13
+#define ADC_DELAY_TIME		2
+#define ADC_DELAY_EN		1
+
+/* AC_MICBIAS_CTL : 0x2310 */
+#define MMBIAS_EN		15
+#define MMBIAS_CHOPPER		14
+#define MMBIAS_CHOP_CLK		12
+#define MMBIAS_SEL		8
+#define ADDA_BIAS_CUR		3
+
+/* AC_ADC_MIC_CTL : 0x2320 */
+#define ADCR_EN			15
+#define ADCL_EN			14
+#define ADC_GAIN		8
+#define MIC1_GAIN_EN		7
+#define MIC1_BOOST		4
+#define MIC2_GAIN_EN		3
+#define MIC2_BOOST		0
+
+/* AC_ADC_MIXER_SRC : 0x2322 */
+#define ADC_MIXERR_MIC1		14
+#define ADC_MIXERR_MIC2		13
+#define ADC_MIXERR_PHPN		12
+#define ADC_MIXERR_PHP		11
+#define ADC_MIXERR_LINER	10
+#define ADC_MIXERR_MIXR		9
+#define ADC_MIXERR_MIXL		8
+#define ADC_MIXERL_MIC1		6
+#define ADC_MIXERL_MIC2		5
+#define ADC_MIXERL_PHPN		4
+#define ADC_MIXERL_PHN		3
+#define ADC_MIXERL_LINEL	2
+#define ADC_MIXERL_MIXL		1
+#define ADC_MIXERL_MIXR		0
+
+/* AC_BIAS_CTL : 0x232A */
+
+/* AC_ANALOG_PROF_CTL : 0x232C */
+/* used for current performance measure */
+
+/* AC_DLDO_OSC_CTL : 0x2340 */
+/* AC_ALDO_CTL : 0x2342 */
+/* used for digital & analog LDO test... etc */
+
+#endif
diff -Nuar -r --no-dereference linux-5.15.139/sound/soc/codecs/Makefile linux/sound/soc/codecs/Makefile
--- linux-5.15.139/sound/soc/codecs/Makefile	2023-11-20 18:08:30.000000000 +0800
+++ linux/sound/soc/codecs/Makefile	2024-01-03 16:06:25.935131000 +0800
@@ -87,6 +87,7 @@
 snd-soc-da732x-objs := da732x.o
 snd-soc-da9055-objs := da9055.o
 snd-soc-dmic-objs := dmic.o
+snd-soc-ec25-objs := ec25.o
 snd-soc-es7134-objs := es7134.o
 snd-soc-es7241-objs := es7241.o
 snd-soc-es8316-objs := es8316.o
@@ -317,6 +318,7 @@
 snd-soc-wm-hubs-objs := wm_hubs.o
 snd-soc-wsa881x-objs := wsa881x.o
 snd-soc-zl38060-objs := zl38060.o
+snd-soc-acx00-objs := acx00.o
 # Amp
 snd-soc-max9877-objs := max9877.o
 snd-soc-max98504-objs := max98504.o
@@ -418,6 +420,7 @@
 obj-$(CONFIG_SND_SOC_DA732X)	+= snd-soc-da732x.o
 obj-$(CONFIG_SND_SOC_DA9055)	+= snd-soc-da9055.o
 obj-$(CONFIG_SND_SOC_DMIC)	+= snd-soc-dmic.o
+obj-$(CONFIG_SND_SOC_EC25)	+= snd-soc-ec25.o
 obj-$(CONFIG_SND_SOC_ES7134)	+= snd-soc-es7134.o
 obj-$(CONFIG_SND_SOC_ES7241)	+= snd-soc-es7241.o
 obj-$(CONFIG_SND_SOC_ES8316)    += snd-soc-es8316.o
@@ -648,6 +651,7 @@
 obj-$(CONFIG_SND_SOC_WM_HUBS)	+= snd-soc-wm-hubs.o
 obj-$(CONFIG_SND_SOC_WSA881X)	+= snd-soc-wsa881x.o
 obj-$(CONFIG_SND_SOC_ZL38060)	+= snd-soc-zl38060.o
+obj-$(CONFIG_SND_SOC_ACX00)	+= snd-soc-acx00.o
 
 # Amp
 obj-$(CONFIG_SND_SOC_MAX9877)	+= snd-soc-max9877.o
diff -Nuar -r --no-dereference linux-5.15.139/sound/soc/codecs/bt-sco.c linux/sound/soc/codecs/bt-sco.c
--- linux-5.15.139/sound/soc/codecs/bt-sco.c	2023-11-20 18:08:30.000000000 +0800
+++ linux/sound/soc/codecs/bt-sco.c	2024-01-03 16:06:25.935131000 +0800
@@ -17,7 +17,9 @@
 
 static const struct snd_soc_dapm_route bt_sco_routes[] = {
 	{ "Capture", NULL, "RX" },
+	{ "Wideband Capture", NULL, "RX" },
 	{ "TX", NULL, "Playback" },
+	{ "TX", NULL, "Wideband Playback" },
 };
 
 static struct snd_soc_dai_driver bt_sco_dai[] = {
@@ -41,14 +43,14 @@
 	{
 		.name = "bt-sco-pcm-wb",
 		.playback = {
-			.stream_name = "Playback",
+			.stream_name = "Wideband Playback",
 			.channels_min = 1,
 			.channels_max = 1,
 			.rates = SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000,
 			.formats = SNDRV_PCM_FMTBIT_S16_LE,
 		},
 		.capture = {
-			 .stream_name = "Capture",
+			 .stream_name = "Wideband Capture",
 			.channels_min = 1,
 			.channels_max = 1,
 			.rates = SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000,
diff -Nuar -r --no-dereference linux-5.15.139/sound/soc/codecs/Kconfig linux/sound/soc/codecs/Kconfig
--- linux-5.15.139/sound/soc/codecs/Kconfig	2023-11-20 18:08:30.000000000 +0800
+++ linux/sound/soc/codecs/Kconfig	2024-01-03 16:06:25.935131000 +0800
@@ -815,6 +815,9 @@
 	select SND_PCM_IEC958
 	select HDMI
 
+config SND_SOC_EC25
+	tristate "EC25 LTE module CODEC"
+
 config SND_SOC_ES7134
 	tristate "Everest Semi ES7134 CODEC"
 
@@ -1944,4 +1947,12 @@
 	select REGMAP_MMIO
 	tristate "Qualcomm TX Macro in LPASS(Low Power Audio SubSystem)"
 
+config SND_SOC_ACX00
+	tristate "ACX00 Codec"
+	select MFD_ACX00
+	default n
+	help
+		ACX00 now used as SUN50IW6 internal Codec, Connect Through I2S0.
+		Say Y or M if you want to add support internal audio codec.
+
 endmenu
diff -Nuar -r --no-dereference linux-5.15.139/sound/soc/codecs/acx00.c linux/sound/soc/codecs/acx00.c
--- linux-5.15.139/sound/soc/codecs/acx00.c	1970-01-01 08:00:00.000000000 +0800
+++ linux/sound/soc/codecs/acx00.c	2024-01-03 16:06:25.935131000 +0800
@@ -0,0 +1,1371 @@
+/*
+ * acx00.c  --  ACX00 ALSA Soc Audio Codec driver
+ *
+ * (C) Copyright 2010-2016 Allwinnertech Technology., Ltd.
+ *
+ * Author: Wolfgang Huang <huangjinhui@allwinner.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/firmware.h>
+#include <linux/delay.h>
+#include <linux/pm.h>
+#include <linux/i2c.h>
+#include <linux/clk.h>
+#include <linux/of_gpio.h>
+#include <linux/of_device.h>
+#include <linux/of_platform.h>
+#include <linux/debugfs.h>
+#include <linux/slab.h>
+#include <linux/mfd/ac200.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/initval.h>
+#include <sound/tlv.h>
+#include <linux/workqueue.h>
+
+#include "acx00.h"
+
+
+#define ACX00_DEF_VOL		0x9F9F
+#undef ACX00_DAPM_LINEOUT
+
+struct acx00_priv {
+	struct ac200_dev *acx00;	/* parent mfd device struct */
+	struct snd_soc_component *component;
+	struct clk *clk;
+	unsigned int sample_rate;
+	unsigned int fmt;
+	unsigned int enable;
+	unsigned int spk_gpio;
+	unsigned int switch_gpio;
+	bool spk_gpio_used;
+	struct mutex mutex;
+	struct delayed_work spk_work;
+	struct delayed_work resume_work;
+};
+
+struct sample_rate {
+	unsigned int samplerate;
+	unsigned int rate_bit;
+};
+
+static const struct sample_rate sample_rate_conv[] = {
+	{44100, 7},
+	{48000, 8},
+	{8000, 0},
+	{32000, 6},
+	{22050, 4},
+	{24000, 5},
+	{16000, 3},
+	{11025, 1},
+	{12000, 2},
+	{192000, 10},
+	{96000, 9},
+};
+
+void __iomem *io_stat_addr;
+
+static const DECLARE_TLV_DB_SCALE(i2s_mixer_adc_tlv, -600, 600, 1);
+static const DECLARE_TLV_DB_SCALE(i2s_mixer_dac_tlv, -600, 600, 1);
+static const DECLARE_TLV_DB_SCALE(dac_mixer_adc_tlv, -600, 600, 1);
+static const DECLARE_TLV_DB_SCALE(dac_mixer_dac_tlv, -600, 600, 1);
+static const DECLARE_TLV_DB_SCALE(line_out_tlv, -450, 150, 0);
+static const DECLARE_TLV_DB_SCALE(mic_out_tlv, -450, 150, 0);
+static const DECLARE_TLV_DB_SCALE(phoneout_tlv, -450, 150, 0);
+static const DECLARE_TLV_DB_SCALE(adc_input_tlv, -450, 150, 0);
+static const DECLARE_TLV_DB_SCALE(lineout_tlv, -4800, 150, 1);
+static const unsigned int mic_boost_tlv[] = {
+	TLV_DB_RANGE_HEAD(2),
+	0, 0, TLV_DB_SCALE_ITEM(0, 0, 0),
+	1, 7, TLV_DB_SCALE_ITEM(2400, 300, 0),
+};
+
+static const struct snd_kcontrol_new acx00_codec_controls[] = {
+	SOC_DOUBLE_TLV("I2S Mixer ADC Volume", AC_I2S_MIXER_GAIN,
+			I2S_MIXERL_GAIN_ADC, I2S_MIXERR_GAIN_ADC,
+			0x1, 0, i2s_mixer_adc_tlv),
+	SOC_DOUBLE_TLV("I2S Mixer DAC Volume", AC_I2S_MIXER_GAIN,
+			I2S_MIXERL_GAIN_DAC, I2S_MIXERR_GAIN_DAC,
+			0x1, 0, i2s_mixer_dac_tlv),
+	SOC_DOUBLE_TLV("DAC Mixer ADC Volume", AC_DAC_MIXER_GAIN,
+			DAC_MIXERL_GAIN_ADC, DAC_MIXERR_GAIN_ADC,
+			0x1, 0, dac_mixer_adc_tlv),
+	SOC_DOUBLE_TLV("DAC Mxier DAC Volume", AC_DAC_MIXER_GAIN,
+			DAC_MIXERL_GAIN_DAC, DAC_MIXERR_GAIN_DAC,
+			0x1, 0, dac_mixer_dac_tlv),
+	SOC_SINGLE_TLV("Line Out Mixer Volume", AC_OUT_MIXER_CTL,
+			OUT_MIXER_LINE_VOL, 0x7, 0, line_out_tlv),
+	SOC_DOUBLE_TLV("MIC Out Mixer Volume", AC_OUT_MIXER_CTL,
+			OUT_MIXER_MIC1_VOL, OUT_MIXER_MIC2_VOL,
+			0x7, 0, mic_out_tlv),
+	SOC_SINGLE_TLV("ADC Input Volume", AC_ADC_MIC_CTL,
+			ADC_GAIN, 0x07, 0, adc_input_tlv),
+	SOC_SINGLE_TLV("Master Volume", AC_LINEOUT_CTL,
+			LINEOUT_VOL, 0x1f, 0, lineout_tlv),
+	SOC_SINGLE_TLV("MIC1 Boost Volume", AC_ADC_MIC_CTL,
+			MIC1_BOOST, 0x07, 0, mic_boost_tlv),
+	SOC_SINGLE_TLV("MIC2 Boost Volume", AC_ADC_MIC_CTL,
+			MIC2_BOOST, 0x07, 0, mic_boost_tlv),
+};
+
+/* Enable I2S & DAC clk, then enable the DAC digital part */
+static int acx00_playback_event(struct snd_soc_dapm_widget *w,
+				struct snd_kcontrol *k, int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+
+	switch (event) {
+	case	SND_SOC_DAPM_POST_PMU:
+		snd_soc_component_update_bits(component, AC_SYS_CLK_CTL,
+				(0x1<<SYS_CLK_DAC), (0x1<<SYS_CLK_DAC));
+		snd_soc_component_update_bits(component, AC_SYS_MOD_RST,
+				(0x1<<MOD_RST_DAC), (0x1<<MOD_RST_DAC));
+		snd_soc_component_update_bits(component, AC_DAC_CTL,
+				(0x1<<DAC_CTL_DAC_EN), (0x1<<DAC_CTL_DAC_EN));
+		break;
+	case	SND_SOC_DAPM_POST_PMD:
+		snd_soc_component_update_bits(component, AC_SYS_CLK_CTL,
+				(0x1<<SYS_CLK_DAC), (0x0<<SYS_CLK_DAC));
+		snd_soc_component_update_bits(component, AC_SYS_MOD_RST,
+				(0x1<<MOD_RST_DAC), (0x0<<MOD_RST_DAC));
+		snd_soc_component_update_bits(component, AC_DAC_CTL,
+				(0x1<<DAC_CTL_DAC_EN), (0x0<<DAC_CTL_DAC_EN));
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+/* Enable I2S & ADC clk, then enable the ADC digital part */
+static int acx00_capture_event(struct snd_soc_dapm_widget *w,
+				struct snd_kcontrol *k, int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+
+	switch (event) {
+	case	SND_SOC_DAPM_POST_PMU:
+		snd_soc_component_update_bits(component, AC_SYS_CLK_CTL,
+				(0x1<<SYS_CLK_ADC), (0x1<<SYS_CLK_ADC));
+		snd_soc_component_update_bits(component, AC_SYS_MOD_RST,
+				(0x1<<MOD_RST_ADC), (0x1<<MOD_RST_ADC));
+		snd_soc_component_update_bits(component, AC_ADC_CTL,
+				(0x1<<ADC_EN), (0x1<<ADC_EN));
+		break;
+	case	SND_SOC_DAPM_POST_PMD:
+		snd_soc_component_update_bits(component, AC_SYS_CLK_CTL,
+				(0x1<<SYS_CLK_ADC), (0x0<<SYS_CLK_ADC));
+		snd_soc_component_update_bits(component, AC_SYS_MOD_RST,
+				(0x1<<MOD_RST_ADC), (0x0<<MOD_RST_ADC));
+		snd_soc_component_update_bits(component, AC_ADC_CTL,
+				(0x1<<ADC_EN), (0x0<<ADC_EN));
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+/*
+ * we used for three scene:
+ * 1. No external Spker & DAPM LINEOUT used, we just enable the LINEOUT in the
+ * ALSA codec probe(acx00_codec_probe) and resume, and we shutdown the LINEOUT
+ * in device shutdown or suspend.
+ * 2. No external Spker, but DAPM LINEOUT used, we just using the LINEOUT
+ * enable or disable throught the DAPM control.
+ * 3. External Spker & DAPM LINEOUT used, we just using the LINEOUT and
+ * External Spker control GPIO enable or disable through DAPM control.
+ */
+static unsigned int spk_delay = 100;
+module_param(spk_delay, int, 0644);
+MODULE_PARM_DESC(spk_delay, "ACX00-Codec spk mute delay time");
+
+static void acx00_spk_enable(struct work_struct *work)
+{
+	struct acx00_priv *priv = container_of(work,
+			struct acx00_priv, spk_work.work);
+	gpio_set_value(priv->spk_gpio, 1);
+}
+
+static int acx00_lineout_event(struct snd_soc_dapm_widget *w,
+				struct snd_kcontrol *k, int event)
+{
+	struct snd_soc_component *component = snd_soc_dapm_to_component(w->dapm);
+	struct acx00_priv *priv = snd_soc_component_get_drvdata(component);
+
+	switch (event) {
+	case	SND_SOC_DAPM_POST_PMU:
+		if (!priv->enable) {
+			snd_soc_component_update_bits(priv->component, AC_LINEOUT_CTL,
+					(1<<LINEL_SRC_EN), (1<<LINEL_SRC_EN));
+			snd_soc_component_update_bits(priv->component, AC_LINEOUT_CTL,
+					(1<<LINER_SRC_EN), (1<<LINER_SRC_EN));
+			msleep(100);
+			priv->enable = 1;
+		}
+#ifdef ACX00_DAPM_LINEOUT
+		snd_soc_component_update_bits(component, AC_LINEOUT_CTL,
+				(1<<LINEOUT_EN), (1<<LINEOUT_EN));
+		mdelay(50);
+#endif
+		if (priv->spk_gpio_used) {
+			if (spk_delay == 0) {
+				gpio_set_value(priv->spk_gpio, 1);
+				/*
+				* time delay to wait spk pa work fine,
+				* general setting 50ms
+				*/
+				mdelay(50);
+			} else
+				schedule_delayed_work(&priv->spk_work,
+					msecs_to_jiffies(spk_delay));
+		}
+		break;
+	case	SND_SOC_DAPM_PRE_PMD:
+		mdelay(50);
+		if (priv->spk_gpio_used) {
+			gpio_set_value(priv->spk_gpio, 0);
+			msleep(50);
+		}
+#ifdef ACX00_DAPM_LINEOUT
+		snd_soc_component_update_bits(component, AC_LINEOUT_CTL,
+				(1<<LINEOUT_EN), (0<<LINEOUT_EN));
+#endif
+		break;
+	default:
+		break;
+	}
+	return 0;
+}
+
+/* AC_I2S_MIXER_SRC : 0x2114 */
+static const struct snd_kcontrol_new i2sl_mixer_src[] = {
+	SOC_DAPM_SINGLE("I2SDACL Switch", AC_I2S_MIXER_SRC,
+			I2S_MIXERL_SRC_DAC, 1, 0),
+	SOC_DAPM_SINGLE("ADCL Switch", AC_I2S_MIXER_SRC,
+			I2S_MIXERL_SRC_ADC, 1, 0),
+};
+
+static const struct snd_kcontrol_new i2sr_mixer_src[] = {
+	SOC_DAPM_SINGLE("I2SDACR Switch", AC_I2S_MIXER_SRC,
+			I2S_MIXERR_SRC_DAC, 1, 0),
+	SOC_DAPM_SINGLE("ADCR Switch", AC_I2S_MIXER_SRC,
+			I2S_MIXERR_SRC_ADC, 1, 0),
+};
+
+/* AC_DAC_MIXER_SRC : 0x2202 */
+static const struct snd_kcontrol_new dacl_mixer_src[] = {
+	SOC_DAPM_SINGLE("I2SDACL Switch", AC_DAC_MIXER_SRC,
+			DAC_MIXERL_SRC_DAC, 1, 0),
+	SOC_DAPM_SINGLE("ADCL Switch", AC_DAC_MIXER_SRC,
+			DAC_MIXERL_SRC_ADC, 1, 0),
+};
+
+static const struct snd_kcontrol_new dacr_mixer_src[] = {
+	SOC_DAPM_SINGLE("I2SDACR Switch", AC_DAC_MIXER_SRC,
+			DAC_MIXERR_SRC_DAC, 1, 0),
+	SOC_DAPM_SINGLE("ADCR Switch", AC_DAC_MIXER_SRC,
+			DAC_MIXERR_SRC_ADC, 1, 0),
+};
+
+/* AC_OUT_MIXER_SRC : 0x2222 */
+static const struct snd_kcontrol_new left_output_mixer[] = {
+	SOC_DAPM_SINGLE("MIC1 Switch", AC_OUT_MIXER_SRC,
+			OUT_MIXERL_SRC_MIC1, 1, 0),
+	SOC_DAPM_SINGLE("MIC2 Switch", AC_OUT_MIXER_SRC,
+			OUT_MIXERL_SRC_MIC2, 1, 0),
+	SOC_DAPM_SINGLE("PhonePN Switch", AC_OUT_MIXER_SRC,
+			OUT_MIXERL_SRC_PHPN, 1, 0),
+	SOC_DAPM_SINGLE("PhoneN Switch", AC_OUT_MIXER_SRC,
+			OUT_MIXERL_SRC_PHN, 1, 0),
+	SOC_DAPM_SINGLE("LINEINL Switch", AC_OUT_MIXER_SRC,
+			OUT_MIXERL_SRC_LINEL, 1, 0),
+	SOC_DAPM_SINGLE("DACL Switch", AC_OUT_MIXER_SRC,
+			OUT_MIXERL_SRC_DACL, 1, 0),
+	SOC_DAPM_SINGLE("DACR Switch", AC_OUT_MIXER_SRC,
+			OUT_MIXERL_SRC_DACR, 1, 0),
+};
+
+static const struct snd_kcontrol_new right_output_mixer[] = {
+	SOC_DAPM_SINGLE("MIC1 Switch", AC_OUT_MIXER_SRC,
+			OUT_MIXERR_SRC_MIC1, 1, 0),
+	SOC_DAPM_SINGLE("MIC2 Switch", AC_OUT_MIXER_SRC,
+			OUT_MIXERR_SRC_MIC2, 1, 0),
+	SOC_DAPM_SINGLE("PhonePN Switch", AC_OUT_MIXER_SRC,
+			OUT_MIXERR_SRC_PHPN, 1, 0),
+	SOC_DAPM_SINGLE("PhoneP Switch", AC_OUT_MIXER_SRC,
+			OUT_MIXERR_SRC_PHP, 1, 0),
+	SOC_DAPM_SINGLE("LINEINR Switch", AC_OUT_MIXER_SRC,
+			OUT_MIXERR_SRC_LINER, 1, 0),
+	SOC_DAPM_SINGLE("DACR Switch", AC_OUT_MIXER_SRC,
+			OUT_MIXERR_SRC_DACR, 1, 0),
+	SOC_DAPM_SINGLE("DACL Switch", AC_OUT_MIXER_SRC,
+			OUT_MIXERR_SRC_DACL, 1, 0),
+};
+
+/* AC_LINEOUT_CTL : 0x2224 */
+const char * const left_lineout_text[] = {
+	"Left OMixer", "LR OMixer",
+};
+
+static const struct soc_enum left_lineout_enum =
+	SOC_ENUM_SINGLE(AC_LINEOUT_CTL, LINEL_SRC,
+		ARRAY_SIZE(left_lineout_text), left_lineout_text);
+
+static const struct snd_kcontrol_new left_lineout_mux =
+	SOC_DAPM_ENUM("Left LINEOUT Mux", left_lineout_enum);
+
+const char * const right_lineout_text[] = {
+	"Right OMixer", "LR OMixer",
+};
+
+static const struct soc_enum right_lineout_enum =
+	SOC_ENUM_SINGLE(AC_LINEOUT_CTL, LINER_SRC,
+		ARRAY_SIZE(right_lineout_text), right_lineout_text);
+
+static const struct snd_kcontrol_new right_lineout_mux =
+	SOC_DAPM_ENUM("Right LINEOUT Mux", right_lineout_enum);
+
+/* AC_ADC_MIXER_SRC : 0x2322 */
+static const struct snd_kcontrol_new left_input_mixer[] = {
+	SOC_DAPM_SINGLE("MIC1 Switch", AC_ADC_MIXER_SRC,
+			ADC_MIXERL_MIC1, 1, 0),
+	SOC_DAPM_SINGLE("MIC2 Switch", AC_ADC_MIXER_SRC,
+			ADC_MIXERL_MIC2, 1, 0),
+	SOC_DAPM_SINGLE("PhonePN Switch", AC_ADC_MIXER_SRC,
+			ADC_MIXERL_PHPN, 1, 0),
+	SOC_DAPM_SINGLE("PhoneN Switch", AC_ADC_MIXER_SRC,
+			ADC_MIXERL_PHN, 1, 0),
+	SOC_DAPM_SINGLE("LINEINL Switch", AC_ADC_MIXER_SRC,
+			ADC_MIXERL_LINEL, 1, 0),
+	SOC_DAPM_SINGLE("OMixerL Switch", AC_ADC_MIXER_SRC,
+			ADC_MIXERL_MIXL, 1, 0),
+	SOC_DAPM_SINGLE("OMixerR Switch", AC_ADC_MIXER_SRC,
+			ADC_MIXERL_MIXR, 1, 0),
+};
+
+static const struct snd_kcontrol_new right_input_mixer[] = {
+	SOC_DAPM_SINGLE("MIC1 Switch", AC_ADC_MIXER_SRC,
+			ADC_MIXERR_MIC1, 1, 0),
+	SOC_DAPM_SINGLE("MIC2 Switch", AC_ADC_MIXER_SRC,
+			ADC_MIXERR_MIC2, 1, 0),
+	SOC_DAPM_SINGLE("PhonePN Switch", AC_ADC_MIXER_SRC,
+			ADC_MIXERR_PHPN, 1, 0),
+	SOC_DAPM_SINGLE("PhoneP Switch", AC_ADC_MIXER_SRC,
+			ADC_MIXERR_PHP, 1, 0),
+	SOC_DAPM_SINGLE("LINEINR Switch", AC_ADC_MIXER_SRC,
+			ADC_MIXERR_LINER, 1, 0),
+	SOC_DAPM_SINGLE("OMixerR Switch", AC_ADC_MIXER_SRC,
+			ADC_MIXERR_MIXR, 1, 0),
+	SOC_DAPM_SINGLE("OMixerL Switch", AC_ADC_MIXER_SRC,
+			ADC_MIXERR_MIXL, 1, 0),
+};
+
+static const struct snd_soc_dapm_widget acx00_codec_dapm_widgets[] = {
+	SND_SOC_DAPM_AIF_IN_E("DACL", "Playback", 0, AC_DAC_CTL,
+			OUT_MIXER_DACL_EN, 0,
+			acx00_playback_event,
+			SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_AIF_IN_E("DACR", "Playback", 0,
+			AC_DAC_CTL, OUT_MIXER_DACR_EN, 0,
+			acx00_playback_event,
+			SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
+
+	SND_SOC_DAPM_AIF_OUT_E("ADCL", "Capture", 0,
+			AC_ADC_MIC_CTL, ADCL_EN, 0,
+			acx00_capture_event,
+			SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
+	SND_SOC_DAPM_AIF_OUT_E("ADCR", "Capture", 0,
+			AC_ADC_MIC_CTL, ADCR_EN, 0,
+			acx00_capture_event,
+			SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
+
+	SND_SOC_DAPM_MIXER("Left Output Mixer", AC_OUT_MIXER_CTL,
+			OUT_MIXER_LMIX_EN, 0,
+			left_output_mixer, ARRAY_SIZE(left_output_mixer)),
+
+	SND_SOC_DAPM_MIXER("Right Output Mixer", AC_OUT_MIXER_CTL,
+			OUT_MIXER_RMIX_EN, 0, right_output_mixer,
+			ARRAY_SIZE(right_output_mixer)),
+
+	SND_SOC_DAPM_MIXER("Left Input Mixer", SND_SOC_NOPM, 0, 0,
+			left_input_mixer, ARRAY_SIZE(left_input_mixer)),
+	SND_SOC_DAPM_MIXER("Right Input Mixer", SND_SOC_NOPM, 0, 0,
+			right_input_mixer, ARRAY_SIZE(right_input_mixer)),
+
+	SND_SOC_DAPM_MIXER("Left DAC Mixer", AC_OUT_MIXER_CTL,
+			OUT_MIXER_DACL_EN, 0, dacl_mixer_src,
+			ARRAY_SIZE(dacl_mixer_src)),
+	SND_SOC_DAPM_MIXER("Right DAC Mixer", AC_OUT_MIXER_CTL,
+			OUT_MIXER_DACR_EN, 0, dacr_mixer_src,
+			ARRAY_SIZE(dacr_mixer_src)),
+
+	SND_SOC_DAPM_MIXER("Left I2S Mixer", SND_SOC_NOPM,
+			0, 0, i2sl_mixer_src, ARRAY_SIZE(i2sl_mixer_src)),
+	SND_SOC_DAPM_MIXER("Right I2S Mixer", SND_SOC_NOPM,
+			0, 0, i2sr_mixer_src, ARRAY_SIZE(i2sr_mixer_src)),
+
+	SND_SOC_DAPM_MUX("Left LINEOUT Mux", SND_SOC_NOPM,
+			0, 0, &left_lineout_mux),
+	SND_SOC_DAPM_MUX("Right LINEOUT Mux", SND_SOC_NOPM,
+			0, 0, &right_lineout_mux),
+
+	SND_SOC_DAPM_PGA("MIC1 PGA", AC_ADC_MIC_CTL,
+			MIC1_GAIN_EN, 0, NULL, 0),
+	SND_SOC_DAPM_PGA("MIC2 PGA", AC_ADC_MIC_CTL,
+			MIC2_GAIN_EN, 0, NULL, 0),
+
+	SND_SOC_DAPM_MICBIAS("MIC Bias", AC_MICBIAS_CTL,
+			MMBIAS_EN, 0),
+
+	/* PHONEIN & PHONEOUT not enable in pin assign */
+	SND_SOC_DAPM_INPUT("PHONEINP"),
+	SND_SOC_DAPM_INPUT("PHONEINN"),
+	SND_SOC_DAPM_INPUT("PHONEINPN"),
+
+	/* endpoint define */
+	SND_SOC_DAPM_LINE("LINEIN", NULL),
+	SND_SOC_DAPM_LINE("LINEOUT", acx00_lineout_event),
+	SND_SOC_DAPM_MIC("MIC1", NULL),
+	SND_SOC_DAPM_MIC("MIC2", NULL),
+};
+
+static const struct snd_soc_dapm_route acx00_codec_dapm_routes[] = {
+	{"Left Output Mixer", "MIC1 Switch", "MIC1 PGA"},
+	{"Left Output Mixer", "MIC2 Switch", "MIC2 PGA"},
+	{"Left Output Mixer", "PhonePN Switch", "PHONEINPN"},
+	{"Left Output Mixer", "PhoneN Switch", "PHONEINN"},
+	{"Left Output Mixer", "LINEINL Switch", "LINEIN"},
+	{"Left Output Mixer", "DACR Switch", "Right DAC Mixer"},
+	{"Left Output Mixer", "DACL Switch", "Left DAC Mixer"},
+
+	{"Right Output Mixer", "MIC1 Switch", "MIC1 PGA"},
+	{"Right Output Mixer", "MIC2 Switch", "MIC2 PGA"},
+	{"Right Output Mixer", "PhonePN Switch", "PHONEINPN"},
+	{"Right Output Mixer", "PhoneP Switch", "PHONEINP"},
+	{"Right Output Mixer", "LINEINR Switch", "LINEIN"},
+	{"Right Output Mixer", "DACR Switch", "Right DAC Mixer"},
+	{"Right Output Mixer", "DACL Switch", "Left DAC Mixer"},
+
+	{"Left LINEOUT Mux", NULL, "Left Output Mixer"},
+	{"Left LINEOUT Mux", "LR OMixer", "Right Output Mixer"},
+	{"Right LINEOUT Mux", NULL, "Right Output Mixer"},
+	{"Right LINEOUT Mux", "LR OMixer", "Left Output Mixer"},
+
+	{"Left Input Mixer", "MIC1 Switch", "MIC1 PGA"},
+	{"Left Input Mixer", "MIC2 Switch", "MIC2 PGA"},
+	{"Left Input Mixer", "PhonePN Switch", "PHONEINPN"},
+	{"Left Input Mixer", "PhoneN Switch", "PHONEINN"},
+	{"Left Input Mixer", "LINEINL Switch", "LINEIN"},
+	{"Left Input Mixer", "OMixerL Switch", "Left Output Mixer"},
+	{"Left Input Mixer", "OMixerR Switch", "Right Output Mixer"},
+
+	{"Right Input Mixer", "MIC1 Switch", "MIC1 PGA"},
+	{"Right Input Mixer", "MIC2 Switch", "MIC2 PGA"},
+	{"Right Input Mixer", "PhonePN Switch", "PHONEINPN"},
+	{"Right Input Mixer", "PhoneP Switch", "PHONEINP"},
+	{"Right Input Mixer", "LINEINR Switch", "LINEIN"},
+	{"Right Input Mixer", "OMixerR Switch", "Right Output Mixer"},
+	{"Right Input Mixer", "OMixerL Switch", "Left Output Mixer"},
+
+	{"Left I2S Mixer", "I2SDACL Switch", "DACL"},
+	{"Left I2S Mixer", "ADCL Switch", "Left Input Mixer"},
+
+	{"Right I2S Mixer", "I2SDACR Switch", "DACR"},
+	{"Right I2S Mixer", "ADCR Switch", "Right Input Mixer"},
+
+	{"Left DAC Mixer", "I2SDACL Switch", "DACL"},
+	{"Left DAC Mixer", "ADCL Switch", "Left Input Mixer"},
+
+	{"Right DAC Mixer", "I2SDACR Switch", "DACR"},
+	{"Right DAC Mixer", "ADCR Switch", "Right Input Mixer"},
+
+	{"ADCL", NULL, "Left I2S Mixer"},
+	{"ADCR", NULL, "Right I2S Mixer"},
+
+	{"LINEOUT", NULL, "Left LINEOUT Mux"},
+	{"LINEOUT", NULL, "Right LINEOUT Mux"},
+
+	{"MIC Bias", NULL, "MIC1"},
+	{"MIC Bias", NULL, "MIC2"},
+	{"MIC1 PGA", NULL, "MIC Bias"},
+	{"MIC2 PGA", NULL, "MIC Bias"},
+};
+
+static void acx00_codec_txctrl_enable(struct snd_soc_component *component,
+					int enable)
+{
+	pr_debug("Enter %s, enable %d\n", __func__, enable);
+	if (enable) {
+		snd_soc_component_update_bits(component, AC_I2S_CTL,
+					(1<<I2S_RX_EN), (1<<I2S_RX_EN));
+	} else {
+		snd_soc_component_update_bits(component, AC_I2S_CTL,
+					(1<<I2S_RX_EN), (0<<I2S_RX_EN));
+	}
+	pr_debug("End %s, enable %d\n", __func__, enable);
+}
+
+static void acx00_codec_rxctrl_enable(struct snd_soc_component *component,
+					int enable)
+{
+	pr_debug("Enter %s, enable %d\n", __func__, enable);
+	if (enable) {
+		snd_soc_component_update_bits(component, AC_I2S_CTL,
+					(1<<I2S_TX_EN), (1<<I2S_TX_EN));
+	} else {
+		snd_soc_component_update_bits(component, AC_I2S_CTL,
+					(1<<I2S_TX_EN), (0<<I2S_TX_EN));
+	}
+	pr_debug("End %s, enable %d\n", __func__, enable);
+}
+
+int acx00_reg_read(struct ac200_dev *acx00, unsigned short reg)
+{
+        unsigned int val;
+        int ret;
+
+        ret = regmap_read(acx00->regmap, reg, &val);
+
+        if (ret < 0)
+                return ret;
+        else
+                return val;
+}
+
+int acx00_reg_write(struct ac200_dev *acx00, unsigned short reg, unsigned short val)
+{
+	return regmap_write(acx00->regmap, reg, val);
+}
+
+static void acx00_codec_init(struct snd_soc_component *component)
+{
+	struct acx00_priv *priv = snd_soc_component_get_drvdata(component);
+
+	acx00_reg_write(priv->acx00, 0x50, 0x82b1);
+	acx00_reg_write(priv->acx00, 0xc, 0xce01);
+
+	/* acx00_codec sysctl init */
+	acx00_reg_write(priv->acx00, 0x0010, 0x03);
+	acx00_reg_write(priv->acx00, 0x0012, 0x01);
+
+	/* The bit3 need to setup to 1 for bias current. */
+	snd_soc_component_update_bits(component, AC_MICBIAS_CTL,
+			(0x1 << ADDA_BIAS_CUR), (0x1 << ADDA_BIAS_CUR));
+
+	/* enable the output & global enable bit */
+	snd_soc_component_update_bits(component, AC_I2S_CTL,
+			(1<<I2S_SDO0_EN), (1<<I2S_SDO0_EN));
+	snd_soc_component_update_bits(component, AC_I2S_CTL, (1<<I2S_GEN), (1<<I2S_GEN));
+
+	/* Default setting slot width as 32 bit for I2S */
+	snd_soc_component_update_bits(component, AC_I2S_FMT0,
+			(7<<I2S_FMT_SLOT_WIDTH), (7<<I2S_FMT_SLOT_WIDTH));
+
+	/* default setting 0xA0A0 for ADC & DAC Volume */
+	snd_soc_component_write(component, AC_I2S_DAC_VOL, ACX00_DEF_VOL);
+	snd_soc_component_write(component, AC_I2S_ADC_VOL, ACX00_DEF_VOL);
+
+	/* Enable HPF for high pass filter */
+	snd_soc_component_update_bits(component, AC_DAC_CTL,
+			(1<<DAC_CTL_HPF_EN), (1<<DAC_CTL_HPF_EN));
+
+	/* LINEOUT ANTI POP & Click noise */
+	snd_soc_component_update_bits(component, AC_LINEOUT_CTL,
+			(0x7<<LINE_ANTI_TIME), (0x3<<LINE_ANTI_TIME));
+	snd_soc_component_update_bits(component, AC_LINEOUT_CTL,
+			(0x3<<LINE_SLOPE_SEL), (0x3<<LINE_SLOPE_SEL));
+
+	/* enable & setting adc convert delay time */
+	snd_soc_component_update_bits(component, AC_ADC_CTL, (0x3<<ADC_DELAY_TIME),
+			(0x3<<ADC_DELAY_TIME));
+	snd_soc_component_update_bits(component, AC_ADC_CTL, (1<<ADC_DELAY_EN),
+			(1<<ADC_DELAY_EN));
+
+	if (priv->spk_gpio_used) {
+		snd_soc_component_update_bits(priv->component, AC_LINEOUT_CTL,
+					(1<<LINEL_SRC_EN), (1<<LINEL_SRC_EN));
+		snd_soc_component_update_bits(priv->component, AC_LINEOUT_CTL,
+					(1<<LINER_SRC_EN), (1<<LINER_SRC_EN));
+		priv->enable = 1;
+	}
+#ifndef ACX00_DAPM_LINEOUT
+	snd_soc_component_update_bits(component, AC_LINEOUT_CTL, (1<<LINEOUT_EN),
+			(1<<LINEOUT_EN));
+#endif
+
+	snd_soc_component_update_bits(component, AC_LINEOUT_CTL, 0x1f, 0x0f);
+	snd_soc_component_write(component, AC_DAC_MIXER_SRC, 0x2200);
+	snd_soc_component_write(component, AC_OUT_MIXER_SRC, 0x0202);
+}
+
+static int acx00_codec_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	struct snd_soc_component *component = dai->component;
+	int i;
+
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		snd_soc_component_update_bits(component, AC_I2S_FMT0,
+			(7<<I2S_FMT_SAMPLE), (3<<I2S_FMT_SAMPLE));
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		snd_soc_component_update_bits(component, AC_I2S_FMT0,
+			(7<<I2S_FMT_SAMPLE), (5<<I2S_FMT_SAMPLE));
+		break;
+	case SNDRV_PCM_FORMAT_S32_LE:
+		snd_soc_component_update_bits(component, AC_I2S_FMT0,
+			(7<<I2S_FMT_SAMPLE), (7<<I2S_FMT_SAMPLE));
+		break;
+	default:
+		dev_err(component->dev, "unrecognized format support\n");
+		break;
+	}
+	for (i = 0; i < ARRAY_SIZE(sample_rate_conv); i++) {
+		if (sample_rate_conv[i].samplerate == params_rate(params)) {
+			snd_soc_component_update_bits(component, AC_SYS_SR_CTL,
+				(SYS_SR_MASK<<SYS_SR_BIT),
+				(sample_rate_conv[i].rate_bit<<SYS_SR_BIT));
+		}
+	}
+
+	return 0;
+}
+
+static int acx00_codec_dai_set_sysclk(struct snd_soc_dai *codec_dai,
+		int clk_id, unsigned int freq, int dir)
+{
+	return 0;
+}
+
+static int acx00_codec_dai_set_fmt(struct snd_soc_dai *codec_dai,
+		unsigned int fmt)
+{
+	struct acx00_priv *priv = snd_soc_dai_get_drvdata(codec_dai);
+	struct snd_soc_component *component = priv->component;
+
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	/* codec clk & FRM master */
+	case SND_SOC_DAIFMT_CBM_CFM:
+		snd_soc_component_update_bits(component, AC_I2S_CLK,
+				(0x1<<I2S_BCLK_OUT), (0x1<<I2S_BCLK_OUT));
+		snd_soc_component_update_bits(component, AC_I2S_CLK,
+				(0x1<<I2S_LRCK_OUT), (0x1<<I2S_LRCK_OUT));
+		break;
+	/* codec clk & FRM slave */
+	case SND_SOC_DAIFMT_CBS_CFS:
+		snd_soc_component_update_bits(component, AC_I2S_CLK,
+				(0x1<<I2S_BCLK_OUT), 0x0<<I2S_BCLK_OUT);
+		snd_soc_component_update_bits(component, AC_I2S_CLK,
+				(0x1<<I2S_LRCK_OUT), 0x0<<I2S_LRCK_OUT);
+		break;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		snd_soc_component_update_bits(component, AC_I2S_CLK,
+				(0x3FF<<I2S_LRCK_PERIOD),
+				(0x1F<<I2S_LRCK_PERIOD));
+		snd_soc_component_update_bits(component, AC_I2S_FMT0,
+				(0x3<<I2S_FMT_MODE), (0x1<<I2S_FMT_MODE));
+		snd_soc_component_update_bits(component, AC_I2S_FMT0,
+				(0x1<<I2S_FMT_TX_OFFSET),
+				(0x1<<I2S_FMT_TX_OFFSET));
+		snd_soc_component_update_bits(component, AC_I2S_FMT0,
+				(0x1<<I2S_FMT_RX_OFFSET),
+				(0x1<<I2S_FMT_RX_OFFSET));
+		break;
+	case SND_SOC_DAIFMT_RIGHT_J:
+		snd_soc_component_update_bits(component, AC_I2S_CLK,
+				(0x3FF<<I2S_LRCK_PERIOD),
+				(0x1F<<I2S_LRCK_PERIOD));
+		snd_soc_component_update_bits(component, AC_I2S_FMT0,
+				(0x3<<I2S_FMT_MODE), (0x2<<I2S_FMT_MODE));
+		snd_soc_component_update_bits(component, AC_I2S_FMT0,
+				(0x1<<I2S_FMT_TX_OFFSET),
+				(0x0<<I2S_FMT_TX_OFFSET));
+		snd_soc_component_update_bits(component, AC_I2S_FMT0,
+				(0x1<<I2S_FMT_TX_OFFSET),
+				(0x0<<I2S_FMT_RX_OFFSET));
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		snd_soc_component_update_bits(component, AC_I2S_CLK,
+				(0x3FF<<I2S_LRCK_PERIOD),
+				(0x1F<<I2S_LRCK_PERIOD));
+		snd_soc_component_update_bits(component, AC_I2S_FMT0,
+				(0x3<<I2S_FMT_MODE), (0x1<<I2S_FMT_MODE));
+		snd_soc_component_update_bits(component, AC_I2S_FMT0,
+				(0x1<<I2S_FMT_TX_OFFSET),
+				(0x0<<I2S_FMT_TX_OFFSET));
+		snd_soc_component_update_bits(component, AC_I2S_FMT0,
+				(0x1<<I2S_FMT_RX_OFFSET),
+				(0x0<<I2S_FMT_RX_OFFSET));
+		break;
+	case SND_SOC_DAIFMT_DSP_A:
+		snd_soc_component_update_bits(component, AC_I2S_CLK,
+				(0x3FF<<I2S_LRCK_PERIOD),
+				(0x3F<<I2S_LRCK_PERIOD));
+		snd_soc_component_update_bits(component, AC_I2S_FMT0,
+				(0x3<<I2S_FMT_MODE), (0x0<<I2S_FMT_MODE));
+		snd_soc_component_update_bits(component, AC_I2S_FMT0,
+				(0x1<<I2S_FMT_TX_OFFSET),
+				(0x1<<I2S_FMT_TX_OFFSET));
+		snd_soc_component_update_bits(component, AC_I2S_FMT0,
+				(0x1<<I2S_FMT_RX_OFFSET),
+				(0x1<<I2S_FMT_RX_OFFSET));
+		break;
+	case SND_SOC_DAIFMT_DSP_B:
+		snd_soc_component_update_bits(component, AC_I2S_CLK,
+				(0x3FF<<I2S_LRCK_PERIOD),
+				(0x3F<<I2S_LRCK_PERIOD));
+		snd_soc_component_update_bits(component, AC_I2S_FMT0,
+				(0x3<<I2S_FMT_MODE), (0x0<<I2S_FMT_MODE));
+		snd_soc_component_update_bits(component, AC_I2S_FMT0,
+				(0x1<<I2S_FMT_TX_OFFSET),
+				(0x0<<I2S_FMT_TX_OFFSET));
+		snd_soc_component_update_bits(component, AC_I2S_FMT0,
+				(0x1<<I2S_FMT_RX_OFFSET),
+				(0x0<<I2S_FMT_RX_OFFSET));
+		break;
+	default:
+		dev_err(component->dev, "format setting failed\n");
+		break;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		snd_soc_component_update_bits(component, AC_I2S_FMT1,
+				(0x1<<I2S_FMT_BCLK_POLAR),
+				(0x0<<I2S_FMT_BCLK_POLAR));
+		snd_soc_component_update_bits(component, AC_I2S_FMT1,
+				(0x1<<I2S_FMT_LRCK_POLAR),
+				(0x0<<I2S_FMT_LRCK_POLAR));
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+		snd_soc_component_update_bits(component, AC_I2S_FMT1,
+				(0x1<<I2S_FMT_BCLK_POLAR),
+				(0x0<<I2S_FMT_BCLK_POLAR));
+		snd_soc_component_update_bits(component, AC_I2S_FMT1,
+				(0x1<<I2S_FMT_LRCK_POLAR),
+				(0x1<<I2S_FMT_LRCK_POLAR));
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		snd_soc_component_update_bits(component, AC_I2S_FMT1,
+				(0x1<<I2S_FMT_BCLK_POLAR),
+				(0x1<<I2S_FMT_BCLK_POLAR));
+		snd_soc_component_update_bits(component, AC_I2S_FMT1,
+				(0x1<<I2S_FMT_LRCK_POLAR),
+				(0x0<<I2S_FMT_LRCK_POLAR));
+		break;
+	case SND_SOC_DAIFMT_IB_IF:
+		snd_soc_component_update_bits(component, AC_I2S_FMT1,
+				(0x1<<I2S_FMT_BCLK_POLAR),
+				(0x1<<I2S_FMT_BCLK_POLAR));
+		snd_soc_component_update_bits(component, AC_I2S_FMT1,
+				(0x1<<I2S_FMT_LRCK_POLAR),
+				(0x1<<I2S_FMT_LRCK_POLAR));
+		break;
+	default:
+		dev_err(component->dev, "invert clk setting failed\n");
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static int acx00_codec_dai_set_clkdiv(struct snd_soc_dai *codec_dai,
+		int clk_id, int clk_div)
+{
+	struct acx00_priv *priv = snd_soc_dai_get_drvdata(codec_dai);
+	struct snd_soc_component *component = priv->component;
+	unsigned int bclk_div;
+	/*
+	 * when PCM mode, setting as 64fs, when I2S mode as 32fs,
+	 * then two channel, then just as 64fs
+	 */
+	unsigned int div_ratio = clk_div / 64;
+
+	switch (div_ratio) {
+	case 1:
+		bclk_div = I2S_BCLK_DIV_1;
+		break;
+	case 2:
+		bclk_div = I2S_BCLK_DIV_2;
+		break;
+	case 4:
+		bclk_div = I2S_BCLK_DIV_3;
+		break;
+	case 6:
+		bclk_div = I2S_BCLK_DIV_4;
+		break;
+	case 8:
+		bclk_div = I2S_BCLK_DIV_5;
+		break;
+	case 12:
+		bclk_div = I2S_BCLK_DIV_6;
+		break;
+	case 16:
+		bclk_div = I2S_BCLK_DIV_7;
+		break;
+	case 24:
+		bclk_div = I2S_BCLK_DIV_8;
+		break;
+	case 32:
+		bclk_div = I2S_BCLK_DIV_9;
+		break;
+	case 48:
+		bclk_div = I2S_BCLK_DIV_10;
+		break;
+	case 64:
+		bclk_div = I2S_BCLK_DIV_11;
+		break;
+	case 96:
+		bclk_div = I2S_BCLK_DIV_12;
+		break;
+	case 128:
+		bclk_div = I2S_BCLK_DIV_13;
+		break;
+	case 176:
+		bclk_div = I2S_BCLK_DIV_14;
+		break;
+	case 192:
+		bclk_div = I2S_BCLK_DIV_15;
+		break;
+	default:
+		dev_err(component->dev, "setting blck div failed\n");
+		break;
+	}
+
+	snd_soc_component_update_bits(component, AC_I2S_CLK,
+			(I2S_BCLK_DIV_MASK<<I2S_BLCK_DIV),
+			(bclk_div<<I2S_BLCK_DIV));
+	return 0;
+}
+
+static int acx00_codec_startup(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *codec_dai)
+{
+	return 0;
+}
+
+static bool acx00_loop_en;
+module_param(acx00_loop_en, bool, 0644);
+MODULE_PARM_DESC(acx00_loop_en, "ACX00-Codec audio loopback debug(Y=enable, N=disable)");
+
+static int acx00_codec_trigger(struct snd_pcm_substream *substream,
+		int cmd, struct snd_soc_dai *codec_dai)
+{
+	struct snd_soc_component *component = codec_dai->component;
+	return 0;
+}
+
+static int acx00_codec_prepare(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *codec_dai)
+{
+	struct snd_soc_component *component = codec_dai->component;
+
+	snd_soc_component_update_bits(component, AC_SYS_CLK_CTL,
+			(0x1<<SYS_CLK_I2S), (0x1<<SYS_CLK_I2S));
+	snd_soc_component_update_bits(component, AC_SYS_MOD_RST,
+			(0x1<<MOD_RST_I2S), (0x1<<MOD_RST_I2S));
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		if (acx00_loop_en)
+			snd_soc_component_update_bits(component, AC_I2S_FMT0,
+				(0x1<<I2S_FMT_LOOP),
+				(0x1<<I2S_FMT_LOOP));
+		else
+			snd_soc_component_update_bits(component, AC_I2S_FMT0,
+				(0x1<<I2S_FMT_LOOP),
+				(0x0<<I2S_FMT_LOOP));
+		acx00_codec_txctrl_enable(component, 1);
+	} else
+		acx00_codec_rxctrl_enable(component, 1);
+	return 0;
+}
+
+static int acx00_codec_digital_mute(struct snd_soc_dai *codec_dai,
+				int mute)
+{
+	struct snd_soc_component *component = codec_dai->component;
+
+	if (mute)
+		snd_soc_component_write(component, AC_I2S_DAC_VOL, 0);
+	else
+		snd_soc_component_write(component, AC_I2S_DAC_VOL, ACX00_DEF_VOL);
+	return 0;
+}
+
+static void acx00_codec_shutdown(struct snd_pcm_substream *substream,
+				struct snd_soc_dai *dai)
+{
+	struct snd_soc_component *component = dai->component;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		acx00_codec_txctrl_enable(component, 0);
+	else
+		acx00_codec_rxctrl_enable(component, 0);
+}
+
+static const struct snd_soc_dai_ops acx00_codec_dai_ops = {
+	.hw_params	= acx00_codec_hw_params,
+	.shutdown	= acx00_codec_shutdown,
+//	.digital_mute	= acx00_codec_digital_mute,
+	.set_sysclk	= acx00_codec_dai_set_sysclk,
+	.set_fmt	= acx00_codec_dai_set_fmt,
+	.set_clkdiv	= acx00_codec_dai_set_clkdiv,
+	.startup	= acx00_codec_startup,
+	.trigger	= acx00_codec_trigger,
+	.prepare	= acx00_codec_prepare,
+};
+
+static struct snd_soc_dai_driver acx00_codec_dai[] = {
+	{
+		.name = "acx00-dai",
+		.playback = {
+			.stream_name = "Playback",
+			.channels_min = 1,
+			.channels_max = 2,
+			.rates = SNDRV_PCM_RATE_8000_192000
+				| SNDRV_PCM_RATE_KNOT,
+			.formats = SNDRV_PCM_FMTBIT_S16_LE
+				| SNDRV_PCM_FMTBIT_S24_LE
+				| SNDRV_PCM_FMTBIT_S32_LE,
+		},
+
+		.capture = {
+			.stream_name = "Capture",
+			.channels_min = 1,
+			.channels_max = 2,
+			.rates = SNDRV_PCM_RATE_8000_192000
+				| SNDRV_PCM_RATE_KNOT,
+			.formats = SNDRV_PCM_FMTBIT_S16_LE
+				| SNDRV_PCM_FMTBIT_S24_LE
+				| SNDRV_PCM_FMTBIT_S32_LE,
+		},
+
+		.ops = &acx00_codec_dai_ops,
+	},
+};
+
+static void acx00_codec_resume_work(struct work_struct *work)
+{
+	struct acx00_priv *priv = container_of(work,
+			struct acx00_priv, resume_work.work);
+
+	acx00_codec_init(priv->component);
+}
+
+static int acx00_codec_probe(struct snd_soc_component *component)
+{
+	struct acx00_priv *priv = snd_soc_component_get_drvdata(component);
+	struct snd_soc_dapm_context *dapm = snd_soc_component_get_dapm(component);
+	int ret = 0;
+
+	mutex_init(&priv->mutex);
+
+	priv->component = component;
+#if 0
+	/* Add virtual switch */
+	ret = snd_soc_add_component_controls(component, acx00_codec_controls,
+					ARRAY_SIZE(acx00_codec_controls));
+	if (ret) {
+		pr_err("[audio-codec] Failed to register audio mode control, will continue without it.\n");
+	}
+	snd_soc_dapm_new_controls(dapm, acx00_codec_dapm_widgets, ARRAY_SIZE(acx00_codec_dapm_widgets));
+	snd_soc_dapm_add_routes(dapm, acx00_codec_dapm_routes, ARRAY_SIZE(acx00_codec_dapm_routes));
+#endif
+	/* using late_initcall to wait 120ms acx00-core to make chip reset */
+	acx00_codec_init(component);
+	INIT_DELAYED_WORK(&priv->spk_work, acx00_spk_enable);
+	INIT_DELAYED_WORK(&priv->resume_work, acx00_codec_resume_work);
+	return 0;
+}
+
+static void acx00_codec_remove(struct snd_soc_component *component)
+{
+	struct acx00_priv *priv = snd_soc_component_get_drvdata(component);
+
+	cancel_delayed_work_sync(&priv->spk_work);
+	cancel_delayed_work_sync(&priv->resume_work);
+}
+
+static unsigned int acx00_codec_read(struct snd_soc_component *component,
+					unsigned int reg)
+{
+	unsigned int data;
+	struct acx00_priv *priv = snd_soc_component_get_drvdata(component);
+
+	/* Device I/O API */
+	data = acx00_reg_read(priv->acx00, reg);
+	return data;
+}
+
+static int acx00_codec_write(struct snd_soc_component *component,
+			unsigned int reg, unsigned int value)
+{
+	struct acx00_priv *priv = snd_soc_component_get_drvdata(component);
+
+	return acx00_reg_write(priv->acx00, reg, value);
+}
+
+static int sunxi_gpio_iodisable(u32 gpio)
+{
+	char pin_name[8];
+	u32 config, ret;
+#if 0
+	sunxi_gpio_to_name(gpio, pin_name);
+	config = 7 << 16;
+	ret = pin_config_set(SUNXI_PINCTRL, pin_name, config);
+#endif
+	return ret;
+}
+
+static int acx00_codec_suspend(struct snd_soc_component *component)
+{
+	struct acx00_priv *priv = snd_soc_component_get_drvdata(component);
+
+	pr_debug("Enter %s\n", __func__);
+
+	clk_disable_unprepare(priv->clk);
+
+	/* PA_CTRL first setting low state, then make it iodisabled */
+	if (priv->spk_gpio_used) {
+		sunxi_gpio_iodisable(priv->spk_gpio);
+		msleep(30);
+	}
+
+	/*
+	 * when codec suspend, then the register reset, if auto reset produce
+	 * Pop & Click noise, then we should cut down the LINEOUT in this town.
+	 */
+	if (priv->enable) {
+		snd_soc_component_update_bits(component, AC_LINEOUT_CTL,
+				(1<<LINEOUT_EN), (0<<LINEOUT_EN));
+		snd_soc_component_update_bits(priv->component, AC_LINEOUT_CTL,
+				(1<<LINEL_SRC_EN), (0<<LINEL_SRC_EN));
+		snd_soc_component_update_bits(priv->component, AC_LINEOUT_CTL,
+				(1<<LINER_SRC_EN), (0<<LINER_SRC_EN));
+		priv->enable = 0;
+	}
+
+	pr_debug("Exit %s\n", __func__);
+
+	return 0;
+}
+
+static int acx00_codec_resume(struct snd_soc_component *component)
+{
+	struct acx00_priv *priv = snd_soc_component_get_drvdata(component);
+
+	pr_debug("Enter %s\n", __func__);
+
+	if (clk_prepare_enable(priv->clk)) {
+		dev_err(component->dev, "codec resume clk failed\n");
+		return -EBUSY;
+	}
+
+	schedule_delayed_work(&priv->resume_work, msecs_to_jiffies(300));
+
+	if (priv->spk_gpio_used) {
+		gpio_direction_output(priv->spk_gpio, 1);
+		gpio_set_value(priv->spk_gpio, 0);
+	}
+
+	pr_debug("Exit %s\n", __func__);
+
+	return 0;
+}
+
+
+static int acx00_codec_set_bias_level(struct snd_soc_component *component,
+		enum snd_soc_bias_level level)
+{
+	component->dapm.bias_level = level;
+	return 0;
+}
+
+struct label {
+	const char *name;
+	int value;
+};
+
+#define LABEL(constant) { #constant, constant }
+#define LABEL_END { NULL, -1 }
+
+static struct label reg_labels[] = {
+	LABEL(AC_SYS_CLK_CTL),
+	LABEL(AC_SYS_MOD_RST),
+	LABEL(AC_SYS_SR_CTL),
+	LABEL(AC_I2S_CTL),
+	LABEL(AC_I2S_CLK),
+	LABEL(AC_I2S_FMT0),
+	LABEL(AC_I2S_FMT1),
+	LABEL(AC_I2S_MIXER_SRC),
+	LABEL(AC_I2S_MIXER_GAIN),
+	LABEL(AC_I2S_DAC_VOL),
+	LABEL(AC_I2S_ADC_VOL),
+	LABEL(AC_DAC_CTL),
+	LABEL(AC_DAC_MIXER_SRC),
+	LABEL(AC_DAC_MIXER_GAIN),
+	LABEL(AC_OUT_MIXER_CTL),
+	LABEL(AC_OUT_MIXER_SRC),
+	LABEL(AC_LINEOUT_CTL),
+	LABEL(AC_ADC_CTL),
+	LABEL(AC_MICBIAS_CTL),
+	LABEL(AC_ADC_MIC_CTL),
+	LABEL(AC_ADC_MIXER_SRC),
+	LABEL(AC_BIAS_CTL),
+	LABEL(AC_ANALOG_PROF_CTL),
+	LABEL_END,
+};
+
+static ssize_t show_audio_reg(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	struct acx00_priv *priv = dev_get_drvdata(dev);
+	int count = 0, i = 0;
+	unsigned int reg_val;
+
+	count += sprintf(buf, "dump audio reg:\n");
+
+	while (reg_labels[i].name != NULL) {
+		reg_val = acx00_reg_read(priv->acx00, reg_labels[i].value);
+		count += sprintf(buf + count, "%s 0x%x: 0x%x\n",
+		reg_labels[i].name, (reg_labels[i].value), reg_val);
+		i++;
+	}
+
+	return count;
+}
+
+/*
+ * param 1: 0 read;1 write
+ * param 2: 1 digital reg; 2 analog reg
+ * param 3: reg value;
+ * param 4: write value;
+ * read:
+ * echo 0,1,0x00> audio_reg
+ * echo 0,2,0x00> audio_reg
+ * write:
+ * echo 1,1,0x00,0xa > audio_reg
+ * echo 1,2,0x00,0xff > audio_reg
+*/
+static ssize_t store_audio_reg(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	int ret;
+	int rw_flag;
+	unsigned int input_reg_val = 0;
+	int input_reg_group = 0;
+	unsigned int input_reg_offset = 0;
+	struct acx00_priv *priv = dev_get_drvdata(dev);
+
+	ret = sscanf(buf, "%d,%d,0x%x,0x%x", &rw_flag, &input_reg_group,
+			&input_reg_offset, &input_reg_val);
+	dev_info(dev, "ret:%d, reg_group:%d, reg_offset:%d, reg_val:0x%x\n",
+			ret, input_reg_group, input_reg_offset, input_reg_val);
+
+	if (input_reg_group != 1) {
+		pr_err("not exist reg group\n");
+		ret = count;
+		goto out;
+	}
+	if (!(rw_flag == 1 || rw_flag == 0)) {
+		pr_err("not rw_flag\n");
+		ret = count;
+		goto out;
+	}
+
+	if (rw_flag) {
+		acx00_reg_write(priv->acx00, input_reg_offset, input_reg_val);
+	} else {
+		input_reg_val = acx00_reg_read(priv->acx00, input_reg_offset);
+		dev_info(dev, "\n\n Reg[0x%x] : 0x%04x\n\n",
+				input_reg_offset, input_reg_val);
+	}
+	ret = count;
+
+out:
+	return ret;
+}
+
+static DEVICE_ATTR(audio_reg, 0644, show_audio_reg, store_audio_reg);
+
+static struct attribute *audio_debug_attrs[] = {
+	&dev_attr_audio_reg.attr,
+	NULL,
+};
+
+static struct attribute_group audio_debug_attr_group = {
+	.name   = "audio_reg_debug",
+	.attrs  = audio_debug_attrs,
+};
+
+static struct snd_soc_component_driver soc_codec_driver_acx00 = {
+	.probe			= acx00_codec_probe,
+	.remove			= acx00_codec_remove,
+	.suspend		= acx00_codec_suspend,
+	.resume			= acx00_codec_resume,
+	.read			= acx00_codec_read,
+	.write			= acx00_codec_write,
+//	.ignore_pmdown_time	= 1,
+	.set_bias_level		= acx00_codec_set_bias_level,
+	.controls		= acx00_codec_controls,
+	.num_controls		= ARRAY_SIZE(acx00_codec_controls),
+	.dapm_widgets		= acx00_codec_dapm_widgets,
+	.num_dapm_widgets	= ARRAY_SIZE(acx00_codec_dapm_widgets),
+	.dapm_routes		= acx00_codec_dapm_routes,
+	.num_dapm_routes	= ARRAY_SIZE(acx00_codec_dapm_routes),
+};
+
+/* through acx00 is part of mfd devices, after the mfd */
+static int acx00_codec_dev_probe(struct platform_device *pdev)
+{
+	struct acx00_priv *priv;
+	int ret;
+	struct device_node *np = of_find_compatible_node(NULL, NULL, "allwinner,ac200_codec");
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(struct acx00_priv), GFP_KERNEL);
+	if (!priv) {
+		dev_err(&pdev->dev, "acx00 codec priv mem alloc failed\n");
+		return -ENOMEM;
+	}
+
+	platform_set_drvdata(pdev, priv);
+	priv->acx00 = dev_get_drvdata(pdev->dev.parent);
+
+	if (np) {
+		ret = of_get_named_gpio(np, "gpio-spk", 0);
+		if (ret >= 0) {
+			priv->spk_gpio_used = 1;
+			priv->spk_gpio = ret;
+			if (!gpio_is_valid(priv->spk_gpio)) {
+				dev_err(&pdev->dev, "gpio-spk is valid\n");
+				ret = -EINVAL;
+				goto err_devm_kfree;
+			} else {
+				ret = devm_gpio_request(&pdev->dev,
+				priv->spk_gpio, "SPK");
+				if (ret) {
+					dev_err(&pdev->dev,
+						"failed request gpio-spk\n");
+					ret = -EBUSY;
+					goto err_devm_kfree;
+				} else {
+					gpio_direction_output(priv->spk_gpio,
+								1);
+					gpio_set_value(priv->spk_gpio, 0);
+				}
+			}
+		} else {
+			priv->spk_gpio_used = 0;
+		}
+
+		ret = of_get_named_gpio(np, "gpio-switch", 0);
+		if (ret >= 0) {
+			priv->switch_gpio = ret;
+			if (!gpio_is_valid(priv->switch_gpio)) {
+				dev_err(&pdev->dev, "gpio-switch is valid\n");
+				ret = -EINVAL;
+				goto err_devm_kfree;
+			} else {
+				ret = devm_gpio_request(&pdev->dev, priv->switch_gpio, "SWITCH");
+				if (ret) {
+					dev_err(&pdev->dev,
+						"failed request gpio-switch\n");
+					ret = -EBUSY;
+					goto err_devm_kfree;
+				} else {
+					gpio_direction_output(priv->switch_gpio, 1);
+					gpio_set_value(priv->switch_gpio, 1);
+				}
+			}
+		} 
+	}
+
+	ret = snd_soc_register_component(&pdev->dev, &soc_codec_driver_acx00,
+			acx00_codec_dai, ARRAY_SIZE(acx00_codec_dai));
+
+	if (ret < 0)
+		dev_err(&pdev->dev, "Failed register acx00: %d\n", ret);
+
+	ret  = sysfs_create_group(&pdev->dev.kobj, &audio_debug_attr_group);
+	if (ret)
+		dev_warn(&pdev->dev, "failed to create attr group\n");
+
+	return 0;
+
+err_devm_kfree:
+	devm_kfree(&pdev->dev, priv);
+	return ret;
+}
+
+/* Mark this space to clear the LINEOUT & gpio */
+static void acx00_codec_dev_shutdown(struct platform_device *pdev)
+{
+	struct acx00_priv *priv = platform_get_drvdata(pdev);
+
+	if (priv->spk_gpio_used)
+		gpio_set_value(priv->spk_gpio, 0);
+}
+
+static int acx00_codec_dev_remove(struct platform_device *pdev)
+{
+	struct acx00_priv *priv = platform_get_drvdata(pdev);
+
+#ifndef ACX00_DAPM_LINEOUT
+	/*
+	snd_soc_component_update_bits(priv->component, AC_LINEOUT_CTL,
+			(1<<LINEOUT_EN), (0<<LINEOUT_EN));
+	*/
+#endif
+	snd_soc_unregister_component(&pdev->dev);
+	clk_disable_unprepare(priv->clk);
+	devm_kfree(&pdev->dev, priv);
+	return 0;
+}
+
+static const struct of_device_id acx00_codec_match[] = {
+	{ .compatible = "x-powers,ac200-codec" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, acx00_codec_match);
+
+static struct platform_driver acx00_codec_driver = {
+	.driver = {
+		.name = "acx00-codec",
+		.of_match_table = acx00_codec_match,
+	},
+	.probe = acx00_codec_dev_probe,
+	.remove = acx00_codec_dev_remove,
+	.shutdown = acx00_codec_dev_shutdown,
+};
+
+static int __init acx00_codec_driver_init(void)
+{
+	return platform_driver_register(&acx00_codec_driver);
+}
+
+static void __exit acx00_codec_driver_exit(void)
+{
+	platform_driver_unregister(&acx00_codec_driver);
+}
+late_initcall(acx00_codec_driver_init);
+module_exit(acx00_codec_driver_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("SUNXI ASoC ACX00 Codec Driver");
+MODULE_AUTHOR("wolfgang huang");
+MODULE_ALIAS("platform:acx00-codec");
diff -Nuar -r --no-dereference linux-5.15.139/arch/arm64/boot/dts/allwinner/sun50i-h616-cpu-opp.dtsi linux/arch/arm64/boot/dts/allwinner/sun50i-h616-cpu-opp.dtsi
--- linux-5.15.139/arch/arm64/boot/dts/allwinner/sun50i-h616-cpu-opp.dtsi	1970-01-01 08:00:00.000000000 +0800
+++ linux/arch/arm64/boot/dts/allwinner/sun50i-h616-cpu-opp.dtsi	2024-01-03 18:52:54.290483190 +0800
@@ -0,0 +1,60 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+
+/ {
+	cpu_opp_table: opp-table-cpu {
+		compatible = "operating-points-v2";
+		opp-shared;
+
+		opp-480000000 {
+			opp-hz = /bits/ 64 <480000000>;
+			opp-microvolt = <820000>;
+			clock-latency-ns = <244144>; /* 8 32k periods */
+		};
+
+		opp-600000000 {
+			opp-hz = /bits/ 64 <600000000>;
+			opp-microvolt = <820000>;
+			clock-latency-ns = <244144>; /* 8 32k periods */
+		};
+
+		opp-792000000 {
+			opp-hz = /bits/ 64 <792000000>;
+			opp-microvolt = <860000>;
+			clock-latency-ns = <244144>; /* 8 32k periods */
+		};
+
+		opp-1008000000 {
+			opp-hz = /bits/ 64 <1008000000>;
+			opp-microvolt = <900000>;
+			clock-latency-ns = <244144>; /* 8 32k periods */
+		};
+
+		opp-1200000000 {
+			opp-hz = /bits/ 64 <1200000000>;
+			opp-microvolt = <960000>;
+			clock-latency-ns = <244144>; /* 8 32k periods */
+		};
+
+		opp-1512000000 {
+			opp-hz = /bits/ 64 <1512000000>;
+			opp-microvolt = <1100000>;
+			clock-latency-ns = <244144>; /* 8 32k periods */
+		};
+	};
+};
+
+&cpu0 {
+	operating-points-v2 = <&cpu_opp_table>;
+};
+
+&cpu1 {
+	operating-points-v2 = <&cpu_opp_table>;
+};
+
+&cpu2 {
+	operating-points-v2 = <&cpu_opp_table>;
+};
+
+&cpu3 {
+	operating-points-v2 = <&cpu_opp_table>;
+};
diff -Nuar -r --no-dereference linux-5.15.139/arch/arm64/boot/dts/allwinner/Makefile linux/arch/arm64/boot/dts/allwinner/Makefile
--- linux-5.15.139/arch/arm64/boot/dts/allwinner/Makefile	2023-11-20 18:08:30.000000000 +0800
+++ linux/arch/arm64/boot/dts/allwinner/Makefile	2024-01-03 18:53:10.558660211 +0800

@@ -37,3 +37,6 @@
 dtb-$(CONFIG_ARCH_SUNXI) += sun50i-h6-pine-h64.dtb
 dtb-$(CONFIG_ARCH_SUNXI) += sun50i-h6-pine-h64-model-b.dtb
 dtb-$(CONFIG_ARCH_SUNXI) += sun50i-h6-tanix-tx6.dtb
+dtb-$(CONFIG_ARCH_SUNXI) += sun50i-h616-orangepi-zero2.dtb
+dtb-$(CONFIG_ARCH_SUNXI) += sun50i-h616-x96-mate.dtb
+dtb-$(CONFIG_ARCH_SUNXI) += sun50i-h616-yuzukichameleon.dtb
diff -Nuar -r --no-dereference linux-5.15.139/arch/arm64/boot/dts/allwinner/sun50i-h616-x96-mate.dts linux/arch/arm64/boot/dts/allwinner/sun50i-h616-x96-mate.dts
--- linux-5.15.139/arch/arm64/boot/dts/allwinner/sun50i-h616-x96-mate.dts	1970-01-01 08:00:00.000000000 +0800
+++ linux/arch/arm64/boot/dts/allwinner/sun50i-h616-x96-mate.dts	2024-01-03 16:06:25.935131000 +0800
@@ -0,0 +1,220 @@
+// SPDX-License-Identifier: (GPL-2.0+ or MIT)
+/*
+ * Copyright (C) 2021 Arm Ltd.
+ */
+
+/dts-v1/;
+
+#include "sun50i-h616.dtsi"
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+
+/ {
+	model = "X96 Mate";
+	compatible = "hechuang,x96-mate", "allwinner,sun50i-h616";
+
+	aliases {
+		ethernet0 = &emac1;
+		serial0 = &uart0;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	reg_vcc5v: vcc5v {
+		/* board wide 5V supply directly from the DC input */
+		compatible = "regulator-fixed";
+		regulator-name = "vcc-5v";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		regulator-always-on;
+	};
+};
+
+&ehci0 {
+	status = "okay";
+};
+
+&ehci2 {
+	status = "okay";
+};
+
+&emac1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&rmii_pins>;
+	phy-mode = "rmii";
+	phy-handle = <&rmii_phy>;
+	phy-supply = <&reg_aldo1>;
+	allwinner,rx-delay-ps = <3100>;
+	allwinner,tx-delay-ps = <700>;
+	status = "okay";
+};
+
+&ir {
+	status = "okay";
+};
+
+&mdio1 {
+	rmii_phy: ethernet-phy@1 {
+		compatible = "ethernet-phy-ieee802.3-c22";
+		reg = <1>;
+	};
+};
+
+&mmc0 {
+	vmmc-supply = <&reg_dcdce>;
+	broken-cd;
+	bus-width = <4>;
+	status = "okay";
+};
+
+&mmc2 {
+	vmmc-supply = <&reg_dcdce>;
+	vqmmc-supply = <&reg_bldo1>;
+	bus-width = <8>;
+	non-removable;
+	cap-mmc-hw-reset;
+	mmc-hs200-1_8v;
+	status = "okay";
+};
+
+&ohci0 {
+	status = "okay";
+};
+
+&ohci2 {
+	status = "okay";
+};
+
+&r_rsb {
+	status = "okay";
+
+	axp305: pmic@745 {
+		compatible = "x-powers,axp305", "x-powers,axp805",
+			     "x-powers,axp806";
+		interrupt-controller;
+		#interrupt-cells = <1>;
+		reg = <0x745>;
+
+		x-powers,self-working-mode;
+		vina-supply = <&reg_vcc5v>;
+		vinb-supply = <&reg_vcc5v>;
+		vinc-supply = <&reg_vcc5v>;
+		vind-supply = <&reg_vcc5v>;
+		vine-supply = <&reg_vcc5v>;
+		aldoin-supply = <&reg_vcc5v>;
+		bldoin-supply = <&reg_vcc5v>;
+		cldoin-supply = <&reg_vcc5v>;
+
+		regulators {
+			reg_aldo1: aldo1 {
+				regulator-always-on;
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-name = "vcc-sys";
+			};
+
+			/* Enabled by the Android BSP */
+			reg_aldo2: aldo2 {
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-name = "vcc3v3-ext";
+				status = "disabled";
+			};
+
+			/* Enabled by the Android BSP */
+			reg_aldo3: aldo3 {
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-name = "vcc3v3-ext2";
+				status = "disabled";
+			};
+
+			reg_bldo1: bldo1 {
+				regulator-always-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-name = "vcc1v8";
+			};
+
+			/* Enabled by the Android BSP */
+			reg_bldo2: bldo2 {
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-name = "vcc1v8-2";
+				status = "disabled";
+			};
+
+			bldo3 {
+				/* unused */
+			};
+
+			bldo4 {
+				/* unused */
+			};
+
+			cldo1 {
+				regulator-min-microvolt = <2500000>;
+				regulator-max-microvolt = <2500000>;
+				regulator-name = "vcc2v5";
+			};
+
+			cldo2 {
+				/* unused */
+			};
+
+			cldo3 {
+				/* unused */
+			};
+
+			reg_dcdca: dcdca {
+				regulator-always-on;
+				regulator-min-microvolt = <810000>;
+				regulator-max-microvolt = <1080000>;
+				regulator-name = "vdd-cpu";
+			};
+
+			reg_dcdcc: dcdcc {
+				regulator-always-on;
+				regulator-min-microvolt = <810000>;
+				regulator-max-microvolt = <1080000>;
+				regulator-name = "vdd-gpu-sys";
+			};
+
+			reg_dcdcd: dcdcd {
+				regulator-always-on;
+				regulator-min-microvolt = <1360000>;
+				regulator-max-microvolt = <1360000>;
+				regulator-name = "vdd-dram";
+			};
+
+			reg_dcdce: dcdce {
+				regulator-boot-on;
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-name = "vcc-eth-mmc";
+			};
+
+			sw {
+				/* unused */
+			};
+		};
+	};
+};
+
+&uart0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart0_ph_pins>;
+	status = "okay";
+};
+
+&usbotg {
+	dr_mode = "host";	/* USB A type receptable */
+	status = "okay";
+};
+
+&usbphy {
+	status = "okay";
+};
diff -Nuar -r --no-dereference linux-5.15.139/arch/arm64/boot/dts/allwinner/sun50i-h616-yuzukichameleon.dts linux/arch/arm64/boot/dts/allwinner/sun50i-h616-yuzukichameleon.dts
--- linux-5.15.139/arch/arm64/boot/dts/allwinner/sun50i-h616-yuzukichameleon.dts	1970-01-01 08:00:00.000000000 +0800
+++ linux/arch/arm64/boot/dts/allwinner/sun50i-h616-yuzukichameleon.dts	2024-01-03 18:54:21.143299458 +0800
@@ -0,0 +1,480 @@
+// SPDX-License-Identifier: (GPL-2.0+ or MIT)
+/*
+ * Copyright (C) 2020 Arm Ltd.
+ */
+
+/dts-v1/;
+
+#include "sun50i-h616.dtsi"
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+#include <dt-bindings/leds/common.h>
+#include "sun50i-h616-cpu-opp.dtsi"
+
+/ {
+	model = "YuzukiChameleon";
+	compatible = "allwinner,sun50i-h616";
+
+	aliases {
+        ethernet0 = &emac1;
+		// ethernet0 = &emac0;
+		serial0 = &uart0;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	connector {
+		compatible = "hdmi-connector";
+		type = "d";
+
+		port {
+			hdmi_con_in: endpoint {
+				remote-endpoint = <&hdmi_out_con>;
+			};
+		};
+	};
+
+	leds {
+		compatible = "gpio-leds";
+        
+		led-0 {
+			function = LED_FUNCTION_POWER;
+			color = <LED_COLOR_ID_RED>;
+            gpios = <&pio 2 13 GPIO_ACTIVE_HIGH>; /* PC13 */
+            status = "disabled";
+		};
+
+		led-1 {
+			function = LED_FUNCTION_STATUS;
+			color = <LED_COLOR_ID_GREEN>;
+            gpio = <&pio 7 5 GPIO_ACTIVE_HIGH>; /* PH5 */
+			default-state = "on";
+            status = "disabled";
+		};
+
+        gpio_1 {
+			function = "wifi_power";
+            gpio = <&pio 5 6 GPIO_ACTIVE_LOW>; /* PF6 */
+            status = "okay";
+		};
+
+        gpio_2 {
+			function = "wifi_wake";
+            gpio = <&pio 6 15 GPIO_ACTIVE_LOW>; /* PG15 */
+            status = "okay";
+		};
+	};
+
+    ws2812 {
+		compatible = "rgb-ws2812";
+		pinctrl-names = "default";
+		status = "okay";
+
+		ws2812_pin@0 {
+            // gpios = <&pio 7 5 GPIO_ACTIVE_LOW>;
+            gpios = <&pio 2 14 GPIO_ACTIVE_LOW>;
+            label = "ws2812";
+            linux,default-trigger = "heartbeat";
+            linux,default-trigger-delay-ms = <0>;
+		};
+    };
+
+    mcp2515_clock: mcp2515_clock {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency  = <12000000>;          //
+	};
+
+    i2c_gpio: i2c-gpio {
+        #address-cells = <1>;
+        #size-cells = <0>;
+        compatible = "i2c-gpio";
+
+        status = "disabled";
+
+        gpios = <&pio 2 12 GPIO_ACTIVE_HIGH>, /* sda */
+                <&pio 2 10 GPIO_ACTIVE_HIGH>; /* scl */
+
+        // sda-open-draingpio.
+        // i2c-gpio,sda-open-drain;
+        // i2c-gpio,scl-open-drain;
+        
+        i2c-gpio,delay-us = <5>; /* 100 kHz */
+        
+        tft_tp: ns2009@48 {
+            compatible = "ns2009";
+            reg = <0x48>;
+            status = "disabled";
+        };
+
+        light: bh1750@5c {
+            compatible = "rohm,bh1750";
+            reg = <0x5c>;
+            status = "disabled";
+        };
+    };
+
+	reg_vcc5v: vcc5v {
+		/* board wide 5V supply directly from the USB-C socket */
+		compatible = "regulator-fixed";
+		regulator-name = "vcc-5v";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		regulator-always-on;
+	};
+
+	reg_usb1_vbus: usb1-vbus {
+		compatible = "regulator-fixed";
+		regulator-name = "usb1-vbus";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		vin-supply = <&reg_vcc5v>;
+		enable-active-high;
+		// gpio = <&pio 2 16 GPIO_ACTIVE_HIGH>;    /* PC16 */
+		status = "okay";
+	};
+
+	reg_vcc33_wifi: vcc33-wifi {
+		/* Always on 3.3V regulator for WiFi and BT */
+		compatible = "regulator-fixed";
+		regulator-name = "vcc33-wifi";
+		regulator-min-microvolt = <3300000>;
+		regulator-max-microvolt = <3300000>;
+		regulator-always-on;
+		vin-supply = <&reg_vcc5v>;
+	};
+
+	reg_vcc_wifi_io: vcc-wifi-io {
+		/* Always on 1.8V/300mA regulator for WiFi and BT IO */
+		compatible = "regulator-fixed";
+		regulator-name = "vcc-wifi-io";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		regulator-always-on;
+		vin-supply = <&reg_vcc33_wifi>;
+	};
+
+	wifi_pwrseq: wifi-pwrseq {
+		compatible = "mmc-pwrseq-simple";
+		clocks = <&rtc 1>;
+		clock-names = "osc32k-out";
+		reset-gpios = <&pio 6 18 GPIO_ACTIVE_LOW>;  /* PG18 */
+		post-power-on-delay-ms = <200>;
+	};
+	wlan:wlan {
+		compatible = "allwinner,sunxi-wlan";
+		//clocks = <&wifi_pwrseq>;
+		//wlan_power = "vcc33-wifi";
+		//wlan_io_regulator = "vcc-wifi-io";
+		wlan_busnum = <0>;
+		wlan_usbnum = <3>;
+		wlan_regon = <&pio 6 11 0>;
+		//wlan_hostwake = <&pio PH 1 6 0 0 0>;
+		//wlan_clk_gpio = <&pio 6 10>;
+		status = "okay";
+	};
+};
+
+&usbphy {
+	usb1_vbus-supply = <&reg_usb1_vbus>;
+	status = "okay";
+};
+
+&de {
+	status = "okay";
+};
+
+&hdmi {
+	hvcc-supply = <&reg_aldo1>;
+    status = "okay";
+};
+
+&hdmi_audio {
+	status = "okay";
+};
+
+&hdmi_out {
+	hdmi_out_con: endpoint {
+		remote-endpoint = <&hdmi_con_in>;
+	};
+};
+
+&gpu {
+    mali-supply = <&reg_dcdc3>;
+    status = "okay";
+};
+
+&ehci0 {
+	status = "okay";
+};
+
+&ehci1 {
+	status = "okay";
+};
+
+&ehci2 {
+	status = "okay";
+};
+
+&ehci3 {
+	status = "okay";
+};
+
+/* USB 2 & 3 are on headers only. */
+
+&emac0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&ext_rgmii_pins>;
+	phy-mode = "rgmii";
+	phy-handle = <&ext_rgmii_phy>;
+    phy-supply = <&reg_dldo1>;
+	allwinner,rx-delay-ps = <3100>;
+	allwinner,tx-delay-ps = <700>;
+	// status = "okay";
+    status = "disabled";
+};
+
+&mdio0 {
+	ext_rgmii_phy: ethernet-phy@1 {
+		compatible = "ethernet-phy-ieee802.3-c22";
+		reg = <1>;
+	};
+};
+
+&emac1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&rmii_pins>;
+	phy-mode = "rmii";
+	phy-handle = <&rmii_phy>;
+	phy-supply = <&reg_dldo1>;
+	allwinner,rx-delay-ps = <3100>;
+	allwinner,tx-delay-ps = <700>;
+	status = "okay";
+};
+
+&mdio1 {
+	rmii_phy: ethernet-phy@1 {
+		compatible = "ethernet-phy-ieee802.3-c22";
+		reg = <1>;
+	};
+};
+
+/*------------------------------------*/
+
+&mmc0 {
+    vmmc-supply = <&reg_dldo1>;
+
+	// cd-gpios = <&pio 5 6 GPIO_ACTIVE_LOW>;	/* PF6 */
+    no-1-8-v;
+	bus-width = <4>;
+	status = "okay";
+};
+
+&mmc1 {
+	vmmc-supply = <&reg_vcc33_wifi>;
+	vqmmc-supply = <&reg_vcc_wifi_io>;
+	mmc-pwrseq = <&wifi_pwrseq>;
+	bus-width = <4>;
+	//non-removable;
+	//mmc-ddr-1_8v;
+    no-1-8-v;
+	status = "okay";
+};
+
+&mmc2 {
+    vmmc-supply = <&reg_dldo1>;
+
+    no-1-8-v;
+	bus-width = <8>;
+    non-removable;
+	// status = "okay";
+    status = "disabled";
+};
+
+&ohci0 {
+	status = "okay";
+};
+
+&ohci1 {
+	status = "okay";
+};
+
+&ohci2 {
+	status = "okay";
+};
+
+&ohci3 {
+	status = "okay";
+};
+
+&r_i2c {
+	status = "okay";
+
+    axp1530: pmic@36 {
+		compatible = "x-powers,axp1530";
+        status = "okay";
+		reg = <0x36>;
+		wakeup-source;
+
+		standby_param: standby_param {
+			vcc-dram = <0x4>;
+		};
+
+		regulators{
+			reg_dcdc1: dcdc1 {
+				regulator-name = "axp1530-dcdc1";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <3400000>;
+				regulator-step-delay-us = <25>;
+				regulator-final-delay-us = <50>;
+				regulator-always-on;
+			};
+
+			reg_dcdc2: dcdc2 {
+				regulator-name = "axp1530-dcdc2";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <1540000>;
+				regulator-step-delay-us = <25>;
+				regulator-final-delay-us = <50>;
+				regulator-ramp-delay = <200>; // FIXME
+				regulator-always-on;
+			};
+
+			reg_dcdc3: dcdc3 {
+				regulator-name = "axp1530-dcdc3";
+				regulator-min-microvolt = <500000>;
+				regulator-max-microvolt = <1840000>;
+				regulator-step-delay-us = <25>;
+				regulator-final-delay-us = <50>;
+				regulator-always-on;
+			};
+
+			reg_aldo1: ldo1 {
+				regulator-name = "axp1530-aldo1";
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-step-delay-us = <25>;
+				regulator-final-delay-us = <50>;
+				regulator-always-on;
+			};
+
+			reg_dldo1: ldo2 {
+				regulator-name = "axp1530-dldo1";
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-step-delay-us = <25>;
+				regulator-final-delay-us = <50>;
+				regulator-always-on;
+			};
+		};
+	};
+};
+
+&spi1 {
+    #address-cells = <1>;
+    #size-cells = <0>;
+    pinctrl-names = "default";
+
+    pinctrl-0 = <&spi1_pins>;
+    cs-gpios = <&pio 2 11 GPIO_ACTIVE_HIGH>,    /* PC11 */ 
+                <&pio 2 7 GPIO_ACTIVE_HIGH>;    /* PC7 */
+
+    status = "disabled";
+    
+    can: mcp2515@0 {
+        compatible = "microchip,mcp2515";
+        clocks = <&mcp2515_clock>;
+        status = "disabled";
+        
+        reg = <0x0>;
+        spi-max-frequency = <1000000>;
+
+        interrupt-parent = <&pio>;
+        interrupts = <2 9 IRQ_TYPE_EDGE_FALLING>;   /* PC9 */
+        
+        vdd-supply = <&reg_vcc33_wifi>;
+        xceiver-supply = <&reg_vcc33_wifi>;
+    };
+
+    tft_35: st7796@1 {
+        compatible = "sitronix,st7796";
+        status = "disabled";
+
+        reg = <0x1>;
+        spi-max-frequency = <50000000>;
+        fps = <60>;
+        rotate = <0>;
+        buswidth = <8>;
+        width = <480>;
+        height = <320>;
+        bpp = <24>;
+        bgr;
+        regwidth = <8>;
+        debug = <0x00>;     //0x20 show fps
+    };
+};
+
+&uart0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart0_ph_pins>;
+	status = "okay";
+};
+
+&usbotg {
+	/*
+	 * PHY0 pins are connected to a USB-C socket, but a role switch
+	 * is not implemented: both CC pins are pulled to GND.
+	 * The VBUS pins power the device, so a fixed peripheral mode
+	 * is the best choice.
+	 * The board can be powered via GPIOs, in this case port0 *can*
+	 * act as a host (with a cable/adapter ignoring CC), as VBUS is
+	 * then provided by the GPIOs. Any user of this setup would
+	 * need to adjust the DT accordingly: dr_mode set to "host",
+	 * enabling OHCI0 and EHCI0.
+	 */
+	dr_mode = "peripheral";
+	status = "okay";
+};
+
+&ir {
+	pinctrl-names = "default";
+	pinctrl-0 = <&ir_rx_pin>;
+	status = "okay";
+};
+
+&codec {
+    allwinner,audio-routing =
+        "Line Out", "LINEOUT";
+    status = "okay";
+};
+
+&ahub_codec {
+	status = "okay";
+};
+
+&cpu0 {
+    cpu-supply = <&reg_dcdc2>;
+};
+
+&ahub_cpudai0 {
+	status = "okay";
+};
+
+&ahub_cpudai1 {
+	status = "okay";
+};
+
+&ahub_cpudai2 {
+	status = "okay";
+};
+
+&sndahub {
+	status = "okay";
+};
+
+&ahub_i2s1 {
+	status = "okay";
+};
diff -Nuar -r --no-dereference linux-5.15.139/arch/arm64/boot/dts/allwinner/sun50i-h616.dtsi linux/arch/arm64/boot/dts/allwinner/sun50i-h616.dtsi
--- linux-5.15.139/arch/arm64/boot/dts/allwinner/sun50i-h616.dtsi	1970-01-01 08:00:00.000000000 +0800
+++ linux/arch/arm64/boot/dts/allwinner/sun50i-h616.dtsi	2024-01-03 18:54:40.403503200 +0800
@@ -0,0 +1,1422 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+// Copyright (C) 2020 Arm Ltd.
+// based on the H6 dtsi, which is:
+//   Copyright (C) 2017 Icenowy Zheng <icenowy@aosc.io>
+
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+#include <dt-bindings/clock/sun50i-h616-ccu.h>
+#include <dt-bindings/clock/sun50i-h6-r-ccu.h>
+#include <dt-bindings/clock/sun8i-de2.h>
+#include <dt-bindings/clock/sun8i-tcon-top.h>
+#include <dt-bindings/reset/sun50i-h616-ccu.h>
+#include <dt-bindings/reset/sun50i-h6-r-ccu.h>
+#include <dt-bindings/reset/sun8i-de2.h>
+#include <dt-bindings/thermal/thermal.h>
+
+/ {
+	interrupt-parent = <&gic>;
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	cpus {
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		cpu0: cpu@0 {
+			compatible = "arm,cortex-a53";
+			device_type = "cpu";
+			reg = <0>;
+			enable-method = "psci";
+			clocks = <&ccu CLK_CPUX>;
+			clock-latency-ns = <244144>; /* 8 32k periods */
+			#cooling-cells = <2>;
+		};
+
+		cpu1: cpu@1 {
+			compatible = "arm,cortex-a53";
+			device_type = "cpu";
+			reg = <1>;
+			enable-method = "psci";
+			clocks = <&ccu CLK_CPUX>;
+			clock-latency-ns = <244144>; /* 8 32k periods */
+			#cooling-cells = <2>;
+		};
+
+		cpu2: cpu@2 {
+			compatible = "arm,cortex-a53";
+			device_type = "cpu";
+			reg = <2>;
+			enable-method = "psci";
+			clocks = <&ccu CLK_CPUX>;
+			clock-latency-ns = <244144>; /* 8 32k periods */
+			#cooling-cells = <2>;
+		};
+
+		cpu3: cpu@3 {
+			compatible = "arm,cortex-a53";
+			device_type = "cpu";
+			reg = <3>;
+			enable-method = "psci";
+			clocks = <&ccu CLK_CPUX>;
+			clock-latency-ns = <244144>; /* 8 32k periods */
+			#cooling-cells = <2>;
+		};
+	};
+
+	de: display-engine {
+		compatible = "allwinner,sun50i-h616-display-engine";
+		allwinner,pipelines = <&mixer0>;
+		status = "disabled";
+	};
+
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		/* 512KiB reserved for ARM Trusted Firmware (BL31) */
+		secmon_reserved: secmon@40000000 {
+			reg = <0x0 0x40000000 0x0 0x80000>;
+			no-map;
+		};
+	};
+
+	osc24M: osc24M_clk {
+		#clock-cells = <0>;
+		compatible = "fixed-clock";
+		clock-frequency = <24000000>;
+		clock-output-names = "osc24M";
+	};
+
+	pmu {
+		compatible = "arm,cortex-a53-pmu";
+		interrupts = <GIC_SPI 140 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 141 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 142 IRQ_TYPE_LEVEL_HIGH>,
+			     <GIC_SPI 143 IRQ_TYPE_LEVEL_HIGH>;
+		interrupt-affinity = <&cpu0>, <&cpu1>, <&cpu2>, <&cpu3>;
+	};
+
+	psci {
+		compatible = "arm,psci-0.2";
+		method = "smc";
+	};
+
+	timer {
+		compatible = "arm,armv8-timer";
+		arm,no-tick-in-suspend;
+		interrupts = <GIC_PPI 13
+			(GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_HIGH)>,
+			     <GIC_PPI 14
+			(GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_HIGH)>,
+			     <GIC_PPI 11
+			(GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_HIGH)>,
+			     <GIC_PPI 10
+			(GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_HIGH)>;
+	};
+
+	soc {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		ranges = <0x0 0x0 0x0 0x40000000>;
+
+		bus@1000000 {
+			compatible = "allwinner,sun50i-h616-de33",
+				     "allwinner,sun50i-a64-de2";
+			reg = <0x1000000 0x400000>;
+			allwinner,sram = <&de3_sram 1>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges = <0 0x1000000 0x400000>;
+
+			display_clocks: clock@8000 {
+				compatible = "allwinner,sun50i-h616-de33-clk";
+				reg = <0x8000 0x100>;
+				clocks = <&ccu CLK_DE>, <&ccu CLK_BUS_DE>;
+				clock-names = "mod", "bus";
+				resets = <&ccu RST_BUS_DE>;
+				#clock-cells = <1>;
+				#reset-cells = <1>;
+			};
+
+			mixer0: mixer@100000 {
+				compatible = "allwinner,sun50i-h616-de33-mixer-0";
+				reg = <0x100000 0x100000>,
+				      <0x8100 0x40>,
+				      <0x280000 0x20000>;
+				clocks = <&display_clocks CLK_BUS_MIXER0>,
+					 <&display_clocks CLK_MIXER0>;
+				clock-names = "bus", "mod";
+				resets = <&display_clocks RST_MIXER0>;
+
+				ports {
+					#address-cells = <1>;
+					#size-cells = <0>;
+
+					mixer0_out: port@1 {
+						reg = <1>;
+
+						mixer0_out_tcon_top_mixer0: endpoint {
+							remote-endpoint = <&tcon_top_mixer0_in_mixer0>;
+						};
+					};
+				};
+			};
+		};
+
+		syscon: syscon@3000000 {
+			compatible = "allwinner,sun50i-h616-system-control";
+			// reg = <0x03000000 0x1000>;
+            reg = <0x03000000 0x30>,<0x03000038 0x0fc8>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges;
+
+			sram_a2: sram@100000 {
+				compatible = "mmio-sram";
+				reg = <0x00100000 0x18000>;
+				#address-cells = <1>;
+				#size-cells = <1>;
+				ranges = <0 0x00100000 0x18000>;
+
+				scpi_sram: scpi-sram@17c00 {
+					compatible = "arm,scp-shmem";
+					reg = <0x17c00 0x200>;
+				};
+			};
+
+			sram_c: sram@28000 {
+				compatible = "mmio-sram";
+				reg = <0x00028000 0x30000>;
+				#address-cells = <1>;
+				#size-cells = <1>;
+				ranges = <0 0x00028000 0x30000>;
+
+				de3_sram: sram-section@0 {
+					compatible = "allwinner,sun50i-h616-sram-c",
+						     "allwinner,sun50i-a64-sram-c";
+					reg = <0x0000 0x1e000>;
+				};
+			};
+
+			sram_c1: sram@1a00000 {
+				compatible = "mmio-sram";
+				reg = <0x01a00000 0x200000>;
+				#address-cells = <1>;
+				#size-cells = <1>;
+				ranges = <0 0x01a00000 0x200000>;
+
+				ve_sram: sram-section@0 {
+					compatible = "allwinner,sun50i-h616-sram-c1";
+					reg = <0x000000 0x200000>;
+				};
+			};
+		};
+
+		ccu: clock@3001000 {
+			compatible = "allwinner,sun50i-h616-ccu";
+			reg = <0x03001000 0x1000>;
+			clocks = <&osc24M>, <&rtc 0>, <&rtc 2>;
+			clock-names = "hosc", "losc", "iosc";
+			#clock-cells = <1>;
+			#reset-cells = <1>;
+		};
+
+		sid: efuse@3006000 {
+			compatible = "allwinner,sun50i-h616-sid";
+			reg = <0x03006000 0x1000>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+
+			cpu_speed_grade: cpu-speed-grade@00 {
+				reg = <0x00 0x02>;
+			};
+
+			ths_calibration: thermal-sensor-calibration@14 {
+				reg = <0x14 0x8>;
+			};
+
+            ephy_calibration: ephy-calibration@2c {
+				reg = <0x2c 0x2>;
+			};
+		};
+
+		watchdog: watchdog@30090a0 {
+			compatible = "allwinner,sun50i-h616-wdt",
+				     "allwinner,sun6i-a31-wdt";
+			reg = <0x030090a0 0x20>;
+			interrupts = <GIC_SPI 50 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&osc24M>;
+			status = "okay";
+		};
+
+		pwm: pwm@300a000 {
+			compatible = "allwinner,sun50i-h616-pwm";
+			reg = <0x0300a000 0x400>;
+			clocks = <&osc24M>, <&ccu CLK_BUS_PWM>;
+			clock-names = "mod", "bus";
+			resets = <&ccu RST_BUS_PWM>;
+			pwm-number = <6>;
+			pwm-base = <0x0>;
+			sunxi-pwms = <&pwm0>, <&pwm1>, <&pwm2>, <&pwm3>, <&pwm4>, <&pwm5>;
+			#pwm-cells = <3>;
+			status = "okay";
+		};
+
+		pwm0: pwm0@0300a000 {
+			compatible = "allwinner,sunxi-pwm0";
+		};
+
+		pwm1: pwm1@0300a000 {
+			compatible = "allwinner,sunxi-pwm1";
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm1_pin>;
+		};
+
+		pwm2: pwm2@0300a000 {
+			compatible = "allwinner,sunxi-pwm2";
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm2_pin>;
+		};
+
+		pwm3: pwm3@0300a000 {
+			compatible = "allwinner,sunxi-pwm3";
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm3_pin>;
+		};
+
+		pwm4: pwm4@0300a000 {
+			compatible = "allwinner,sunxi-pwm4";
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm4_pin>;
+		};
+
+		pwm5: pwm5@0300a000 {
+			compatible = "allwinner,sunxi-pwm5";
+			pinctrl-names = "default";
+			pinctrl-0 = <&pwm5_pin>;
+		};
+
+		pio: pinctrl@300b000 {
+			compatible = "allwinner,sun50i-h616-pinctrl";
+			reg = <0x0300b000 0x400>;
+			interrupts = <GIC_SPI 51 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 52 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 53 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 43 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 54 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 55 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 56 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 57 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_APB1>, <&osc24M>, <&rtc 0>;
+			clock-names = "apb", "hosc", "losc";
+			gpio-controller;
+			#gpio-cells = <3>;
+			interrupt-controller;
+			#interrupt-cells = <3>;
+
+			ext_rgmii_pins: rgmii-pins {
+				pins = "PI0", "PI1", "PI2", "PI3", "PI4",
+				       "PI5", "PI7", "PI8", "PI9", "PI10",
+				       "PI11", "PI12", "PI13", "PI14", "PI15",
+				       "PI16";
+				function = "emac0";
+				drive-strength = <40>;
+			};
+
+            rmii_pins: rmii-pins {
+				pins = "PA0", "PA1", "PA2", "PA3", "PA4",
+				       "PA5", "PA6", "PA7", "PA8", "PA9";
+				function = "emac1";
+				drive-strength = <40>;
+			};
+
+			i2c0_pins: i2c0-pins {
+				pins = "PI6", "PI7";
+				function = "i2c0";
+			};
+
+			i2c1_pins: i2c1-pins {
+				pins = "PH0", "PH1";
+				function = "i2c1";
+			};
+
+			i2c2_pins: i2c2-pins {
+				pins = "PH2", "PH3";
+				function = "i2c2";
+			};
+
+			i2c3_pins: i2c3-pins {
+				pins = "PH4", "PH5";
+				function = "i2c3";
+			};
+
+			i2c4_pins: i2c4-pins {
+				pins = "PH6", "PH7";
+				function = "i2c4";
+			};
+
+			i2s3_pins: i2s3-pins {
+				pins = "PH5", "PH6", "PH7", "PH8", "PH9";
+				function = "i2s3";
+			};
+
+			ir_rx_pin: ir-rx-pin {
+				pins = "PH10";
+				function = "ir_rx";
+			};
+
+			pwm1_pin: pwm1-pin {
+				pins = "PH3";
+				function = "pwm1";
+			};
+
+			pwm2_pin: pwm2-pin {
+				pins = "PH2";
+				function = "pwm2";
+			};
+
+			pwm3_pin: pwm3-pin {
+				pins = "PH0";
+				function = "pwm3";
+			};
+
+			pwm4_pin: pwm4-pin {
+				pins = "PH1";
+				function = "pwm4";
+			};
+
+			pwm5_pin: pwm5-pin {
+				pins = "PA12";
+				function = "pwm5";
+			};
+
+			mmc0_pins: mmc0-pins {
+				pins = "PF0", "PF1", "PF2", "PF3",
+				       "PF4", "PF5";
+				function = "mmc0";
+				drive-strength = <40>;
+				bias-pull-up;
+			};
+
+			mmc1_pins: mmc1-pins {
+				pins = "PG0", "PG1", "PG2", "PG3",
+				       "PG4", "PG5";
+				function = "mmc1";
+				drive-strength = <40>;
+				bias-pull-up;
+			};
+
+			mmc2_pins: mmc2-pins {
+				pins = "PC0", "PC1", "PC5", "PC6",
+				       "PC8", "PC9", "PC10", "PC11",
+				       "PC13", "PC14", "PC15", "PC16";
+				function = "mmc2";
+				drive-strength = <30>;
+				bias-pull-up;
+			};
+
+			spi0_pins: spi0-pins {
+				pins = "PC0", "PC2", "PC4";
+				function = "spi0";
+			};
+
+			spi1_pins: spi1-pins {
+				pins = "PH6", "PH7", "PH8";
+				function = "spi1";
+			};
+
+			spi1_cs_pin: spi1-cs-pin {
+				pins = "PH9";
+				function = "spi1";
+			};
+
+			uart0_ph_pins: uart0-ph-pins {
+				pins = "PH0", "PH1";
+				function = "uart0";
+			};
+
+			uart1_pins: uart1-pins {
+				pins = "PG6", "PG7";
+				function = "uart1";
+			};
+
+			uart1_rts_cts_pins: uart1-rts-cts-pins {
+				pins = "PG8", "PG9";
+				function = "uart1";
+			};
+
+			uart2_ph_pins: uart2-ph-pins {
+				pins = "PH5", "PH6";
+				function = "uart2";
+			};
+
+			uart2_rts_cts_pins: uart2-rts-cts-pins {
+				pins = "PH7", "PH8";
+				function = "uart2";
+			};
+
+			uart5_ph_pins: uart5-ph-pins {
+				pins = "PH2", "PH3";
+				function = "uart5";
+			};
+		};
+
+		gic: interrupt-controller@3021000 {
+			compatible = "arm,gic-400";
+			reg = <0x03021000 0x1000>,
+			      <0x03022000 0x2000>,
+			      <0x03024000 0x2000>,
+			      <0x03026000 0x2000>;
+			interrupts = <GIC_PPI 9 (GIC_CPU_MASK_SIMPLE(4) | IRQ_TYPE_LEVEL_HIGH)>;
+			interrupt-controller;
+			#interrupt-cells = <3>;
+		};
+
+		mmc0: mmc@4020000 {
+			compatible = "allwinner,sun50i-h616-mmc",
+				     "allwinner,sun50i-a100-mmc";
+			reg = <0x04020000 0x1000>;
+			clocks = <&ccu CLK_BUS_MMC0>, <&ccu CLK_MMC0>;
+			clock-names = "ahb", "mmc";
+			resets = <&ccu RST_BUS_MMC0>;
+			reset-names = "ahb";
+			interrupts = <GIC_SPI 35 IRQ_TYPE_LEVEL_HIGH>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&mmc0_pins>;
+			status = "disabled";
+			max-frequency = <50000000>;
+			cap-sd-highspeed;
+			cap-mmc-highspeed;
+			mmc-ddr-3_3v;
+			mmc-ddr-1_8v;
+			cap-sdio-irq;
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		mmc1: mmc@4021000 {
+			compatible = "allwinner,sun50i-h616-mmc",
+				     "allwinner,sun50i-a100-mmc";
+			reg = <0x04021000 0x1000>;
+			clocks = <&ccu CLK_BUS_MMC1>, <&ccu CLK_MMC1>;
+			clock-names = "ahb", "mmc";
+			resets = <&ccu RST_BUS_MMC1>;
+			reset-names = "ahb";
+			interrupts = <GIC_SPI 36 IRQ_TYPE_LEVEL_HIGH>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&mmc1_pins>;
+			status = "disabled";
+			max-frequency = <25000000>;
+			cap-sd-highspeed;
+			cap-mmc-highspeed;
+			mmc-ddr-3_3v;
+			mmc-ddr-1_8v;
+			cap-sdio-irq;
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		mmc2: mmc@4022000 {
+			compatible = "allwinner,sun50i-h616-emmc",
+				     "allwinner,sun50i-a100-emmc";
+			reg = <0x04022000 0x1000>;
+			clocks = <&ccu CLK_BUS_MMC2>, <&ccu CLK_MMC2>;
+			clock-names = "ahb", "mmc";
+			resets = <&ccu RST_BUS_MMC2>;
+			reset-names = "ahb";
+			interrupts = <GIC_SPI 37 IRQ_TYPE_LEVEL_HIGH>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&mmc2_pins>;
+			status = "disabled";
+			max-frequency = <120000000>;
+			cap-sd-highspeed;
+			cap-mmc-highspeed;
+			mmc-ddr-3_3v;
+			mmc-ddr-1_8v;
+			cap-sdio-irq;
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		dma: dma-controller@3002000 {
+			compatible = "allwinner,sun50i-h616-dma";
+			reg = <0x03002000 0x1000>;
+			interrupts = <GIC_SPI 42 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_DMA>, <&ccu CLK_MBUS_DMA>;
+			clock-names = "bus", "mbus";
+			dma-channels = <16>;
+			dma-requests = <49>;
+			resets = <&ccu RST_BUS_DMA>;
+			#dma-cells = <1>;
+		};
+
+		codec: codec@05096000 {
+			#sound-dai-cells = <0>;
+			compatible = "allwinner,sun50i-h616-codec";
+			reg = <0x05096000 0x31c>;
+			interrupts = <GIC_SPI 58 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_AUDIO_CODEC>,
+				 <&ccu CLK_AUDIO_CODEC_1X>,
+				 <&ccu CLK_AUDIO_CODEC_4X>;
+			clock-names = "apb", "audio-codec-1x", "audio-codec-4x";
+			resets = <&ccu RST_BUS_AUDIO_CODEC>;
+			dmas = <&dma 6>;
+			dma-names = "tx";
+			status = "disabled";
+		};
+
+		ahub_codec: ahub_codec@0x05097000 {
+			compatible = "allwinner,sunxi-ahub";
+			reg = <0x5097000 0xadf>;
+			clocks = <&ccu CLK_BUS_AUDIO_HUB>,
+				 <&ccu CLK_AUDIO_CODEC_1X>,
+				 <&ccu CLK_AUDIO_CODEC_4X>,
+				 <&ccu CLK_AUDIO_HUB>;
+			clock-names = "apb", "audio-codec-1x", "audio-codec-4x", "audio-hub";
+			resets = <&ccu RST_BUS_AUDIO_HUB>;
+			status = "disabled";
+		};
+
+		ahub_cpudai0: cpudai0-controller@0x05097000 {
+			compatible = "allwinner,sunxi-ahub-cpudai";
+			reg = <0x05097000 0xADF>;
+			id = <0x0>;
+			dmas = <&dma 3>, <&dma 3>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		ahub_cpudai1: cpudai1-controller@0x05097000 {
+			compatible = "allwinner,sunxi-ahub-cpudai";
+			reg = <0x05097000 0xADF>;
+			id = <0x1>;
+			dmas = <&dma 4>, <&dma 4>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		ahub_cpudai2: cpudai2-controller@0x05097000 {
+			compatible = "allwinner,sunxi-ahub-cpudai";
+			reg = <0x05097000 0xADF>;
+			id = <0x2>;
+			dmas = <&dma 5>, <&dma 5>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+		};
+
+		sndahub: sound@0{
+			compatible = "allwinner,sunxi-ahub-machine";
+			sunxi,cpudai-controller0 = <&ahub_cpudai0>;
+			sunxi,cpudai-controller1 = <&ahub_cpudai1>;
+			sunxi,cpudai-controller2 = <&ahub_cpudai2>;
+			sunxi,audio-codec = <&ahub_codec>;
+			status = "disabled";
+		};
+
+		ahub_i2s1: ahub-i2s1@0x05097000 {
+			#sound-dai-cells = <0>;
+			compatible = "allwinner,sunxi-ahub-daudio";
+			reg = <0x5097000 0xadf>;
+			clocks = <&ccu CLK_BUS_AUDIO_HUB>,
+				 <&ccu CLK_AUDIO_CODEC_1X>,
+				 <&ccu CLK_AUDIO_CODEC_4X>,
+				 <&ccu CLK_AUDIO_HUB>;
+			clock-names = "apb", "audio-codec-1x", "audio-codec-4x", "audio-hub";
+			tdm_num = <0x1>;
+			pinconfig = <0x0>;
+			frametype = <0x0>;
+			pcm_lrck_period = <0x20>;
+			slot_width_select = <0x20>;
+			daudio_master = <0x4>;
+			audio_format = <0x1>;
+			signal_inversion = <0x1>;
+			tdm_config = <0x1>;
+			mclk_div = <0x1>;
+			status = "disabled";
+		};
+
+		ahub_i2s3: ahub-i2s3@0x05097000 {
+			//#sound-dai-cells = <0>;
+			compatible = "allwinner,sunxi-ahub-daudio";
+			reg = <0x5097000 0xadf>;
+			clocks = <&ccu CLK_BUS_AUDIO_HUB>,
+				 <&ccu CLK_AUDIO_CODEC_1X>,
+				 <&ccu CLK_AUDIO_CODEC_4X>,
+				 <&ccu CLK_AUDIO_HUB>;
+			clock-names = "apb", "audio-codec-1x", "audio-codec-4x", "audio-hub";
+			pinctrl-names = "default";
+			pinctrl-0 = <&i2s3_pins>;
+			tdm_num = <0x3>;
+			pinconfig = <0x1>;
+			frametype = <0x0>;
+			pcm_lrck_period = <0x20>;
+			slot_width_select = <0x20>;
+			daudio_master = <0x4>;
+			audio_format = <0x1>;
+			signal_inversion = <0x1>;
+			tdm_config = <0x1>;
+			mclk_div = <0x4>;
+			status = "disabled";
+		};
+
+		uart0: serial@5000000 {
+			compatible = "snps,dw-apb-uart";
+			reg = <0x05000000 0x400>;
+			interrupts = <GIC_SPI 0 IRQ_TYPE_LEVEL_HIGH>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			clocks = <&ccu CLK_BUS_UART0>;
+			resets = <&ccu RST_BUS_UART0>;
+			status = "disabled";
+		};
+
+		uart1: serial@5000400 {
+			compatible = "snps,dw-apb-uart";
+			reg = <0x05000400 0x400>;
+			interrupts = <GIC_SPI 1 IRQ_TYPE_LEVEL_HIGH>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			clocks = <&ccu CLK_BUS_UART1>;
+			resets = <&ccu RST_BUS_UART1>;
+			status = "disabled";
+		};
+
+		uart2: serial@5000800 {
+			compatible = "snps,dw-apb-uart";
+			reg = <0x05000800 0x400>;
+			interrupts = <GIC_SPI 2 IRQ_TYPE_LEVEL_HIGH>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			clocks = <&ccu CLK_BUS_UART2>;
+			resets = <&ccu RST_BUS_UART2>;
+			status = "disabled";
+		};
+
+		uart3: serial@5000c00 {
+			compatible = "snps,dw-apb-uart";
+			reg = <0x05000c00 0x400>;
+			interrupts = <GIC_SPI 3 IRQ_TYPE_LEVEL_HIGH>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			clocks = <&ccu CLK_BUS_UART3>;
+			resets = <&ccu RST_BUS_UART3>;
+			status = "disabled";
+		};
+
+		uart4: serial@5001000 {
+			compatible = "snps,dw-apb-uart";
+			reg = <0x05001000 0x400>;
+			interrupts = <GIC_SPI 4 IRQ_TYPE_LEVEL_HIGH>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			clocks = <&ccu CLK_BUS_UART4>;
+			resets = <&ccu RST_BUS_UART4>;
+			status = "disabled";
+		};
+
+		uart5: serial@5001400 {
+			compatible = "snps,dw-apb-uart";
+			reg = <0x05001400 0x400>;
+			interrupts = <GIC_SPI 5 IRQ_TYPE_LEVEL_HIGH>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+			clocks = <&ccu CLK_BUS_UART5>;
+			resets = <&ccu RST_BUS_UART5>;
+			status = "disabled";
+		};
+
+		i2c0: i2c@5002000 {
+			compatible = "allwinner,sun50i-h616-i2c",
+				     "allwinner,sun6i-a31-i2c";
+			reg = <0x05002000 0x400>;
+			interrupts = <GIC_SPI 6 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_I2C0>;
+			resets = <&ccu RST_BUS_I2C0>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&i2c0_pins>;
+			status = "disabled";
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		i2c1: i2c@5002400 {
+			compatible = "allwinner,sun50i-h616-i2c",
+				     "allwinner,sun6i-a31-i2c";
+			reg = <0x05002400 0x400>;
+			interrupts = <GIC_SPI 7 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_I2C1>;
+			resets = <&ccu RST_BUS_I2C1>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&i2c1_pins>;
+			status = "disabled";
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		i2c2: i2c@5002800 {
+			compatible = "allwinner,sun50i-h616-i2c",
+				     "allwinner,sun6i-a31-i2c";
+			reg = <0x05002800 0x400>;
+			interrupts = <GIC_SPI 8 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_I2C2>;
+			resets = <&ccu RST_BUS_I2C2>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&i2c2_pins>;
+			status = "disabled";
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		i2c3: i2c@5002c00 {
+			compatible = "allwinner,sun50i-h616-i2c",
+				     "allwinner,sun6i-a31-i2c";
+			reg = <0x05002c00 0x400>;
+			interrupts = <GIC_SPI 9 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_I2C3>;
+			resets = <&ccu RST_BUS_I2C3>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&i2c3_pins>;
+			status = "disabled";
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		i2c4: i2c@5003000 {
+			compatible = "allwinner,sun50i-h616-i2c",
+				     "allwinner,sun6i-a31-i2c";
+			reg = <0x05003000 0x400>;
+			interrupts = <GIC_SPI 10 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_I2C4>;
+			resets = <&ccu RST_BUS_I2C4>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&i2c4_pins>;
+			status = "disabled";
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		spi0: spi@5010000 {
+			compatible = "allwinner,sun50i-h616-spi",
+				     "allwinner,sun8i-h3-spi";
+			reg = <0x05010000 0x1000>;
+			interrupts = <GIC_SPI 12 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_SPI0>, <&ccu CLK_SPI0>;
+			clock-names = "ahb", "mod";
+			resets = <&ccu RST_BUS_SPI0>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&spi0_pins>;
+			dmas = <&dma 22>, <&dma 22>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		spi1: spi@5011000 {
+			compatible = "allwinner,sun50i-h616-spi",
+				     "allwinner,sun8i-h3-spi";
+			reg = <0x05011000 0x1000>;
+			interrupts = <GIC_SPI 13 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_SPI1>, <&ccu CLK_SPI1>;
+			clock-names = "ahb", "mod";
+			resets = <&ccu RST_BUS_SPI1>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&spi1_pins>, <&spi1_cs_pin>;
+			dmas = <&dma 23>, <&dma 23>;
+			dma-names = "rx", "tx";
+			status = "disabled";
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		emac0: ethernet@5020000 {
+			compatible = "allwinner,sun50i-h616-emac",
+				     "allwinner,sun50i-a64-emac";
+			syscon = <&syscon>;
+			reg = <0x05020000 0x10000>;
+			interrupts = <GIC_SPI 14 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "macirq";
+			resets = <&ccu RST_BUS_EMAC0>;
+			reset-names = "stmmaceth";
+			clocks = <&ccu CLK_BUS_EMAC0>;
+			clock-names = "stmmaceth";
+			status = "disabled";
+
+			mdio0: mdio {
+				compatible = "snps,dwmac-mdio";
+				#address-cells = <1>;
+				#size-cells = <0>;
+			};
+		};
+
+        emac1: ethernet@5030000 { 
+            compatible = "allwinner,sunxi-gmac";
+			// syscon = <&syscon 1>;
+			reg = <0x05030000 0x10000>,
+                  <0x03000034 0x4>;
+			reg-names = "gmac1_reg","ephy_reg";      
+            interrupts = <GIC_SPI 15 IRQ_TYPE_LEVEL_HIGH>;          
+			interrupt-names = "gmacirq";
+			resets = <&ccu RST_BUS_EMAC1>;
+			reset-names = "stmmaceth";
+			clocks = <&ccu CLK_BUS_EMAC1>,<&ccu CLK_EMAC_25M>;
+			clock-names = "bus-emac1","emac-25m";
+			pinctrl-0 = <&rmii_pins>;
+			pinctrl-names = "default";
+			phy-mode = "rmii";
+			tx-delay = <7>;
+			rx-delay = <31>;
+			phy-rst;
+			gmac-power0;
+			gmac-power1;
+			gmac-power2;
+            status = "disabled";
+
+			mdio1: mdio {
+                // compatible = "snps,dwmac-mdio";
+				compatible = "ethernet-phy-ieee802.3-c22";
+				#address-cells = <1>;
+				#size-cells = <0>;
+			};
+		};
+
+		usbotg: usb@5100000 {
+			compatible = "allwinner,sun50i-h616-musb",
+				     "allwinner,sun8i-h3-musb";
+			reg = <0x05100000 0x0400>;
+			clocks = <&ccu CLK_BUS_OTG>;
+			resets = <&ccu RST_BUS_OTG>;
+			interrupts = <GIC_SPI 25 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "mc";
+			phys = <&usbphy 0>;
+			phy-names = "usb";
+			extcon = <&usbphy 0>;
+			status = "disabled";
+		};
+
+		usbphy: phy@5100400 {
+			compatible = "allwinner,sun50i-h616-usb-phy";
+			reg = <0x05100400 0x24>,
+			      <0x05101800 0x14>,
+			      <0x05200800 0x14>,
+			      <0x05310800 0x14>,
+			      <0x05311800 0x14>;
+			reg-names = "phy_ctrl",
+				    "pmu0",
+				    "pmu1",
+				    "pmu2",
+				    "pmu3";
+			clocks = <&ccu CLK_USB_PHY0>,
+				 <&ccu CLK_USB_PHY1>,
+				 <&ccu CLK_USB_PHY2>,
+				 <&ccu CLK_USB_PHY3>,
+				 <&ccu CLK_BUS_EHCI2>;
+			clock-names = "usb0_phy",
+				      "usb1_phy",
+				      "usb2_phy",
+				      "usb3_phy",
+				      "pmu2_clk";
+			resets = <&ccu RST_USB_PHY0>,
+				 <&ccu RST_USB_PHY1>,
+				 <&ccu RST_USB_PHY2>,
+				 <&ccu RST_USB_PHY3>;
+			reset-names = "usb0_reset",
+				      "usb1_reset",
+				      "usb2_reset",
+				      "usb3_reset";
+			status = "disabled";
+			#phy-cells = <1>;
+		};
+
+		ehci0: usb@5101000 {
+			compatible = "allwinner,sun50i-h616-ehci",
+				     "generic-ehci";
+			reg = <0x05101000 0x100>;
+			interrupts = <GIC_SPI 26 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_OHCI0>,
+				 <&ccu CLK_BUS_EHCI0>,
+				 <&ccu CLK_USB_OHCI0>,
+				 <&ccu CLK_USB_PHY2>;
+			resets = <&ccu RST_BUS_OHCI0>,
+				 <&ccu RST_BUS_EHCI0>,
+				 <&ccu RST_USB_PHY2>;
+			phys = <&usbphy 0>;
+			phy-names = "usb";
+			status = "disabled";
+		};
+
+		ohci0: usb@5101400 {
+			compatible = "allwinner,sun50i-h616-ohci",
+				     "generic-ohci";
+			reg = <0x05101400 0x100>;
+			interrupts = <GIC_SPI 27 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_OHCI0>,
+				 <&ccu CLK_USB_OHCI0>,
+				 <&ccu CLK_USB_PHY2>;
+			resets = <&ccu RST_BUS_OHCI0>,
+				 <&ccu RST_USB_PHY2>;
+			phys = <&usbphy 0>;
+			phy-names = "usb";
+			status = "disabled";
+		};
+
+		ehci1: usb@5200000 {
+			compatible = "allwinner,sun50i-h616-ehci",
+				     "generic-ehci";
+			reg = <0x05200000 0x100>;
+			interrupts = <GIC_SPI 28 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_OHCI1>,
+				 <&ccu CLK_BUS_EHCI1>,
+				 <&ccu CLK_USB_OHCI1>,
+				 <&ccu CLK_USB_PHY2>;
+			resets = <&ccu RST_BUS_OHCI1>,
+				 <&ccu RST_BUS_EHCI1>,
+				 <&ccu RST_USB_PHY2>;
+			phys = <&usbphy 1>;
+			phy-names = "usb";
+			status = "disabled";
+		};
+
+		ohci1: usb@5200400 {
+			compatible = "allwinner,sun50i-h616-ohci",
+				     "generic-ohci";
+			reg = <0x05200400 0x100>;
+			interrupts = <GIC_SPI 29 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_OHCI1>,
+				 <&ccu CLK_USB_OHCI1>,
+				 <&ccu CLK_USB_PHY2>;
+			resets = <&ccu RST_BUS_OHCI1>,
+				 <&ccu RST_USB_PHY2>;
+			phys = <&usbphy 1>;
+			phy-names = "usb";
+			status = "disabled";
+		};
+
+		ehci2: usb@5310000 {
+			compatible = "allwinner,sun50i-h616-ehci",
+				     "generic-ehci";
+			reg = <0x05310000 0x100>;
+			interrupts = <GIC_SPI 30 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_OHCI2>,
+				 <&ccu CLK_BUS_EHCI2>,
+				 <&ccu CLK_USB_OHCI2>;
+			resets = <&ccu RST_BUS_OHCI2>,
+				 <&ccu RST_BUS_EHCI2>;
+			phys = <&usbphy 2>;
+			phy-names = "usb";
+			status = "disabled";
+		};
+
+		ohci2: usb@5310400 {
+			compatible = "allwinner,sun50i-h616-ohci",
+				     "generic-ohci";
+			reg = <0x05310400 0x100>;
+			interrupts = <GIC_SPI 31 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_OHCI2>,
+				 <&ccu CLK_USB_OHCI2>;
+			resets = <&ccu RST_BUS_OHCI2>;
+			phys = <&usbphy 2>;
+			phy-names = "usb";
+			status = "disabled";
+		};
+
+		ehci3: usb@5311000 {
+			compatible = "allwinner,sun50i-h616-ehci",
+				     "generic-ehci";
+			reg = <0x05311000 0x100>;
+			interrupts = <GIC_SPI 32 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_OHCI3>,
+				 <&ccu CLK_BUS_EHCI3>,
+				 <&ccu CLK_USB_OHCI3>,
+				 <&ccu CLK_USB_PHY2>;
+			resets = <&ccu RST_BUS_OHCI3>,
+				 <&ccu RST_BUS_EHCI3>,
+				 <&ccu RST_USB_PHY2>;
+			phys = <&usbphy 3>;
+			phy-names = "usb";
+			status = "disabled";
+		};
+
+		ohci3: usb@5311400 {
+			compatible = "allwinner,sun50i-h616-ohci",
+				     "generic-ohci";
+			reg = <0x05311400 0x100>;
+			interrupts = <GIC_SPI 33 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_OHCI3>,
+				 <&ccu CLK_USB_OHCI3>,
+				 <&ccu CLK_USB_PHY2>;
+			resets = <&ccu RST_BUS_OHCI3>,
+				 <&ccu RST_USB_PHY2>;
+			phys = <&usbphy 3>;
+			phy-names = "usb";
+			status = "disabled";
+		};
+
+		hdmi: hdmi@6000000 {
+			#sound-dai-cells = <0>;
+			compatible = "allwinner,sun50i-h616-dw-hdmi";
+			reg = <0x06000000 0x10000>;
+			reg-io-width = <1>;
+			interrupts = <GIC_SPI 63 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_HDMI>, <&ccu CLK_HDMI_SLOW>,
+				 <&ccu CLK_HDMI>, <&ccu CLK_HDMI_CEC>,
+				 <&ccu CLK_HDCP>, <&ccu CLK_BUS_HDCP>;
+			clock-names = "iahb", "isfr", "tmds", "cec", "hdcp", "hdcp-bus";
+			resets = <&ccu RST_BUS_HDMI>, <&ccu RST_BUS_HDCP>;
+			reset-names = "ctrl", "hdcp";
+			phys = <&hdmi_phy>;
+			phy-names = "phy";
+            drive-strength = <10>;
+			status = "disabled";
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				hdmi_in: port@0 {
+					reg = <0>;
+
+					hdmi_in_tcon_top: endpoint {
+						remote-endpoint = <&tcon_top_hdmi_out_hdmi>;
+					};
+				};
+
+				hdmi_out: port@1 {
+					reg = <1>;
+				};
+			};
+		};
+
+		hdmi_phy: hdmi-phy@6010000 {
+			compatible = "allwinner,sun50i-h616-hdmi-phy";
+			reg = <0x06010000 0x10000>;
+			clocks = <&ccu CLK_BUS_HDMI>, <&ccu CLK_HDMI_SLOW>;
+			clock-names = "bus", "mod";
+			resets = <&ccu RST_BUS_HDMI_SUB>;
+			reset-names = "phy";
+			#phy-cells = <0>;
+		};
+
+        hdmi_audio: hdmi-audio@1 {
+			compatible = "allwinner,sunxi-hdmi-machine";
+			sunxi,cpudai-controller = <&ahub_i2s1>;
+			sunxi,snddaudio-codec = "hdmi-audio-codec.4.auto";
+			status = "disabled";
+		};
+
+		tcon_top: tcon-top@6510000 {
+			compatible = "allwinner,sun50i-h616-tcon-top";
+			reg = <0x06510000 0x1000>;
+			clocks = <&ccu CLK_BUS_TCON_TOP>,
+				 <&ccu CLK_TCON_TV0>;
+			clock-names = "bus", "tcon-tv0";
+			clock-output-names = "tcon-top-tv0";
+			resets = <&ccu RST_BUS_TCON_TOP>;
+			#clock-cells = <1>;
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+                
+				tcon_top_mixer0_in: port@0 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <0>;
+
+					tcon_top_mixer0_in_mixer0: endpoint@0 {
+						reg = <0>;
+						remote-endpoint = <&mixer0_out_tcon_top_mixer0>;
+					};
+				};
+
+				tcon_top_mixer0_out: port@1 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <1>;
+
+					tcon_top_mixer0_out_tcon_tv: endpoint@2 {
+						reg = <2>;
+						remote-endpoint = <&tcon_tv_in_tcon_top_mixer0>;
+					};
+				};
+                
+				tcon_top_hdmi_in: port@4 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <4>;
+
+					tcon_top_hdmi_in_tcon_tv: endpoint@0 {
+						reg = <0>;
+						remote-endpoint = <&tcon_tv_out_tcon_top>;
+					};
+				};
+
+				tcon_top_hdmi_out: port@5 {
+					reg = <5>;
+
+					tcon_top_hdmi_out_hdmi: endpoint {
+						remote-endpoint = <&hdmi_in_tcon_top>;
+					};
+				};
+			};
+		};
+
+		video-codec@1c0e000 {
+			compatible = "allwinner,sun50i-h616-video-engine";
+			reg = <0x01c0e000 0x2000>;
+			clocks = <&ccu CLK_BUS_VE>, <&ccu CLK_VE>,
+				 <&ccu CLK_MBUS_VE>;
+			clock-names = "ahb", "mod", "ram";
+			resets = <&ccu RST_BUS_VE>;
+			interrupts = <GIC_SPI 93 IRQ_TYPE_LEVEL_HIGH>;
+			allwinner,sram = <&ve_sram 1>;
+		};
+
+		gpu: gpu@0x01800000 {
+			compatible = "allwinner,sun50i-h616-mali", "arm,mali-bifrost";
+			reg = <0x1800000 0x40000>;
+			interrupt-parent = <&gic>;
+			interrupts = <GIC_SPI 95 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 96 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 97 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "job", "mmu", "gpu";
+			clocks = <&ccu CLK_GPU0>, <&ccu CLK_BUS_GPU>;
+			clock-names = "core", "bus";
+			resets = <&ccu RST_BUS_GPU>;
+			//operating-points-v2 = <&gpu_opp_table>;
+			//#cooling-cells = <2>;
+			status = "disabled";
+		};
+
+		tcon_tv: lcd-controller@6515000 {
+			compatible = "allwinner,sun50i-h616-tcon-tv";
+			reg = <0x06515000 0x1000>;
+			interrupts = <GIC_SPI 66 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_TCON_TV0>,
+				 <&tcon_top CLK_TCON_TOP_TV0>;
+			clock-names = "ahb", "tcon-ch1";
+			resets = <&ccu RST_BUS_TCON_TV0>;
+			reset-names = "lcd";
+
+			ports {
+				#address-cells = <1>;
+				#size-cells = <0>;
+
+				tcon_tv_in: port@0 {
+					reg = <0>;
+
+					tcon_tv_in_tcon_top_mixer0: endpoint {
+						remote-endpoint = <&tcon_top_mixer0_out_tcon_tv>;
+					};
+				};
+
+				tcon_tv_out: port@1 {
+					#address-cells = <1>;
+					#size-cells = <0>;
+					reg = <1>;
+
+					tcon_tv_out_tcon_top: endpoint@1 {
+						reg = <1>;
+						remote-endpoint = <&tcon_top_hdmi_in_tcon_tv>;
+					};
+				};
+			};
+		};
+
+		rtc: rtc@7000000 {
+			compatible = "allwinner,sun50i-h616-rtc",
+				     "allwinner,sun50i-h6-rtc";
+			reg = <0x07000000 0x400>;
+			interrupts = <GIC_SPI 101 IRQ_TYPE_LEVEL_HIGH>,
+				     <GIC_SPI 102 IRQ_TYPE_LEVEL_HIGH>;
+			clock-output-names = "osc32k", "osc32k-out", "iosc";
+			#clock-cells = <1>;
+		};
+
+		r_ccu: clock@7010000 {
+			compatible = "allwinner,sun50i-h616-r-ccu";
+			reg = <0x07010000 0x210>;
+			clocks = <&osc24M>, <&rtc 0>, <&rtc 2>,
+				 <&ccu CLK_PLL_PERIPH0>;
+			clock-names = "hosc", "losc", "iosc", "pll-periph";
+			#clock-cells = <1>;
+			#reset-cells = <1>;
+		};
+
+		r_pio: pinctrl@7022000 {
+			compatible = "allwinner,sun50i-h616-r-pinctrl";
+			reg = <0x07022000 0x400>;
+			interrupts = <GIC_SPI 43 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&r_ccu CLK_R_APB1>, <&osc24M>, <&rtc 0>;
+			clock-names = "apb", "hosc", "losc";
+			gpio-controller;
+			#gpio-cells = <3>;
+			interrupt-controller;
+			#interrupt-cells = <3>;
+
+			r_i2c_pins: r-i2c-pins {
+				pins = "PL0", "PL1";
+				function = "s_i2c";
+			};
+
+			r_rsb_pins: r-rsb-pins {
+				pins = "PL0", "PL1";
+				function = "s_rsb";
+			};
+		};
+
+		ir: ir@7040000 {
+				compatible = "allwinner,sun50i-h616-ir",
+					     "allwinner,sun6i-a31-ir";
+				reg = <0x07040000 0x400>;
+				interrupts = <GIC_SPI 106 IRQ_TYPE_LEVEL_HIGH>;
+				clocks = <&r_ccu CLK_R_APB1_IR>,
+					 <&r_ccu CLK_IR>;
+				clock-names = "apb", "ir";
+				resets = <&r_ccu RST_R_APB1_IR>;
+				pinctrl-names = "default";
+				pinctrl-0 = <&ir_rx_pin>;
+				status = "disabled";
+		};
+
+		r_i2c: i2c@7081400 {
+			compatible = "allwinner,sun50i-h616-i2c",
+				     "allwinner,sun6i-a31-i2c";
+			reg = <0x07081400 0x400>;
+			interrupts = <GIC_SPI 105 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&r_ccu CLK_R_APB2_I2C>;
+			resets = <&r_ccu RST_R_APB2_I2C>;
+			status = "disabled";
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		r_rsb: rsb@7083000 {
+			compatible = "allwinner,sun50i-h616-rsb",
+				     "allwinner,sun8i-a23-rsb";
+			reg = <0x07083000 0x400>;
+			interrupts = <GIC_SPI 109 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&r_ccu CLK_R_APB2_RSB>;
+			clock-frequency = <3000000>;
+			resets = <&r_ccu RST_R_APB2_RSB>;
+			pinctrl-names = "default";
+			pinctrl-0 = <&r_rsb_pins>;
+			status = "disabled";
+			#address-cells = <1>;
+			#size-cells = <0>;
+		};
+
+		ths: thermal-sensor@5070400 {
+			compatible = "allwinner,sun50i-h616-ths";
+			reg = <0x05070400 0x400>;
+			interrupts = <GIC_SPI 19 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&ccu CLK_BUS_THS>;
+			clock-names = "bus";
+			resets = <&ccu RST_BUS_THS>;
+			nvmem-cells = <&ths_calibration>;
+			nvmem-cell-names = "calibration";
+			#thermal-sensor-cells = <1>;
+		};
+
+		dump_reg: dump_reg@20000 {
+			compatible = "allwinner,sunxi-dump-reg";
+			reg = <0x0 0x03001000 0x0 0x0f20>;
+			status = "okay";
+		};
+
+		sunxi-info {
+			compatible = "allwinner,sun50i-h616-sys-info";
+			status = "okay";
+		};
+
+		addr_mgt: addr-mgt {
+			compatible = "allwinner,sunxi-addr_mgt";
+			type_addr_wifi = <0x2>;
+			type_addr_bt = <0x2>;
+			type_addr_eth = <0x2>;
+			status = "okay";
+		};
+	};
+
+	thermal-zones {
+		cpu-thermal {
+			polling-delay-passive = <500>;
+			polling-delay = <1000>;
+			thermal-sensors = <&ths 2>;
+
+			trips {
+				cpu_warm: cpu_warm {
+					temperature = <75000>;
+					hysteresis = <2000>;
+					type = "passive";
+				};
+
+				cpu_hot_pre: cpu_hot_pre {
+					temperature = <80000>;
+					hysteresis = <2000>;
+					type = "passive";
+				};
+
+				cpu_hot: cpu_hot {
+					temperature = <85000>;
+					hysteresis = <2000>;
+					type = "passive";
+				};
+
+				cpu_very_hot: cpu_very_hot {
+					temperature = <90000>;
+					hysteresis = <2000>;
+					type = "passive";
+				};
+
+				cpu_crit: cpu_crit {
+					temperature = <105000>;
+					hysteresis = <2000>;
+					type = "critical";
+				};
+			};
+
+			cooling-maps {
+				cpu_warm_limit_cpu {
+					trip = <&cpu_warm>;
+					cooling-device = <&cpu0 THERMAL_NO_LIMIT 2>;
+				};
+
+				cpu_hot_pre_limit_cpu {
+					trip = <&cpu_hot_pre>;
+					cooling-device = <&cpu0 2 3>;
+				};
+
+				cpu_hot_limit_cpu {
+					trip = <&cpu_hot>;
+					cooling-device = <&cpu0 3 4>;
+				};
+
+				cpu_very_hot_limit_cpu {
+					trip = <&cpu_very_hot>;
+					cooling-device = <&cpu0 5 THERMAL_NO_LIMIT>;
+				};
+			};
+		};
+
+		gpu-thermal {
+			polling-delay-passive = <0>;
+			polling-delay = <0>;
+			thermal-sensors = <&ths 0>;
+		};
+
+		ve-thermal {
+			polling-delay-passive = <0>;
+			polling-delay = <0>;
+			thermal-sensors = <&ths 1>;
+		};
+
+		ddr-thermal {
+			polling-delay-passive = <0>;
+			polling-delay = <0>;
+			thermal-sensors = <&ths 3>;
+		};
+	};
+};
diff -Nuar -r --no-dereference linux-5.15.139/arch/arm64/boot/dts/allwinner/sun50i-h616-orangepi-zero2.dts linux/arch/arm64/boot/dts/allwinner/sun50i-h616-orangepi-zero2.dts
--- linux-5.15.139/arch/arm64/boot/dts/allwinner/sun50i-h616-orangepi-zero2.dts	1970-01-01 08:00:00.000000000 +0800
+++ linux/arch/arm64/boot/dts/allwinner/sun50i-h616-orangepi-zero2.dts	2024-01-03 16:06:25.935131000 +0800
@@ -0,0 +1,250 @@
+// SPDX-License-Identifier: (GPL-2.0+ or MIT)
+/*
+ * Copyright (C) 2020 Arm Ltd.
+ */
+
+/dts-v1/;
+
+#include "sun50i-h616.dtsi"
+
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+#include <dt-bindings/leds/common.h>
+
+/ {
+	model = "OrangePi Zero2";
+	compatible = "xunlong,orangepi-zero2", "allwinner,sun50i-h616";
+
+	aliases {
+		ethernet0 = &emac0;
+		serial0 = &uart0;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+
+	leds {
+		compatible = "gpio-leds";
+
+		led-0 {
+			function = LED_FUNCTION_POWER;
+			color = <LED_COLOR_ID_RED>;
+			gpios = <&pio 2 12 GPIO_ACTIVE_HIGH>; /* PC12 */
+			default-state = "on";
+		};
+
+		led-1 {
+			function = LED_FUNCTION_STATUS;
+			color = <LED_COLOR_ID_GREEN>;
+			gpios = <&pio 2 13 GPIO_ACTIVE_HIGH>; /* PC13 */
+		};
+	};
+
+	reg_vcc5v: vcc5v {
+		/* board wide 5V supply directly from the USB-C socket */
+		compatible = "regulator-fixed";
+		regulator-name = "vcc-5v";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		regulator-always-on;
+	};
+
+	reg_usb1_vbus: usb1-vbus {
+		compatible = "regulator-fixed";
+		regulator-name = "usb1-vbus";
+		regulator-min-microvolt = <5000000>;
+		regulator-max-microvolt = <5000000>;
+		vin-supply = <&reg_vcc5v>;
+		enable-active-high;
+		gpio = <&pio 2 16 GPIO_ACTIVE_HIGH>; /* PC16 */
+		status = "okay";
+	};
+};
+
+&ehci1 {
+	status = "okay";
+};
+
+&gpu {
+	mali-supply = <&reg_dcdcc>;
+	status = "okay";
+};
+
+/* USB 2 & 3 are on headers only. */
+
+&emac0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&ext_rgmii_pins>;
+	phy-mode = "rgmii";
+	phy-handle = <&ext_rgmii_phy>;
+	phy-supply = <&reg_dcdce>;
+	allwinner,rx-delay-ps = <3100>;
+	allwinner,tx-delay-ps = <700>;
+	status = "okay";
+};
+
+&mdio0 {
+	ext_rgmii_phy: ethernet-phy@1 {
+		compatible = "ethernet-phy-ieee802.3-c22";
+		reg = <1>;
+	};
+};
+
+&mmc0 {
+	vmmc-supply = <&reg_dcdce>;
+	cd-gpios = <&pio 5 6 GPIO_ACTIVE_LOW>;	/* PF6 */
+	bus-width = <4>;
+	status = "okay";
+};
+
+&ohci1 {
+	status = "okay";
+};
+
+&r_rsb {
+	status = "okay";
+
+	axp305: pmic@745 {
+		compatible = "x-powers,axp305", "x-powers,axp805",
+			     "x-powers,axp806";
+		interrupt-controller;
+		#interrupt-cells = <1>;
+		reg = <0x745>;
+
+		x-powers,self-working-mode;
+		vina-supply = <&reg_vcc5v>;
+		vinb-supply = <&reg_vcc5v>;
+		vinc-supply = <&reg_vcc5v>;
+		vind-supply = <&reg_vcc5v>;
+		vine-supply = <&reg_vcc5v>;
+		aldoin-supply = <&reg_vcc5v>;
+		bldoin-supply = <&reg_vcc5v>;
+		cldoin-supply = <&reg_vcc5v>;
+
+		regulators {
+			reg_aldo1: aldo1 {
+				regulator-always-on;
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-name = "vcc-sys";
+			};
+
+			reg_aldo2: aldo2 {	/* 3.3V on headers */
+				regulator-always-on;
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-name = "vcc3v3-ext";
+			};
+
+			reg_aldo3: aldo3 {	/* 3.3V on headers */
+				regulator-always-on;
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-name = "vcc3v3-ext2";
+			};
+
+			reg_bldo1: bldo1 {
+				regulator-always-on;
+				regulator-min-microvolt = <1800000>;
+				regulator-max-microvolt = <1800000>;
+				regulator-name = "vcc1v8";
+			};
+
+			bldo2 {
+				/* unused */
+			};
+
+			bldo3 {
+				/* unused */
+			};
+
+			bldo4 {
+				/* unused */
+			};
+
+			cldo1 {
+				/* reserved */
+			};
+
+			cldo2 {
+				/* unused */
+			};
+
+			cldo3 {
+				/* unused */
+			};
+
+			reg_dcdca: dcdca {
+				regulator-always-on;
+				regulator-min-microvolt = <810000>;
+				regulator-max-microvolt = <1080000>;
+				regulator-name = "vdd-cpu";
+			};
+
+			reg_dcdcc: dcdcc {
+				regulator-always-on;
+				regulator-min-microvolt = <810000>;
+				regulator-max-microvolt = <1080000>;
+				regulator-name = "vdd-gpu-sys";
+			};
+
+			reg_dcdcd: dcdcd {
+				regulator-always-on;
+				regulator-min-microvolt = <1500000>;
+				regulator-max-microvolt = <1500000>;
+				regulator-name = "vdd-dram";
+			};
+
+			reg_dcdce: dcdce {
+				regulator-boot-on;
+				regulator-min-microvolt = <3300000>;
+				regulator-max-microvolt = <3300000>;
+				regulator-name = "vcc-eth-mmc";
+			};
+
+			sw {
+				/* unused */
+			};
+		};
+	};
+};
+
+&spi0  {
+	status = "okay";
+
+	flash@0 {
+		#address-cells = <1>;
+		#size-cells = <1>;
+		compatible = "jedec,spi-nor";
+		reg = <0>;
+		spi-max-frequency = <40000000>;
+	};
+};
+
+&uart0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart0_ph_pins>;
+	status = "okay";
+};
+
+&usbotg {
+	/*
+	 * PHY0 pins are connected to a USB-C socket, but a role switch
+	 * is not implemented: both CC pins are pulled to GND.
+	 * The VBUS pins power the device, so a fixed peripheral mode
+	 * is the best choice.
+	 * The board can be powered via GPIOs, in this case port0 *can*
+	 * act as a host (with a cable/adapter ignoring CC), as VBUS is
+	 * then provided by the GPIOs. Any user of this setup would
+	 * need to adjust the DT accordingly: dr_mode set to "host",
+	 * enabling OHCI0 and EHCI0.
+	 */
+	dr_mode = "peripheral";
+	status = "okay";
+};
+
+&usbphy {
+	usb1_vbus-supply = <&reg_usb1_vbus>;
+	status = "okay";
+};
diff -Nuar -r --no-dereference linux-5.15.139/arch/arm64/include/asm/xor.h linux/arch/arm64/include/asm/xor.h
--- linux-5.15.139/arch/arm64/include/asm/xor.h	2023-11-20 18:08:30.000000000 +0800
+++ linux/arch/arm64/include/asm/xor.h	2024-01-03 16:06:25.935131000 +0800
@@ -50,21 +50,15 @@
 	kernel_neon_end();
 }
 
-static struct xor_block_template xor_block_arm64 = {
+static struct xor_block_template xor_block_arm64 __maybe_unused = {
 	.name   = "arm64_neon",
 	.do_2   = xor_neon_2,
 	.do_3   = xor_neon_3,
 	.do_4   = xor_neon_4,
 	.do_5	= xor_neon_5
 };
-#undef XOR_TRY_TEMPLATES
-#define XOR_TRY_TEMPLATES           \
-	do {        \
-		xor_speed(&xor_block_8regs);    \
-		xor_speed(&xor_block_32regs);    \
-		if (cpu_has_neon()) { \
-			xor_speed(&xor_block_arm64);\
-		} \
-	} while (0)
+
+#define XOR_SELECT_TEMPLATE(x)	\
+	(&xor_block_32regs)
 
 #endif /* ! CONFIG_KERNEL_MODE_NEON */
diff -Nuar -r --no-dereference linux-5.15.139/arch/arm64/include/generated/uapi/asm/sembuf.h linux/arch/arm64/include/generated/uapi/asm/sembuf.h
--- linux-5.15.139/arch/arm64/include/generated/uapi/asm/sembuf.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/arch/arm64/include/generated/uapi/asm/sembuf.h	2024-01-03 15:02:55.539845000 +0800
@@ -0,0 +1 @@
+#include <asm-generic/sembuf.h>
diff -Nuar -r --no-dereference linux-5.15.139/arch/arm64/include/generated/uapi/asm/termios.h linux/arch/arm64/include/generated/uapi/asm/termios.h
--- linux-5.15.139/arch/arm64/include/generated/uapi/asm/termios.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/arch/arm64/include/generated/uapi/asm/termios.h	2024-01-03 15:02:55.543845000 +0800
@@ -0,0 +1 @@
+#include <asm-generic/termios.h>
diff -Nuar -r --no-dereference linux-5.15.139/arch/arm64/include/generated/uapi/asm/ipcbuf.h linux/arch/arm64/include/generated/uapi/asm/ipcbuf.h
--- linux-5.15.139/arch/arm64/include/generated/uapi/asm/ipcbuf.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/arch/arm64/include/generated/uapi/asm/ipcbuf.h	2024-01-03 15:02:55.539845000 +0800
@@ -0,0 +1 @@
+#include <asm-generic/ipcbuf.h>
diff -Nuar -r --no-dereference linux-5.15.139/arch/arm64/include/generated/uapi/asm/msgbuf.h linux/arch/arm64/include/generated/uapi/asm/msgbuf.h
--- linux-5.15.139/arch/arm64/include/generated/uapi/asm/msgbuf.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/arch/arm64/include/generated/uapi/asm/msgbuf.h	2024-01-03 15:02:55.539845000 +0800
@@ -0,0 +1 @@
+#include <asm-generic/msgbuf.h>
diff -Nuar -r --no-dereference linux-5.15.139/arch/arm64/include/generated/uapi/asm/types.h linux/arch/arm64/include/generated/uapi/asm/types.h
--- linux-5.15.139/arch/arm64/include/generated/uapi/asm/types.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/arch/arm64/include/generated/uapi/asm/types.h	2024-01-03 15:02:55.543845000 +0800
@@ -0,0 +1 @@
+#include <asm-generic/types.h>
diff -Nuar -r --no-dereference linux-5.15.139/arch/arm64/include/generated/uapi/asm/shmbuf.h linux/arch/arm64/include/generated/uapi/asm/shmbuf.h
--- linux-5.15.139/arch/arm64/include/generated/uapi/asm/shmbuf.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/arch/arm64/include/generated/uapi/asm/shmbuf.h	2024-01-03 15:02:55.543845000 +0800
@@ -0,0 +1 @@
+#include <asm-generic/shmbuf.h>
diff -Nuar -r --no-dereference linux-5.15.139/arch/arm64/include/generated/uapi/asm/resource.h linux/arch/arm64/include/generated/uapi/asm/resource.h
--- linux-5.15.139/arch/arm64/include/generated/uapi/asm/resource.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/arch/arm64/include/generated/uapi/asm/resource.h	2024-01-03 15:02:55.539845000 +0800
@@ -0,0 +1 @@
+#include <asm-generic/resource.h>
diff -Nuar -r --no-dereference linux-5.15.139/arch/arm64/include/generated/uapi/asm/swab.h linux/arch/arm64/include/generated/uapi/asm/swab.h
--- linux-5.15.139/arch/arm64/include/generated/uapi/asm/swab.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/arch/arm64/include/generated/uapi/asm/swab.h	2024-01-03 15:02:55.543845000 +0800
@@ -0,0 +1 @@
+#include <asm-generic/swab.h>
diff -Nuar -r --no-dereference linux-5.15.139/arch/arm64/include/generated/uapi/asm/ioctls.h linux/arch/arm64/include/generated/uapi/asm/ioctls.h
--- linux-5.15.139/arch/arm64/include/generated/uapi/asm/ioctls.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/arch/arm64/include/generated/uapi/asm/ioctls.h	2024-01-03 15:02:55.539845000 +0800
@@ -0,0 +1 @@
+#include <asm-generic/ioctls.h>
diff -Nuar -r --no-dereference linux-5.15.139/arch/arm64/include/generated/uapi/asm/errno.h linux/arch/arm64/include/generated/uapi/asm/errno.h
--- linux-5.15.139/arch/arm64/include/generated/uapi/asm/errno.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/arch/arm64/include/generated/uapi/asm/errno.h	2024-01-03 15:02:55.539845000 +0800
@@ -0,0 +1 @@
+#include <asm-generic/errno.h>
diff -Nuar -r --no-dereference linux-5.15.139/arch/arm64/include/generated/uapi/asm/termbits.h linux/arch/arm64/include/generated/uapi/asm/termbits.h
--- linux-5.15.139/arch/arm64/include/generated/uapi/asm/termbits.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/arch/arm64/include/generated/uapi/asm/termbits.h	2024-01-03 15:02:55.543845000 +0800
@@ -0,0 +1 @@
+#include <asm-generic/termbits.h>
diff -Nuar -r --no-dereference linux-5.15.139/arch/arm64/include/generated/uapi/asm/siginfo.h linux/arch/arm64/include/generated/uapi/asm/siginfo.h
--- linux-5.15.139/arch/arm64/include/generated/uapi/asm/siginfo.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/arch/arm64/include/generated/uapi/asm/siginfo.h	2024-01-03 15:02:55.543845000 +0800
@@ -0,0 +1 @@
+#include <asm-generic/siginfo.h>
diff -Nuar -r --no-dereference linux-5.15.139/arch/arm64/include/generated/uapi/asm/sockios.h linux/arch/arm64/include/generated/uapi/asm/sockios.h
--- linux-5.15.139/arch/arm64/include/generated/uapi/asm/sockios.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/arch/arm64/include/generated/uapi/asm/sockios.h	2024-01-03 15:02:55.543845000 +0800
@@ -0,0 +1 @@
+#include <asm-generic/sockios.h>
diff -Nuar -r --no-dereference linux-5.15.139/arch/arm64/include/generated/uapi/asm/socket.h linux/arch/arm64/include/generated/uapi/asm/socket.h
--- linux-5.15.139/arch/arm64/include/generated/uapi/asm/socket.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/arch/arm64/include/generated/uapi/asm/socket.h	2024-01-03 15:02:55.543845000 +0800
@@ -0,0 +1 @@
+#include <asm-generic/socket.h>
diff -Nuar -r --no-dereference linux-5.15.139/arch/arm64/include/generated/uapi/asm/stat.h linux/arch/arm64/include/generated/uapi/asm/stat.h
--- linux-5.15.139/arch/arm64/include/generated/uapi/asm/stat.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/arch/arm64/include/generated/uapi/asm/stat.h	2024-01-03 15:02:55.543845000 +0800
@@ -0,0 +1 @@
+#include <asm-generic/stat.h>
diff -Nuar -r --no-dereference linux-5.15.139/arch/arm64/include/generated/uapi/asm/poll.h linux/arch/arm64/include/generated/uapi/asm/poll.h
--- linux-5.15.139/arch/arm64/include/generated/uapi/asm/poll.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/arch/arm64/include/generated/uapi/asm/poll.h	2024-01-03 15:02:55.539845000 +0800
@@ -0,0 +1 @@
+#include <asm-generic/poll.h>
diff -Nuar -r --no-dereference linux-5.15.139/arch/arm64/include/generated/uapi/asm/ioctl.h linux/arch/arm64/include/generated/uapi/asm/ioctl.h
--- linux-5.15.139/arch/arm64/include/generated/uapi/asm/ioctl.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/arch/arm64/include/generated/uapi/asm/ioctl.h	2024-01-03 15:02:55.539845000 +0800
@@ -0,0 +1 @@
+#include <asm-generic/ioctl.h>
diff -Nuar -r --no-dereference linux-5.15.139/arch/arm64/include/generated/uapi/asm/kvm_para.h linux/arch/arm64/include/generated/uapi/asm/kvm_para.h
--- linux-5.15.139/arch/arm64/include/generated/uapi/asm/kvm_para.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/arch/arm64/include/generated/uapi/asm/kvm_para.h	2024-01-03 15:02:55.539845000 +0800
@@ -0,0 +1 @@
+#include <asm-generic/kvm_para.h>
diff -Nuar -r --no-dereference linux-5.15.139/arch/arm64/include/generated/asm/msi.h linux/arch/arm64/include/generated/asm/msi.h
--- linux-5.15.139/arch/arm64/include/generated/asm/msi.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/arch/arm64/include/generated/asm/msi.h	2024-01-03 15:02:55.663847000 +0800
@@ -0,0 +1 @@
+#include <asm-generic/msi.h>
diff -Nuar -r --no-dereference linux-5.15.139/arch/arm64/include/generated/asm/cpucaps.h linux/arch/arm64/include/generated/asm/cpucaps.h
--- linux-5.15.139/arch/arm64/include/generated/asm/cpucaps.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/arch/arm64/include/generated/asm/cpucaps.h	2024-01-03 15:02:56.231860000 +0800
@@ -0,0 +1,75 @@
+#ifndef __ASM_CPUCAPS_H
+#define __ASM_CPUCAPS_H
+
+/* Generated file - do not edit */
+
+#define ARM64_BTI                           	0
+#define ARM64_HAS_32BIT_EL0_DO_NOT_USE      	1
+#define ARM64_HAS_32BIT_EL1                 	2
+#define ARM64_HAS_ADDRESS_AUTH              	3
+#define ARM64_HAS_ADDRESS_AUTH_ARCH         	4
+#define ARM64_HAS_ADDRESS_AUTH_IMP_DEF      	5
+#define ARM64_HAS_AMU_EXTN                  	6
+#define ARM64_HAS_ARMv8_4_TTL               	7
+#define ARM64_HAS_CACHE_DIC                 	8
+#define ARM64_HAS_CACHE_IDC                 	9
+#define ARM64_HAS_CNP                       	10
+#define ARM64_HAS_CRC32                     	11
+#define ARM64_HAS_DCPODP                    	12
+#define ARM64_HAS_DCPOP                     	13
+#define ARM64_HAS_E0PD                      	14
+#define ARM64_HAS_EPAN                      	15
+#define ARM64_HAS_GENERIC_AUTH              	16
+#define ARM64_HAS_GENERIC_AUTH_ARCH         	17
+#define ARM64_HAS_GENERIC_AUTH_IMP_DEF      	18
+#define ARM64_HAS_IRQ_PRIO_MASKING          	19
+#define ARM64_HAS_LDAPR                     	20
+#define ARM64_HAS_LSE_ATOMICS               	21
+#define ARM64_HAS_NO_FPSIMD                 	22
+#define ARM64_HAS_NO_HW_PREFETCH            	23
+#define ARM64_HAS_PAN                       	24
+#define ARM64_HAS_RAS_EXTN                  	25
+#define ARM64_HAS_RNG                       	26
+#define ARM64_HAS_SB                        	27
+#define ARM64_HAS_STAGE2_FWB                	28
+#define ARM64_HAS_SYSREG_GIC_CPUIF          	29
+#define ARM64_HAS_TLB_RANGE                 	30
+#define ARM64_HAS_VIRT_HOST_EXTN            	31
+#define ARM64_HW_DBM                        	32
+#define ARM64_KVM_PROTECTED_MODE            	33
+#define ARM64_MISMATCHED_CACHE_TYPE         	34
+#define ARM64_MTE                           	35
+#define ARM64_SPECTRE_V2                    	36
+#define ARM64_SPECTRE_V3A                   	37
+#define ARM64_SPECTRE_V4                    	38
+#define ARM64_SPECTRE_BHB                   	39
+#define ARM64_SSBS                          	40
+#define ARM64_SVE                           	41
+#define ARM64_UNMAP_KERNEL_AT_EL0           	42
+#define ARM64_WORKAROUND_834220             	43
+#define ARM64_WORKAROUND_843419             	44
+#define ARM64_WORKAROUND_845719             	45
+#define ARM64_WORKAROUND_858921             	46
+#define ARM64_WORKAROUND_1418040            	47
+#define ARM64_WORKAROUND_1463225            	48
+#define ARM64_WORKAROUND_1508412            	49
+#define ARM64_WORKAROUND_1542419            	50
+#define ARM64_WORKAROUND_1742098            	51
+#define ARM64_WORKAROUND_2457168            	52
+#define ARM64_WORKAROUND_TRBE_OVERWRITE_FILL_MODE	53
+#define ARM64_WORKAROUND_TSB_FLUSH_FAILURE  	54
+#define ARM64_WORKAROUND_TRBE_WRITE_OUT_OF_RANGE	55
+#define ARM64_WORKAROUND_CAVIUM_23154       	56
+#define ARM64_WORKAROUND_CAVIUM_27456       	57
+#define ARM64_WORKAROUND_CAVIUM_30115       	58
+#define ARM64_WORKAROUND_CAVIUM_TX2_219_PRFM	59
+#define ARM64_WORKAROUND_CAVIUM_TX2_219_TVM 	60
+#define ARM64_WORKAROUND_CLEAN_CACHE        	61
+#define ARM64_WORKAROUND_DEVICE_LOAD_ACQUIRE	62
+#define ARM64_WORKAROUND_NVIDIA_CARMEL_CNP  	63
+#define ARM64_WORKAROUND_QCOM_FALKOR_E1003  	64
+#define ARM64_WORKAROUND_REPEAT_TLBI        	65
+#define ARM64_WORKAROUND_SPECULATIVE_AT     	66
+#define ARM64_NCAPS				67
+
+#endif /* __ASM_CPUCAPS_H */
diff -Nuar -r --no-dereference linux-5.15.139/arch/arm64/include/generated/asm/qspinlock.h linux/arch/arm64/include/generated/asm/qspinlock.h
--- linux-5.15.139/arch/arm64/include/generated/asm/qspinlock.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/arch/arm64/include/generated/asm/qspinlock.h	2024-01-03 15:02:55.619846000 +0800
@@ -0,0 +1 @@
+#include <asm-generic/qspinlock.h>
diff -Nuar -r --no-dereference linux-5.15.139/arch/arm64/include/generated/asm/div64.h linux/arch/arm64/include/generated/asm/div64.h
--- linux-5.15.139/arch/arm64/include/generated/asm/div64.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/arch/arm64/include/generated/asm/div64.h	2024-01-03 15:02:55.655847000 +0800
@@ -0,0 +1 @@
+#include <asm-generic/div64.h>
diff -Nuar -r --no-dereference linux-5.15.139/arch/arm64/include/generated/asm/early_ioremap.h linux/arch/arm64/include/generated/asm/early_ioremap.h
--- linux-5.15.139/arch/arm64/include/generated/asm/early_ioremap.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/arch/arm64/include/generated/asm/early_ioremap.h	2024-01-03 15:02:55.603846000 +0800
@@ -0,0 +1 @@
+#include <asm-generic/early_ioremap.h>
diff -Nuar -r --no-dereference linux-5.15.139/arch/arm64/include/generated/asm/mmiowb.h linux/arch/arm64/include/generated/asm/mmiowb.h
--- linux-5.15.139/arch/arm64/include/generated/asm/mmiowb.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/arch/arm64/include/generated/asm/mmiowb.h	2024-01-03 15:02:55.663847000 +0800
@@ -0,0 +1 @@
+#include <asm-generic/mmiowb.h>
diff -Nuar -r --no-dereference linux-5.15.139/arch/arm64/include/generated/asm/hw_irq.h linux/arch/arm64/include/generated/asm/hw_irq.h
--- linux-5.15.139/arch/arm64/include/generated/asm/hw_irq.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/arch/arm64/include/generated/asm/hw_irq.h	2024-01-03 15:02:55.659847000 +0800
@@ -0,0 +1 @@
+#include <asm-generic/hw_irq.h>
diff -Nuar -r --no-dereference linux-5.15.139/arch/arm64/include/generated/asm/dma.h linux/arch/arm64/include/generated/asm/dma.h
--- linux-5.15.139/arch/arm64/include/generated/asm/dma.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/arch/arm64/include/generated/asm/dma.h	2024-01-03 15:02:55.655847000 +0800
@@ -0,0 +1 @@
+#include <asm-generic/dma.h>
diff -Nuar -r --no-dereference linux-5.15.139/arch/arm64/include/generated/asm/trace_clock.h linux/arch/arm64/include/generated/asm/trace_clock.h
--- linux-5.15.139/arch/arm64/include/generated/asm/trace_clock.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/arch/arm64/include/generated/asm/trace_clock.h	2024-01-03 15:02:55.663847000 +0800
@@ -0,0 +1 @@
+#include <asm-generic/trace_clock.h>
diff -Nuar -r --no-dereference linux-5.15.139/arch/arm64/include/generated/asm/delay.h linux/arch/arm64/include/generated/asm/delay.h
--- linux-5.15.139/arch/arm64/include/generated/asm/delay.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/arch/arm64/include/generated/asm/delay.h	2024-01-03 15:02:55.651847000 +0800
@@ -0,0 +1 @@
+#include <asm-generic/delay.h>
diff -Nuar -r --no-dereference linux-5.15.139/arch/arm64/include/generated/asm/user.h linux/arch/arm64/include/generated/asm/user.h
--- linux-5.15.139/arch/arm64/include/generated/asm/user.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/arch/arm64/include/generated/asm/user.h	2024-01-03 15:02:55.643847000 +0800
@@ -0,0 +1 @@
+#include <asm-generic/user.h>
diff -Nuar -r --no-dereference linux-5.15.139/arch/arm64/include/generated/asm/irq_regs.h linux/arch/arm64/include/generated/asm/irq_regs.h
--- linux-5.15.139/arch/arm64/include/generated/asm/irq_regs.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/arch/arm64/include/generated/asm/irq_regs.h	2024-01-03 15:02:55.659847000 +0800
@@ -0,0 +1 @@
+#include <asm-generic/irq_regs.h>
diff -Nuar -r --no-dereference linux-5.15.139/arch/arm64/include/generated/asm/emergency-restart.h linux/arch/arm64/include/generated/asm/emergency-restart.h
--- linux-5.15.139/arch/arm64/include/generated/asm/emergency-restart.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/arch/arm64/include/generated/asm/emergency-restart.h	2024-01-03 15:02:55.659847000 +0800
@@ -0,0 +1 @@
+#include <asm-generic/emergency-restart.h>
diff -Nuar -r --no-dereference linux-5.15.139/arch/arm64/include/generated/asm/dma-mapping.h linux/arch/arm64/include/generated/asm/dma-mapping.h
--- linux-5.15.139/arch/arm64/include/generated/asm/dma-mapping.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/arch/arm64/include/generated/asm/dma-mapping.h	2024-01-03 15:02:55.655847000 +0800
@@ -0,0 +1 @@
+#include <asm-generic/dma-mapping.h>
diff -Nuar -r --no-dereference linux-5.15.139/arch/arm64/include/generated/asm/qrwlock.h linux/arch/arm64/include/generated/asm/qrwlock.h
--- linux-5.15.139/arch/arm64/include/generated/asm/qrwlock.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/arch/arm64/include/generated/asm/qrwlock.h	2024-01-03 15:02:55.611846000 +0800
@@ -0,0 +1 @@
+#include <asm-generic/qrwlock.h>
diff -Nuar -r --no-dereference linux-5.15.139/arch/arm64/include/generated/asm/unaligned.h linux/arch/arm64/include/generated/asm/unaligned.h
--- linux-5.15.139/arch/arm64/include/generated/asm/unaligned.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/arch/arm64/include/generated/asm/unaligned.h	2024-01-03 15:02:55.663847000 +0800
@@ -0,0 +1 @@
+#include <asm-generic/unaligned.h>
diff -Nuar -r --no-dereference linux-5.15.139/arch/arm64/include/generated/asm/switch_to.h linux/arch/arm64/include/generated/asm/switch_to.h
--- linux-5.15.139/arch/arm64/include/generated/asm/switch_to.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/arch/arm64/include/generated/asm/switch_to.h	2024-01-03 15:02:55.663847000 +0800
@@ -0,0 +1 @@
+#include <asm-generic/switch_to.h>
diff -Nuar -r --no-dereference linux-5.15.139/arch/arm64/include/generated/asm/kdebug.h linux/arch/arm64/include/generated/asm/kdebug.h
--- linux-5.15.139/arch/arm64/include/generated/asm/kdebug.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/arch/arm64/include/generated/asm/kdebug.h	2024-01-03 15:02:55.659847000 +0800
@@ -0,0 +1 @@
+#include <asm-generic/kdebug.h>
diff -Nuar -r --no-dereference linux-5.15.139/arch/arm64/include/generated/asm/kmap_size.h linux/arch/arm64/include/generated/asm/kmap_size.h
--- linux-5.15.139/arch/arm64/include/generated/asm/kmap_size.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/arch/arm64/include/generated/asm/kmap_size.h	2024-01-03 15:02:55.663847000 +0800
@@ -0,0 +1 @@
+#include <asm-generic/kmap_size.h>
diff -Nuar -r --no-dereference linux-5.15.139/arch/arm64/include/generated/asm/local.h linux/arch/arm64/include/generated/asm/local.h
--- linux-5.15.139/arch/arm64/include/generated/asm/local.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/arch/arm64/include/generated/asm/local.h	2024-01-03 15:02:55.663847000 +0800
@@ -0,0 +1 @@
+#include <asm-generic/local.h>
diff -Nuar -r --no-dereference linux-5.15.139/arch/arm64/include/generated/asm/local64.h linux/arch/arm64/include/generated/asm/local64.h
--- linux-5.15.139/arch/arm64/include/generated/asm/local64.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/arch/arm64/include/generated/asm/local64.h	2024-01-03 15:02:55.663847000 +0800
@@ -0,0 +1 @@
+#include <asm-generic/local64.h>
diff -Nuar -r --no-dereference linux-5.15.139/arch/arm64/include/generated/asm/bugs.h linux/arch/arm64/include/generated/asm/bugs.h
--- linux-5.15.139/arch/arm64/include/generated/asm/bugs.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/arch/arm64/include/generated/asm/bugs.h	2024-01-03 15:02:55.651847000 +0800
@@ -0,0 +1 @@
+#include <asm-generic/bugs.h>
diff -Nuar -r --no-dereference linux-5.15.139/arch/arm64/include/generated/asm/mcs_spinlock.h linux/arch/arm64/include/generated/asm/mcs_spinlock.h
--- linux-5.15.139/arch/arm64/include/generated/asm/mcs_spinlock.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/arch/arm64/include/generated/asm/mcs_spinlock.h	2024-01-03 15:02:55.611846000 +0800
@@ -0,0 +1 @@
+#include <asm-generic/mcs_spinlock.h>
diff -Nuar -r --no-dereference linux-5.15.139/arch/arm64/include/generated/asm/serial.h linux/arch/arm64/include/generated/asm/serial.h
--- linux-5.15.139/arch/arm64/include/generated/asm/serial.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/arch/arm64/include/generated/asm/serial.h	2024-01-03 15:02:55.663847000 +0800
@@ -0,0 +1 @@
+#include <asm-generic/serial.h>
diff -Nuar -r --no-dereference linux-5.15.139/arch/arm64/include/generated/asm/softirq_stack.h linux/arch/arm64/include/generated/asm/softirq_stack.h
--- linux-5.15.139/arch/arm64/include/generated/asm/softirq_stack.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/arch/arm64/include/generated/asm/softirq_stack.h	2024-01-03 15:02:55.663847000 +0800
@@ -0,0 +1 @@
+#include <asm-generic/softirq_stack.h>
diff -Nuar -r --no-dereference linux-5.15.139/arch/arm64/include/generated/asm/vga.h linux/arch/arm64/include/generated/asm/vga.h
--- linux-5.15.139/arch/arm64/include/generated/asm/vga.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/arch/arm64/include/generated/asm/vga.h	2024-01-03 15:02:55.663847000 +0800
@@ -0,0 +1 @@
+#include <asm-generic/vga.h>
diff -Nuar -r --no-dereference linux-5.15.139/drivers/spi/spidev.c linux/drivers/spi/spidev.c
--- linux-5.15.139/drivers/spi/spidev.c	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/spi/spidev.c	2024-01-03 16:06:25.935131000 +0800
@@ -22,8 +22,7 @@
 #include <linux/of_device.h>
 #include <linux/acpi.h>
 
-#include <linux/spi/spi.h>
-#include <linux/spi/spidev.h>
+#include <uapi/linux/spi/spidev.h>
 
 #include <linux/uaccess.h>
 
@@ -683,6 +682,7 @@
 static struct class *spidev_class;
 
 static const struct spi_device_id spidev_spi_ids[] = {
+	{ .name = "spi-dev" },
 	{ .name = "dh2228fv" },
 	{ .name = "ltc2488" },
 	{ .name = "sx1301" },
@@ -697,6 +697,7 @@
 
 #ifdef CONFIG_OF
 static const struct of_device_id spidev_dt_ids[] = {
+	{ .compatible = "armbian,spi-dev" },
 	{ .compatible = "rohm,dh2228fv" },
 	{ .compatible = "lineartechnology,ltc2488" },
 	{ .compatible = "semtech,sx1301" },
@@ -759,10 +760,13 @@
 	 * spidev should never be referenced in DT without a specific
 	 * compatible string, it is a Linux implementation thing
 	 * rather than a description of the hardware.
+	 * But people don't care and use DT overlays to activate SPIdev
+	 * on demand. Armbian has added a compatible string alias "spi-dev"
+	 * for this module.
 	 */
 	WARN(spi->dev.of_node &&
 	     of_device_is_compatible(spi->dev.of_node, "spidev"),
-	     "%pOF: buggy DT: spidev listed directly in DT\n", spi->dev.of_node);
+	     "%pOF: buggy DT: spidev listed directly in DT\n\tUse an alias like spi-dev in DT\n", spi->dev.of_node);
 
 	spidev_probe_acpi(spi);
 
diff -Nuar -r --no-dereference linux-5.15.139/drivers/spi/spi.c linux/drivers/spi/spi.c
--- linux-5.15.139/drivers/spi/spi.c	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/spi/spi.c	2024-01-03 16:06:25.935131000 +0800
@@ -3482,6 +3482,7 @@
 {
 	unsigned	bad_bits, ugly_bits;
 	int		status;
+	int		ret;
 
 	/*
 	 * check mode to prevent that any two of DUAL, QUAD and NO_MOSI/MISO
@@ -3554,6 +3555,19 @@
 		}
 	}
 
+	if (gpio_is_valid(spi->cs_gpio)) {
+		dev_info(&spi->dev, "spi_setup / gpio_is_valid(%d) ... doing gpio_request ...\n", spi->cs_gpio);
+		ret = gpio_request(spi->cs_gpio, dev_name(&spi->dev));
+		if (ret) {
+			dev_err(&spi->dev, "failed to request gpio\n");
+		}
+		else {
+			gpio_direction_output(spi->cs_gpio,
+				 !(spi->mode & SPI_CS_HIGH));
+			dev_info(&spi->dev, "spi_setup / gpio_direction_output(%d) done !\n", spi->cs_gpio);
+		}
+	}
+
 	if (spi->controller->auto_runtime_pm && spi->controller->set_cs) {
 		status = pm_runtime_get_sync(spi->controller->dev.parent);
 		if (status < 0) {
diff -Nuar -r --no-dereference linux-5.15.139/drivers/spi/spi-sun4i.c linux/drivers/spi/spi-sun4i.c
--- linux-5.15.139/drivers/spi/spi-sun4i.c	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/spi/spi-sun4i.c	2024-01-03 16:06:25.935131000 +0800
@@ -389,6 +389,7 @@
 	struct spi_master *master = dev_get_drvdata(dev);
 	struct sun4i_spi *sspi = spi_master_get_devdata(master);
 	int ret;
+	u32 reg;
 
 	ret = clk_prepare_enable(sspi->hclk);
 	if (ret) {
@@ -401,9 +402,10 @@
 		dev_err(dev, "Couldn't enable module clock\n");
 		goto err;
 	}
+	reg = sun4i_spi_read(sspi, SUN4I_CTL_REG);
 
 	sun4i_spi_write(sspi, SUN4I_CTL_REG,
-			SUN4I_CTL_ENABLE | SUN4I_CTL_MASTER | SUN4I_CTL_TP);
+			reg | SUN4I_CTL_ENABLE | SUN4I_CTL_MASTER | SUN4I_CTL_TP);
 
 	return 0;
 
diff -Nuar -r --no-dereference linux-5.15.139/drivers/nvmem/sunxi_sid.c linux/drivers/nvmem/sunxi_sid.c
--- linux-5.15.139/drivers/nvmem/sunxi_sid.c	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/nvmem/sunxi_sid.c	2024-01-03 16:06:25.935131000 +0800
@@ -37,6 +37,25 @@
 	u32			value_offset;
 };
 
+static unsigned int sunxi_soc_chipid[4];
+static unsigned int sunxi_serial[4];
+
+int sunxi_get_soc_chipid(unsigned char *chipid)
+{
+	memcpy(chipid, sunxi_soc_chipid, 16);
+
+	return 0;
+}
+EXPORT_SYMBOL(sunxi_get_soc_chipid);
+
+int sunxi_get_serial(unsigned       char *serial)
+{
+	memcpy(serial, sunxi_serial, 16);
+
+	return 0;
+}
+EXPORT_SYMBOL(sunxi_get_serial);
+
 static int sunxi_sid_read(void *context, unsigned int offset,
 			  void *val, size_t bytes)
 {
@@ -167,6 +186,15 @@
 
 	platform_set_drvdata(pdev, nvmem);
 
+	nvmem_cfg->reg_read(sid, 0, &sunxi_soc_chipid[0], sizeof(int));
+	nvmem_cfg->reg_read(sid, 4, &sunxi_soc_chipid[1], sizeof(int));
+	nvmem_cfg->reg_read(sid, 8, &sunxi_soc_chipid[2], sizeof(int));
+	nvmem_cfg->reg_read(sid, 12, &sunxi_soc_chipid[3], sizeof(int));
+
+	sunxi_serial[0] = sunxi_soc_chipid[3];
+	sunxi_serial[1] = sunxi_soc_chipid[2];
+	sunxi_serial[2] = (sunxi_soc_chipid[1] >> 16) & 0x0ffff;
+
 	return 0;
 }
 
@@ -195,6 +223,12 @@
 	.size = 0x200,
 };
 
+static const struct sunxi_sid_cfg sun50i_h616_cfg = {
+	.value_offset = 0x200,
+	.size = 0x100,
+	.need_register_readout = true,
+};
+
 static const struct of_device_id sunxi_sid_of_match[] = {
 	{ .compatible = "allwinner,sun4i-a10-sid", .data = &sun4i_a10_cfg },
 	{ .compatible = "allwinner,sun7i-a20-sid", .data = &sun7i_a20_cfg },
@@ -203,6 +237,7 @@
 	{ .compatible = "allwinner,sun50i-a64-sid", .data = &sun50i_a64_cfg },
 	{ .compatible = "allwinner,sun50i-h5-sid", .data = &sun50i_a64_cfg },
 	{ .compatible = "allwinner,sun50i-h6-sid", .data = &sun50i_h6_cfg },
+	{ .compatible = "allwinner,sun50i-h616-sid", .data = &sun50i_h616_cfg },
 	{/* sentinel */},
 };
 MODULE_DEVICE_TABLE(of, sunxi_sid_of_match);
diff -Nuar -r --no-dereference linux-5.15.139/drivers/usb/typec/Makefile linux/drivers/usb/typec/Makefile
--- linux-5.15.139/drivers/usb/typec/Makefile	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/usb/typec/Makefile	2024-01-03 16:06:25.935131000 +0800
@@ -5,6 +5,7 @@
 obj-$(CONFIG_TYPEC_TCPM)	+= tcpm/
 obj-$(CONFIG_TYPEC_UCSI)	+= ucsi/
 obj-$(CONFIG_TYPEC_TPS6598X)	+= tipd/
+obj-$(CONFIG_TYPEC_ANX7688)	+= anx7688.o
 obj-$(CONFIG_TYPEC_HD3SS3220)	+= hd3ss3220.o
 obj-$(CONFIG_TYPEC_QCOM_PMIC)	+= qcom-pmic-typec.o
 obj-$(CONFIG_TYPEC_STUSB160X) 	+= stusb160x.o
diff -Nuar -r --no-dereference linux-5.15.139/drivers/usb/typec/anx7688.c linux/drivers/usb/typec/anx7688.c
--- linux-5.15.139/drivers/usb/typec/anx7688.c	1970-01-01 08:00:00.000000000 +0800
+++ linux/drivers/usb/typec/anx7688.c	2024-01-03 16:06:25.935131000 +0800
@@ -0,0 +1,2233 @@
+/*
+ * ANX7688 USB-C HDMI bridge/PD driver
+ *
+ * Warning, this driver is somewhat PinePhone specific.
+ *
+ * How this works:
+ * - this driver allows to program firmware into ANX7688 EEPROM, and
+ *   initialize it
+ * - it then communicates with the firmware running on the OCM (on-chip
+ *   microcontroller)
+ * - it detects whether there is cable plugged in or not and powers
+ *   up or down the ANX7688 based on that
+ * - when the cable is connected the firmware on the OCM will handle
+ *   the detection of the nature of the device on the other end
+ *   of the USB-C cable
+ * - this driver then communicates with the USB phy to let it swap
+ *   data roles accordingly
+ * - it also enables VBUS and VCONN regulators as appropriate
+ * - USB phy driver (Allwinner) needs to know whether to switch to
+ *   device or host mode, or whether to turn off
+ * - when the firmware detects SRC.1.5A or SRC.3.0A via CC pins
+ *   or something else via PD, it notifies this driver via software
+ *   interrupt and this driver will determine how to update the TypeC
+ *   port status and what input current limit is appropriate
+ * - input current limit determination happens 500ms after cable
+ *   insertion or hard reset (delay is necessary to determine whether
+ *   the remote end is PD capable or not)
+ * - this driver tells to the PMIC driver that the input current limit
+ *   needs to be changed
+ * - this driver also monitors PMIC status and re-sets the input current
+ *   limit if it changes for some reason (due to PMIC internal decision
+ *   making) (this is disabled for now)
+ *
+ * ANX7688 FW behavior as observed:
+ *
+ * - DO NOT SET MORE THAN 1 SINK CAPABILITY! Firmware will ignore what
+ *   you set and send hardcoded PDO_BATT 5-21V 30W message!
+ */
+
+#define DEBUG
+
+#include <linux/debugfs.h>
+#include <linux/delay.h>
+#include <linux/extcon-provider.h>
+#include <linux/firmware.h>
+#include <linux/gpio/consumer.h>
+#include <linux/i2c.h>
+#include <linux/interrupt.h>
+#include <linux/irqreturn.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_irq.h>
+#include <linux/power_supply.h>
+#include <linux/regulator/consumer.h>
+#include <linux/usb/pd.h>
+#include <linux/usb/role.h>
+#include <linux/usb/typec.h>
+
+#define DISABLE_OCM 0
+
+/* firmware regs */
+
+#define ANX7688_REG_VBUS_OFF_DELAY_TIME 0x22
+#define ANX7688_REG_FEATURE_CTRL        0x27
+#define ANX7688_REG_EEPROM_LOAD_STATUS1 0x11
+#define ANX7688_REG_EEPROM_LOAD_STATUS0 0x12
+#define ANX7688_REG_FW_VERSION1         0x15
+#define ANX7688_REG_FW_VERSION0         0x16
+
+#define ANX7688_EEPROM_FW_LOADED	0x01
+
+#define ANX7688_REG_STATUS_INT_MASK     0x17
+#define ANX7688_REG_STATUS_INT          0x28
+#define ANX7688_IRQS_RECEIVED_MSG       BIT(0)
+#define ANX7688_IRQS_RECEIVED_ACK       BIT(1)
+#define ANX7688_IRQS_VCONN_CHANGE       BIT(2)
+#define ANX7688_IRQS_VBUS_CHANGE        BIT(3)
+#define ANX7688_IRQS_CC_STATUS_CHANGE   BIT(4)
+#define ANX7688_IRQS_DATA_ROLE_CHANGE   BIT(5)
+
+#define ANX7688_REG_STATUS              0x29
+#define ANX7688_VCONN_STATUS            BIT(2) /* 0 = off  1 = on */
+#define ANX7688_VBUS_STATUS             BIT(3) /* 0 = off  1 = on */
+#define ANX7688_DATA_ROLE_STATUS        BIT(5) /* 0 = device 1 = host */
+
+#define ANX7688_REG_CC_STATUS           0x2a
+#define ANX7688_REG_TRY_UFP_TIMER       0x23
+#define ANX7688_REG_TIME_CTRL           0x24
+
+#define ANX7688_REG_MAX_VOLTAGE         0x1b
+#define ANX7688_REG_MAX_POWER           0x1c
+#define ANX7688_REG_MIN_POWER           0x1d
+#define ANX7688_REG_MAX_VOLTAGE_STATUS  0x1e
+#define ANX7688_REG_MAX_POWER_STATUS    0x1f
+
+#define ANX7688_SOFT_INT_MASK           0x7f
+
+/* tcpc regs */
+
+#define ANX7688_TCPC_REG_VENDOR_ID0     0x00
+#define ANX7688_TCPC_REG_VENDOR_ID1     0x01
+#define ANX7688_TCPC_REG_ALERT0         0x10
+#define ANX7688_TCPC_REG_ALERT1         0x11
+#define ANX7688_TCPC_REG_ALERT_MASK0    0x12
+#define ANX7688_TCPC_REG_ALERT_MASK1    0x13
+#define ANX7688_TCPC_REG_INTERFACE_SEND 0x30
+#define ANX7688_TCPC_REG_INTERFACE_RECV 0x51
+
+/* hw regs */
+
+#define ANX7688_REG_IRQ_EXT_SOURCE0     0x3e
+#define ANX7688_REG_IRQ_EXT_SOURCE1     0x4e
+#define ANX7688_REG_IRQ_EXT_SOURCE2     0x4f
+#define ANX7688_REG_IRQ_EXT_MASK0       0x3b
+#define ANX7688_REG_IRQ_EXT_MASK1       0x3c
+#define ANX7688_REG_IRQ_EXT_MASK2       0x3d
+#define ANX7688_REG_IRQ_SOURCE0         0x54
+#define ANX7688_REG_IRQ_SOURCE1         0x55
+#define ANX7688_REG_IRQ_SOURCE2         0x56
+#define ANX7688_REG_IRQ_MASK0           0x57
+#define ANX7688_REG_IRQ_MASK1           0x58
+#define ANX7688_REG_IRQ_MASK2           0x59
+
+#define ANX7688_IRQ2_SOFT_INT           BIT(2)
+
+#define ANX7688_REG_USBC_RESET_CTRL		0x05
+#define ANX7688_USBC_RESET_CTRL_OCM_RESET	BIT(4)
+
+//#define ANX7688_IRQ2_USB_PLUGIN         BIT(4)
+//#define ANX7688_REG_IRQ_STATUS          0x53
+
+/* ocm messages */
+
+#define ANX7688_OCM_MSG_PWR_SRC_CAP     0x00
+#define ANX7688_OCM_MSG_PWR_SNK_CAP     0x01
+#define ANX7688_OCM_MSG_DP_SNK_IDENTITY 0x02
+#define ANX7688_OCM_MSG_SVID            0x03
+#define ANX7688_OCM_MSG_GET_DP_SNK_CAP  0x04
+#define ANX7688_OCM_MSG_ACCEPT          0x05
+#define ANX7688_OCM_MSG_REJECT          0x06
+#define ANX7688_OCM_MSG_PSWAP_REQ       0x10
+#define ANX7688_OCM_MSG_DSWAP_REQ       0x11
+#define ANX7688_OCM_MSG_GOTO_MIN_REQ    0x12
+#define ANX7688_OCM_MSG_VCONN_SWAP_REQ  0x13
+#define ANX7688_OCM_MSG_VDM             0x14
+#define ANX7688_OCM_MSG_DP_SNK_CFG      0x15
+#define ANX7688_OCM_MSG_PWR_OBJ_REQ     0x16
+#define ANX7688_OCM_MSG_PD_STATUS_REQ   0x17
+#define ANX7688_OCM_MSG_DP_ALT_ENTER    0x19
+#define ANX7688_OCM_MSG_DP_ALT_EXIT     0x1a
+#define ANX7688_OCM_MSG_GET_SNK_CAP     0x1b
+#define ANX7688_OCM_MSG_RESPONSE_TO_REQ 0xf0
+#define ANX7688_OCM_MSG_SOFT_RST        0xf1
+#define ANX7688_OCM_MSG_HARD_RST        0xf2
+#define ANX7688_OCM_MSG_RESTART         0xf3
+
+static const char * const anx7688_supply_names[] = {
+        "avdd33",
+        "avdd18",
+        "dvdd18",
+        "avdd10",
+        "dvdd10",
+        "i2c",
+        "hdmi_vt",
+
+        "vconn", // power for VCONN1/VCONN2 switches
+        "vbus", // vbus power
+};
+
+#define ANX7688_NUM_SUPPLIES ARRAY_SIZE(anx7688_supply_names)
+#define ANX7688_NUM_ALWAYS_ON_SUPPLIES (ANX7688_NUM_SUPPLIES - 1)
+
+#define ANX7688_I2C_INDEX (ANX7688_NUM_SUPPLIES - 4)
+#define ANX7688_VCONN_INDEX (ANX7688_NUM_SUPPLIES - 2)
+#define ANX7688_VBUS_INDEX (ANX7688_NUM_SUPPLIES - 1)
+
+enum {
+	ANX7688_F_POWERED,
+	ANX7688_F_CONNECTED,
+	ANX7688_F_FW_FAILED,
+	ANX7688_F_PWRSUPPLY_CHANGE,
+	ANX7688_F_CURRENT_UPDATE,
+};
+
+struct anx7688 {
+        struct device *dev;
+        struct i2c_client *client;
+        struct i2c_client *client_tcpc;
+        struct regulator_bulk_data supplies[ANX7688_NUM_SUPPLIES];
+	struct power_supply *vbus_in_supply;
+	struct notifier_block vbus_in_nb;
+	int input_current_limit; // mA
+        struct gpio_desc *gpio_enable;
+        struct gpio_desc *gpio_reset;
+        struct gpio_desc *gpio_cabledet;
+
+	uint32_t src_caps[8];
+	unsigned n_src_caps;
+
+	uint32_t snk_caps[8];
+	unsigned n_snk_caps;
+
+	unsigned long flags[1];
+
+        struct delayed_work work;
+	struct timer_list work_timer;
+
+        struct mutex lock;
+        bool vbus_on, vconn_on;
+	bool pd_capable;
+	int pd_current_limit; // mA
+	ktime_t current_update_deadline;
+
+        struct typec_port *port;
+        struct typec_partner *partner;
+        struct usb_pd_identity partner_identity;
+	struct usb_role_switch *role_sw;
+	int pwr_role, data_role;
+
+        struct dentry *debug_root;
+
+	/* for debug */
+	int last_status;
+	int last_cc_status;
+	int last_dp_state;
+	int last_bc_result;
+
+	/* for HDMI HPD */
+	struct extcon_dev *extcon;
+};
+
+static const unsigned int anx7688_extcon_cable[] = {
+	EXTCON_DISP_HDMI,
+	EXTCON_NONE,
+};
+
+static int anx7688_reg_read(struct anx7688 *anx7688, u8 reg_addr)
+{
+        int ret;
+
+        ret = i2c_smbus_read_byte_data(anx7688->client, reg_addr);
+        if (ret < 0)
+                dev_err(anx7688->dev, "i2c read failed at 0x%x (%d)\n",
+                        reg_addr, ret);
+
+        return ret;
+}
+
+static int anx7688_reg_write(struct anx7688 *anx7688, u8 reg_addr, u8 value)
+{
+        int ret;
+
+        ret = i2c_smbus_write_byte_data(anx7688->client, reg_addr, value);
+        if (ret < 0)
+                dev_err(anx7688->dev, "i2c write failed at 0x%x (%d)\n",
+                        reg_addr, ret);
+
+        return ret;
+}
+
+static int anx7688_reg_update_bits(struct anx7688 *anx7688, u8 reg_addr,
+                                   u8 mask, u8 value)
+{
+        int ret;
+
+        ret = anx7688_reg_read(anx7688, reg_addr);
+        if (ret < 0)
+                return ret;
+
+        ret &= ~mask;
+        ret |= value;
+
+        return anx7688_reg_write(anx7688, reg_addr, ret);
+}
+
+static int anx7688_tcpc_reg_read(struct anx7688 *anx7688, u8 reg_addr)
+{
+        int ret;
+
+        ret = i2c_smbus_read_byte_data(anx7688->client_tcpc, reg_addr);
+        if (ret < 0)
+                dev_err(anx7688->dev, "tcpc i2c read failed at 0x%x (%d)\n",
+                        reg_addr, ret);
+
+        return ret;
+}
+
+static int anx7688_tcpc_reg_write(struct anx7688 *anx7688, u8 reg_addr, u8 value)
+{
+        int ret;
+
+        ret = i2c_smbus_write_byte_data(anx7688->client_tcpc, reg_addr, value);
+        if (ret < 0)
+                dev_err(anx7688->dev, "tcpc i2c write failed at 0x%x (%d)\n",
+                        reg_addr, ret);
+
+        return ret;
+}
+
+static void anx7688_power_enable(struct anx7688 *anx7688)
+{
+        gpiod_set_value(anx7688->gpio_reset, 1);
+        gpiod_set_value(anx7688->gpio_enable, 1);
+
+        /* wait for power to stabilize and release reset */
+        msleep(10);
+        gpiod_set_value(anx7688->gpio_reset, 0);
+        udelay(2);
+
+        dev_dbg(anx7688->dev, "power enabled\n");
+
+	set_bit(ANX7688_F_POWERED, anx7688->flags);
+}
+
+static void anx7688_power_disable(struct anx7688 *anx7688)
+{
+        gpiod_set_value(anx7688->gpio_reset, 1);
+        msleep(5);
+        gpiod_set_value(anx7688->gpio_enable, 0);
+
+        dev_dbg(anx7688->dev, "power disabled\n");
+
+	clear_bit(ANX7688_F_POWERED, anx7688->flags);
+}
+
+static int anx7688_send_ocm_message(struct anx7688 *anx7688, int cmd,
+                                    const u8 *data, int data_len)
+{
+        int ret = 0, i;
+        u8 pkt[32];
+
+        if (data_len > sizeof(pkt) - 3) {
+                dev_dbg(anx7688->dev,
+                        "invalid ocm message length cmd=0x%02x len=%d\n",
+                        cmd, data_len);
+                return -EINVAL;
+        }
+
+        // prepare pd packet
+        pkt[0] = data_len + 1;
+        pkt[1] = cmd;
+	if (data_len > 0)
+		memcpy(pkt + 2, data, data_len);
+        pkt[2 + data_len] = 0;
+        for (i = 0; i < data_len + 2; i++)
+                pkt[data_len + 2] -= pkt[i];
+
+        dev_dbg(anx7688->dev, "send pd packet cmd=0x%02x %*ph\n",
+                cmd, data_len + 3, pkt);
+
+        ret = anx7688_tcpc_reg_read(anx7688, ANX7688_TCPC_REG_INTERFACE_SEND);
+        if (ret) {
+                dev_err(anx7688->dev,
+                        "failed to send pd packet (tx buffer full)\n");
+                return -EBUSY;
+        }
+
+        ret = i2c_smbus_write_i2c_block_data(anx7688->client_tcpc,
+                                             ANX7688_TCPC_REG_INTERFACE_SEND,
+                                             data_len + 3, pkt);
+        if (ret < 0)
+                dev_err(anx7688->dev,
+                        "failed to send pd packet (err=%d)\n", ret);
+
+        // wait until the message is processed (30ms max)
+        for (i = 0; i < 300; i++) {
+                ret = anx7688_tcpc_reg_read(anx7688, ANX7688_TCPC_REG_INTERFACE_SEND);
+                if (ret <= 0)
+                        return ret;
+
+                udelay(100);
+        }
+
+        dev_err(anx7688->dev, "timeout waiting for the message queue flush\n");
+        return -ETIMEDOUT;
+}
+
+static int anx7688_connect(struct anx7688 *anx7688)
+{
+#if DISABLE_OCM
+        int ret;
+
+        dev_dbg(anx7688->dev, "cable inserted\n");
+
+        msleep(10);
+        anx7688_power_enable(anx7688);
+
+	/* reset the OCM right away */
+        ret = anx7688_reg_update_bits(anx7688, ANX7688_REG_USBC_RESET_CTRL,
+                                      ANX7688_USBC_RESET_CTRL_OCM_RESET,
+                                      ANX7688_USBC_RESET_CTRL_OCM_RESET);
+	if (ret)
+		goto err_poweroff;
+
+	/* enable interrupts for VBUS, etc. */
+        ret = anx7688_reg_write(anx7688, ANX7688_REG_IRQ_EXT_SOURCE2, 0xff);
+	if (ret)
+		goto err_poweroff;
+
+        ret = anx7688_reg_write(anx7688, ANX7688_REG_IRQ_EXT_MASK2, ~(BIT(6) | BIT(5) | BIT(4)));
+	if (ret)
+		goto err_poweroff;
+
+	set_bit(ANX7688_F_CONNECTED, anx7688->flags);
+        return 0;
+
+err_poweroff:
+        anx7688_power_disable(anx7688);
+        return ret;
+#else
+	struct typec_partner_desc desc = {};
+        int ret, i;
+        u8 fw[2];
+	const u8 dp_snk_identity[16] = {
+		0x00, 0x00, 0x00, 0xec,	/* id header */
+		0x00, 0x00, 0x00, 0x00,	/* cert stat */
+		0x00, 0x00, 0x00, 0x00,	/* product type */
+		0x39, 0x00, 0x00, 0x51	/* alt mode adapter */
+	};
+	const u8 svid[4] = {
+		0x00, 0x00, 0x01, 0xff,
+	};
+        u32 caps[8];
+
+        dev_dbg(anx7688->dev, "cable inserted\n");
+
+	anx7688->last_status = -1;
+	anx7688->last_cc_status = -1;
+	anx7688->last_dp_state = -1;
+
+        msleep(10);
+        anx7688_power_enable(anx7688);
+
+        ret = regulator_enable(anx7688->supplies[ANX7688_VCONN_INDEX].consumer);
+        if (ret) {
+                dev_err(anx7688->dev, "failed to enable vconn\n");
+                goto err_poweroff;
+        }
+	anx7688->vconn_on = true;
+
+        /* wait till the firmware is loaded (typically ~30ms) */
+        for (i = 0; i < 100; i++) {
+                ret = anx7688_reg_read(anx7688, ANX7688_REG_EEPROM_LOAD_STATUS0);
+
+                if (ret >= 0 && (ret & ANX7688_EEPROM_FW_LOADED) == ANX7688_EEPROM_FW_LOADED) {
+                        dev_dbg(anx7688->dev, "eeprom0 = 0x%02x\n", ret);
+                        dev_info(anx7688->dev, "fw loaded after %d ms\n", i * 10);
+                        goto fw_loaded;
+                }
+
+                msleep(5);
+        }
+
+	set_bit(ANX7688_F_FW_FAILED, anx7688->flags);
+        dev_err(anx7688->dev, "boot firmware load failed (you may need to flash FW to anx7688 first)\n");
+        ret = -ETIMEDOUT;
+        goto err_vconoff;
+
+fw_loaded:
+        ret = i2c_smbus_read_i2c_block_data(anx7688->client,
+                                            ANX7688_REG_FW_VERSION1, 2, fw);
+        if (ret < 0) {
+                dev_err(anx7688->dev, "failed to read firmware version\n");
+                goto err_vconoff;
+        }
+
+        dev_info(anx7688->dev, "OCM firmware loaded (version 0x%04x)\n",
+                 fw[1] | fw[0] << 8);
+
+        /* Unmask interrupts */
+        ret = anx7688_reg_write(anx7688, ANX7688_REG_STATUS_INT, 0);
+	if (ret)
+		goto err_vconoff;
+
+        ret = anx7688_reg_write(anx7688, ANX7688_REG_STATUS_INT_MASK, ~ANX7688_SOFT_INT_MASK);
+	if (ret)
+		goto err_vconoff;
+
+        ret = anx7688_reg_write(anx7688, ANX7688_REG_IRQ_EXT_SOURCE2, 0xff);
+	if (ret)
+		goto err_vconoff;
+
+        ret = anx7688_reg_write(anx7688, ANX7688_REG_IRQ_EXT_MASK2, (u8)~ANX7688_IRQ2_SOFT_INT);
+	if (ret)
+		goto err_vconoff;
+
+        /* time to turn off vbus after cc disconnect (unit is 4 ms) */
+        ret = anx7688_reg_write(anx7688, ANX7688_REG_VBUS_OFF_DELAY_TIME, 100 / 4);
+	if (ret)
+		goto err_vconoff;
+
+        //anx7688_reg_write(anx7688, ANX7688_REG_TIME_CTRL, 0x00);
+
+        /* 300ms (unit is 2 ms) */
+        ret = anx7688_reg_write(anx7688, ANX7688_REG_TRY_UFP_TIMER, 300 / 2);
+	if (ret)
+		goto err_vconoff;
+
+        /* maximum voltage in 100 mV units */
+        ret = anx7688_reg_write(anx7688, ANX7688_REG_MAX_VOLTAGE, 50); /* 5 V */
+	if (ret)
+		goto err_vconoff;
+
+        /* min/max power in 500 mW units */
+        ret = anx7688_reg_write(anx7688, ANX7688_REG_MAX_POWER, 15 * 2); /* 15 W */
+	if (ret)
+		goto err_vconoff;
+
+        ret = anx7688_reg_write(anx7688, ANX7688_REG_MIN_POWER, 1);  /* 0.5 W */
+	if (ret)
+		goto err_vconoff;
+
+        /* auto_pd, try.src, try.sink, goto safe 5V */
+        ret = anx7688_reg_write(anx7688, ANX7688_REG_FEATURE_CTRL, 0x1e & ~BIT(2)); // disable try_src
+	if (ret)
+		goto err_vconoff;
+
+	for (i = 0; i < anx7688->n_src_caps; i++)
+		caps[i] = cpu_to_le32(anx7688->src_caps[i]);
+	ret = anx7688_send_ocm_message(anx7688, ANX7688_OCM_MSG_PWR_SRC_CAP,
+				       (u8*)&caps, 4 * anx7688->n_src_caps);
+	if (ret)
+		goto err_vconoff;
+
+	for (i = 0; i < anx7688->n_snk_caps; i++)
+		caps[i] = cpu_to_le32(anx7688->snk_caps[i]);
+	ret = anx7688_send_ocm_message(anx7688, ANX7688_OCM_MSG_PWR_SNK_CAP,
+				       (u8*)&caps, 4 * anx7688->n_snk_caps);
+	if (ret)
+		goto err_vconoff;
+
+	/* Send DP SNK identity */
+	ret = anx7688_send_ocm_message(anx7688, ANX7688_OCM_MSG_DP_SNK_IDENTITY,
+				       dp_snk_identity, sizeof dp_snk_identity);
+	if (ret)
+		goto err_vconoff;
+
+	ret = anx7688_send_ocm_message(anx7688, ANX7688_OCM_MSG_SVID,
+				       svid, sizeof svid);
+	if (ret)
+		goto err_vconoff;
+
+        dev_dbg(anx7688->dev, "OCM configuration completed\n");
+
+        desc.accessory = TYPEC_ACCESSORY_NONE;
+
+	typec_unregister_partner(anx7688->partner);
+
+        anx7688->partner = typec_register_partner(anx7688->port, &desc);
+        if (IS_ERR(anx7688->partner)) {
+                ret = PTR_ERR(anx7688->partner);
+		goto err_vconoff;
+	}
+
+	// after this deadline passes we'll check if device is pd_capable and
+	// set up the current limit accordingly
+	anx7688->current_update_deadline = ktime_add_ms(ktime_get(), 3000);
+
+	set_bit(ANX7688_F_CONNECTED, anx7688->flags);
+        return 0;
+
+err_vconoff:
+        regulator_disable(anx7688->supplies[ANX7688_VCONN_INDEX].consumer);
+	anx7688->vconn_on = false;
+err_poweroff:
+        anx7688_power_disable(anx7688);
+        dev_err(anx7688->dev, "OCM configuration failed\n");
+        return ret;
+#endif
+}
+
+static void anx7688_disconnect(struct anx7688 *anx7688)
+{
+	union power_supply_propval val = {0,};
+	struct device *dev = anx7688->dev;
+	int ret;
+
+        dev_dbg(dev, "cable removed\n");
+
+	anx7688->current_update_deadline = 0;
+
+	if (anx7688->extcon)
+		extcon_set_state_sync(anx7688->extcon, EXTCON_DISP_HDMI, 0);
+
+	if (anx7688->vconn_on) {
+		regulator_disable(anx7688->supplies[ANX7688_VCONN_INDEX].consumer);
+		anx7688->vconn_on = false;
+	}
+
+	if (anx7688->vbus_on) {
+		regulator_disable(anx7688->supplies[ANX7688_VBUS_INDEX].consumer);
+		anx7688->vbus_on = false;
+	}
+
+        anx7688_power_disable(anx7688);
+
+	anx7688->pd_capable = false;
+
+	typec_unregister_partner(anx7688->partner);
+        anx7688->partner = NULL;
+
+	anx7688->pwr_role = TYPEC_SINK;
+	anx7688->data_role = TYPEC_DEVICE;
+        typec_set_pwr_role(anx7688->port, anx7688->pwr_role);
+        typec_set_data_role(anx7688->port, anx7688->data_role);
+        typec_set_pwr_opmode(anx7688->port, TYPEC_PWR_MODE_USB);
+        typec_set_vconn_role(anx7688->port, TYPEC_SINK);
+
+	usb_role_switch_set_role(anx7688->role_sw, USB_ROLE_NONE);
+
+	val.intval = 500 * 1000;
+	dev_dbg(dev, "setting vbus_in current limit to %d mA\n", val.intval);
+	ret = power_supply_set_property(anx7688->vbus_in_supply,
+					POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT,
+					&val);
+	if (ret)
+		dev_err(dev, "failed to set vbus_in current to %d mA\n",
+			val.intval / 1000);
+
+	val.intval = 0;
+	dev_dbg(dev, "disabling vbus_in power path\n");
+	ret = power_supply_set_property(anx7688->vbus_in_supply,
+					POWER_SUPPLY_PROP_ONLINE,
+					&val);
+	if (ret)
+		dev_err(dev, "failed to offline vbus_in\n");
+
+	val.intval = 1;
+	dev_dbg(dev, "enabling USB BC 1.2 detection\n");
+	ret = power_supply_set_property(anx7688->vbus_in_supply,
+					POWER_SUPPLY_PROP_USB_BC_ENABLED,
+					&val);
+	if (ret)
+		dev_err(dev, "failed to enabled USB BC1.2 detection\n");
+
+	clear_bit(ANX7688_F_CONNECTED, anx7688->flags);
+}
+
+static void anx7688_handle_cable_change(struct anx7688* anx7688)
+{
+        int cabledet;
+	bool connected;
+
+	connected = test_bit(ANX7688_F_CONNECTED, anx7688->flags);
+        cabledet = gpiod_get_value(anx7688->gpio_cabledet);
+
+        if (cabledet && !connected)
+                anx7688_connect(anx7688);
+        else if (!cabledet && connected)
+                anx7688_disconnect(anx7688);
+}
+
+static irqreturn_t anx7688_irq_plug_handler(int irq, void *data)
+{
+        struct anx7688 *anx7688 = data;
+
+        dev_dbg(anx7688->dev, "plug irq (cd=%d)\n",
+                gpiod_get_value(anx7688->gpio_cabledet));
+
+        /*
+         * After each cabledet change the scheduled work timer is reset
+         * to fire in ~10ms. So the work is done only after the cabledet
+         * is stable for ~10ms.
+         */
+        schedule_delayed_work(&anx7688->work, msecs_to_jiffies(10));
+
+        return IRQ_HANDLED;
+}
+
+enum {
+	CMD_SUCCESS,
+	CMD_REJECT,
+	CMD_FAIL,
+	CMD_BUSY,
+};
+
+static const char* anx7688_cmd_statuses[] = {
+	"SUCCESS",
+	"REJECT",
+	"FAIL",
+	"BUSY",
+};
+
+static int anx7688_handle_pd_message_response(struct anx7688* anx7688,
+					      u8 to_cmd, u8 resp)
+{
+        const char* status = resp <= CMD_BUSY ? anx7688_cmd_statuses[resp] : "UNKNOWN";
+
+	switch (to_cmd) {
+		case ANX7688_OCM_MSG_PSWAP_REQ:
+			dev_info(anx7688->dev, "received response to PSWAP_REQ (%s)\n", status);
+			break;
+
+		case ANX7688_OCM_MSG_DSWAP_REQ:
+			dev_info(anx7688->dev, "received response to DSWAP_REQ (%s)\n", status);
+			break;
+
+		case ANX7688_OCM_MSG_VCONN_SWAP_REQ:
+			dev_info(anx7688->dev, "received response to VCONN_SWAP_REQ (%s)\n", status);
+			break;
+
+		case ANX7688_OCM_MSG_PWR_OBJ_REQ:
+			dev_info(anx7688->dev, "received response to PWR_OBJ_REQ (%s)\n", status);
+			break;
+
+		case ANX7688_OCM_MSG_VDM:
+			dev_info(anx7688->dev, "received response to VDM (%s)\n", status);
+			break;
+
+		case ANX7688_OCM_MSG_GOTO_MIN_REQ:
+			dev_info(anx7688->dev, "received response to GOTO_MIN_REQ (%s)\n", status);
+			break;
+
+		case ANX7688_OCM_MSG_GET_SNK_CAP:
+			dev_info(anx7688->dev, "received response to GET_SNK_CAP (%s)\n", status);
+			break;
+
+		default:
+			dev_info(anx7688->dev, "received response to unknown request (%s)\n", status);
+			break;
+	}
+
+	return 0;
+}
+
+static int anx7688_handle_pd_message(struct anx7688* anx7688,
+				     u8 cmd, u8* msg, unsigned len)
+{
+	struct device *dev = anx7688->dev;
+	union power_supply_propval psy_val = {0,};
+	uint32_t* pdos = (uint32_t*)msg;
+        int ret, i, rdo_max_v, rdo_max_p;
+	uint32_t pdo, rdo;
+
+	switch (cmd) {
+	case ANX7688_OCM_MSG_PWR_SRC_CAP:
+		dev_info(anx7688->dev, "received SRC_CAP\n");
+
+                if (len % 4 != 0) {
+			dev_warn(anx7688->dev, "received invalid sized PDO array\n");
+			break;
+		}
+
+		/* the partner is PD capable */
+		anx7688->pd_capable = true;
+
+		for (i = 0; i < len / 4; i++) {
+			pdo = le32_to_cpu(pdos[i]);
+
+			if (pdo_type(pdo) == PDO_TYPE_FIXED) {
+				unsigned voltage = pdo_fixed_voltage(pdo);
+				unsigned max_curr = pdo_max_current(pdo);
+
+				dev_info(anx7688->dev, "SRC_CAP PDO_FIXED (%umV %umA)\n", voltage, max_curr);
+			} else if (pdo_type(pdo) == PDO_TYPE_BATT) {
+				unsigned min_volt = pdo_min_voltage(pdo);
+				unsigned max_volt = pdo_max_voltage(pdo);
+				unsigned max_pow = pdo_max_power(pdo);
+
+				dev_info(anx7688->dev, "SRC_CAP PDO_BATT (%umV-%umV %umW)\n", min_volt, max_volt, max_pow);
+			} else if (pdo_type(pdo) == PDO_TYPE_VAR) {
+				unsigned min_volt = pdo_min_voltage(pdo);
+				unsigned max_volt = pdo_max_voltage(pdo);
+				unsigned max_curr = pdo_max_current(pdo);
+
+				dev_info(anx7688->dev, "SRC_CAP PDO_VAR (%umV-%umV %umA)\n", min_volt, max_volt, max_curr);
+			} else {
+				dev_info(anx7688->dev, "SRC_CAP PDO_APDO (0x%08X)\n", pdo);
+			}
+		}
+
+		/* when auto_pd mode is enabled, the FW has already set
+		 * RDO_MAX_VOLTAGE and RDO_MAX_POWER for the RDO it sent to the
+		 * partner based on the received SOURCE_CAPs. This does not
+		 * mean, the request was acked, but we can't do better here than
+		 * calculate the current_limit to set later and hope for the best.
+		 */
+		rdo_max_v = anx7688_reg_read(anx7688, ANX7688_REG_MAX_VOLTAGE_STATUS);
+		if (rdo_max_v < 0)
+			return rdo_max_v;
+		if (rdo_max_v == 0)
+			return -EINVAL;
+
+		rdo_max_p = anx7688_reg_read(anx7688, ANX7688_REG_MAX_POWER_STATUS);
+		if (rdo_max_p < 0)
+			return rdo_max_p;
+
+		anx7688->pd_current_limit = rdo_max_p * 5000 / rdo_max_v;
+
+		dev_dbg(anx7688->dev, "RDO max voltage = %dmV, max power = %dmW, PD current limit = %dmA\n",
+			rdo_max_v * 100, rdo_max_p * 500, anx7688->pd_current_limit);
+
+		// update current limit sooner, now that we have PD negotiation result
+		anx7688->current_update_deadline = ktime_add_ms(ktime_get(), 500);
+
+		//TODO: we should go through PDOs and decide which one
+		//to request, build a RDO with a proper index of the
+		//selected PDO and send it via PWR_OBJ_REQ message to FW
+		//but we're using auto_pd, so FW does this for us
+		//
+		//rdo = cpu_to_le32(RDO_FIXED(0, 1500, 1500, RDO_USB_COMM));
+		//ret = anx7688_send_ocm_message(anx7688, ANX7688_OCM_MSG_PWR_OBJ_REQ, &rdo, 4);
+
+		break;
+
+	case ANX7688_OCM_MSG_PWR_SNK_CAP:
+		dev_info(anx7688->dev, "received SNK_CAP\n");
+
+                if (len % 4 != 0) {
+			dev_warn(anx7688->dev, "received invalid sized PDO array\n");
+			break;
+		}
+
+		for (i = 0; i < len / 4; i++) {
+			pdo = le32_to_cpu(pdos[i]);
+
+			if (pdo_type(pdo) == PDO_TYPE_FIXED) {
+				unsigned voltage = pdo_fixed_voltage(pdo);
+				unsigned max_curr = pdo_max_current(pdo);
+
+				dev_info(anx7688->dev, "SNK_CAP PDO_FIXED (%umV %umA)\n", voltage, max_curr);
+			} else if (pdo_type(pdo) == PDO_TYPE_BATT) {
+				unsigned min_volt = pdo_min_voltage(pdo);
+				unsigned max_volt = pdo_max_voltage(pdo);
+				unsigned max_pow = pdo_max_power(pdo);
+
+				dev_info(anx7688->dev, "SNK_CAP PDO_BATT (%umV-%umV %umW)\n", min_volt, max_volt, max_pow);
+			} else if (pdo_type(pdo) == PDO_TYPE_VAR) {
+				unsigned min_volt = pdo_min_voltage(pdo);
+				unsigned max_volt = pdo_max_voltage(pdo);
+				unsigned max_curr = pdo_max_current(pdo);
+
+				dev_info(anx7688->dev, "SNK_CAP PDO_VAR (%umV-%umV %umA)\n", min_volt, max_volt, max_curr);
+			} else {
+				dev_info(anx7688->dev, "SNK_CAP PDO_APDO (0x%08X)\n", pdo);
+			}
+		}
+
+		break;
+
+	case ANX7688_OCM_MSG_PWR_OBJ_REQ:
+		dev_info(anx7688->dev, "received PWR_OBJ_REQ\n");
+
+		anx7688->pd_capable = true;
+
+                if (len != 4) {
+			dev_warn(anx7688->dev, "received invalid sized RDO\n");
+			break;
+		}
+
+		rdo = le32_to_cpu(pdos[0]);
+
+		if (rdo_index(rdo) >= 1 && rdo_index(rdo) <= anx7688->n_src_caps) {
+			unsigned rdo_op_curr = rdo_op_current(rdo);
+			unsigned rdo_max_curr = rdo_max_current(rdo);
+			unsigned rdo_idx = rdo_index(rdo) - 1;
+                        unsigned pdo_volt, pdo_max_curr;
+
+			pdo = anx7688->src_caps[rdo_idx];
+			pdo_volt = pdo_fixed_voltage(pdo);
+			pdo_max_curr = pdo_max_current(pdo);
+
+			dev_info(anx7688->dev, "RDO (idx=%d op=%umA max=%umA)\n",
+				 rdo_idx, rdo_op_curr, rdo_max_curr);
+
+			dev_info(anx7688->dev, "PDO_FIXED (%umV %umA)\n",
+				 pdo_volt, pdo_max_curr);
+
+			//TODO: we should check the req and respond with accept/reject
+			// but we're using auto_pd feature, so the FW will do
+			// this for us
+			if (rdo_op_curr > pdo_max_curr || rdo_max_curr > pdo_max_curr) {
+				//ret = anx7688_send_ocm_message(anx7688, ANX7688_OCM_MSG_REJECT, 0, 0);
+			} else {
+				//ret = anx7688_send_ocm_message(anx7688, ANX7688_OCM_MSG_ACCEPT, 0, 0);
+			}
+		} else {
+			dev_info(anx7688->dev, "PWR_OBJ RDO index out of range (RDO = 0x%08X)\n", rdo);
+		}
+
+		break;
+
+	case ANX7688_OCM_MSG_ACCEPT:
+		dev_info(anx7688->dev, "received ACCEPT\n");
+		break;
+
+	case ANX7688_OCM_MSG_REJECT:
+		dev_info(anx7688->dev, "received REJECT\n");
+		break;
+
+	case ANX7688_OCM_MSG_RESPONSE_TO_REQ:
+		if (len < 2) {
+			dev_warn(anx7688->dev, "received short RESPONSE_TO_REQ\n");
+			break;
+		}
+
+		anx7688_handle_pd_message_response(anx7688, msg[0], msg[1]);
+		break;
+
+	case ANX7688_OCM_MSG_SOFT_RST:
+		dev_info(anx7688->dev, "received SOFT_RST\n");
+		break;
+
+	case ANX7688_OCM_MSG_HARD_RST:
+		if (anx7688->pd_capable) {
+			dev_info(anx7688->dev, "received HARD_RST\n");
+
+			// stop drawing power from VBUS
+			psy_val.intval = 0;
+			dev_dbg(dev, "disabling vbus_in power path\n");
+			ret = power_supply_set_property(anx7688->vbus_in_supply,
+							POWER_SUPPLY_PROP_ONLINE,
+							&psy_val);
+			if (ret)
+				dev_err(anx7688->dev, "failed to offline vbus_in\n");
+
+			// wait till the dust settles
+			anx7688->current_update_deadline = ktime_add_ms(ktime_get(), 3000);
+		} else {
+			dev_dbg(anx7688->dev, "received HARD_RST, idiot firmware is bored\n");
+		}
+
+		break;
+
+	case ANX7688_OCM_MSG_RESTART:
+		dev_info(anx7688->dev, "received RESTART\n");
+		break;
+
+	case ANX7688_OCM_MSG_PSWAP_REQ:
+		dev_info(anx7688->dev, "received PSWAP_REQ\n");
+		break;
+
+	case ANX7688_OCM_MSG_DSWAP_REQ:
+		dev_info(anx7688->dev, "received DSWAP_REQ\n");
+		break;
+
+	case ANX7688_OCM_MSG_VCONN_SWAP_REQ:
+		dev_info(anx7688->dev, "received VCONN_SWAP_REQ\n");
+		break;
+
+	case ANX7688_OCM_MSG_DP_ALT_ENTER:
+		dev_info(anx7688->dev, "received DP_ALT_ENTER\n");
+		break;
+
+	case ANX7688_OCM_MSG_DP_ALT_EXIT:
+		dev_info(anx7688->dev, "received DP_ALT_EXIT\n");
+		break;
+
+	case ANX7688_OCM_MSG_DP_SNK_IDENTITY:
+		dev_info(anx7688->dev, "received DP_SNK_IDENTITY\n");
+		break;
+
+	case ANX7688_OCM_MSG_SVID:
+		dev_info(anx7688->dev, "received SVID\n");
+		break;
+
+	case ANX7688_OCM_MSG_VDM:
+		dev_info(anx7688->dev, "received VDM\n");
+		break;
+
+	case ANX7688_OCM_MSG_GOTO_MIN_REQ:
+		dev_info(anx7688->dev, "received GOTO_MIN_REQ\n");
+		break;
+
+	case ANX7688_OCM_MSG_PD_STATUS_REQ:
+		dev_info(anx7688->dev, "received PD_STATUS_REQ\n");
+		break;
+
+	case ANX7688_OCM_MSG_GET_DP_SNK_CAP:
+		dev_info(anx7688->dev, "received GET_DP_SNK_CAP\n");
+		break;
+
+	case ANX7688_OCM_MSG_DP_SNK_CFG:
+		dev_info(anx7688->dev, "received DP_SNK_CFG\n");
+		break;
+
+	default:
+		dev_info(anx7688->dev, "received unknown message 0x%02x\n", cmd);
+		break;
+	}
+
+	return 0;
+}
+
+static int anx7688_receive_msg(struct anx7688* anx7688)
+{
+        u8 pkt[32], checksum = 0;
+        int i, ret;
+
+        ret = i2c_smbus_read_i2c_block_data(anx7688->client_tcpc,
+                                            ANX7688_TCPC_REG_INTERFACE_RECV,
+                                            32, pkt);
+        if (ret < 0) {
+                dev_err(anx7688->dev, "failed to read pd msg\n");
+                return ret;
+        }
+
+        ret = anx7688_tcpc_reg_write(anx7688, ANX7688_TCPC_REG_INTERFACE_RECV, 0);
+        if (ret) {
+                dev_warn(anx7688->dev, "failed to clear recv fifo\n");
+        }
+
+        if (pkt[0] == 0 || pkt[0] > sizeof(pkt) - 2) {
+                dev_err(anx7688->dev, "received invalid pd message: %*ph\n",
+			(int)sizeof(pkt), pkt);
+                return -EINVAL;
+        }
+
+        dev_dbg(anx7688->dev, "recv ocm message cmd=0x%02x %*ph\n",
+                pkt[1], pkt[0] + 2, pkt);
+
+        for (i = 0; i < pkt[0] + 2; i++)
+                checksum += pkt[i];
+
+        if (checksum != 0) {
+                dev_err(anx7688->dev, "bad checksum on received message\n");
+                return -EINVAL;
+        }
+
+        anx7688_handle_pd_message(anx7688, pkt[1], pkt + 2, pkt[0] - 1);
+        return 0;
+}
+
+static const char* anx7688_cc_status_string(unsigned v)
+{
+	switch (v) {
+	case 0: return "SRC.Open";
+	case 1: return "SRC.Rd";
+	case 2: return "SRC.Ra";
+	case 4: return "SNK.Default";
+	case 8: return "SNK.Power1.5";
+	case 12: return "SNK.Power3.0";
+	default: return "UNK";
+	}
+}
+
+static int anx7688_update_status(struct anx7688 *anx7688)
+{
+        struct device *dev = anx7688->dev;
+	bool vbus_on, vconn_on, dr_dfp;
+	int status, cc_status, dp_state, dp_substate, ret;
+
+	status = anx7688_reg_read(anx7688, ANX7688_REG_STATUS);
+	if (status < 0)
+		return status;
+
+	cc_status = anx7688_reg_read(anx7688, ANX7688_REG_CC_STATUS);
+	if (cc_status < 0)
+		return cc_status;
+
+	dp_state = anx7688_tcpc_reg_read(anx7688, 0x87);
+	if (dp_state < 0)
+		return dp_state;
+
+	dp_substate = anx7688_tcpc_reg_read(anx7688, 0x88);
+	if (dp_substate < 0)
+		return dp_substate;
+
+	if (anx7688->extcon)
+		extcon_set_state_sync(anx7688->extcon,
+				      EXTCON_DISP_HDMI, dp_state >= 3);
+
+	dp_state = (dp_state << 8) | dp_substate;
+
+	if (anx7688->last_status == -1 || anx7688->last_status != status) {
+		anx7688->last_status = status;
+		dev_dbg(dev, "status changed to 0x%02x\n", status);
+	}
+
+	if (anx7688->last_cc_status == -1 || anx7688->last_cc_status != cc_status) {
+		anx7688->last_cc_status = cc_status;
+		dev_dbg(dev, "cc_status changed to CC1 = %s CC2 = %s\n",
+			anx7688_cc_status_string(cc_status & 0xf),
+			anx7688_cc_status_string((cc_status >> 4) & 0xf));
+	}
+
+	if (anx7688->last_dp_state == -1 || anx7688->last_dp_state != dp_state) {
+		anx7688->last_dp_state = dp_state;
+		dev_dbg(dev, "DP state changed to 0x%04x\n", dp_state);
+	}
+
+	vbus_on = !!(status & ANX7688_VBUS_STATUS);
+	vconn_on = !!(status & ANX7688_VCONN_STATUS);
+	dr_dfp = !!(status & ANX7688_DATA_ROLE_STATUS);
+
+	if (anx7688->vbus_on != vbus_on) {
+		dev_dbg(anx7688->dev, "POWER role change to %s\n",
+			vbus_on ? "SOURCE" : "SINK");
+
+		if (vbus_on) {
+			ret = regulator_enable(anx7688->supplies[ANX7688_VBUS_INDEX].consumer);
+			if (ret) {
+				dev_err(anx7688->dev, "failed to enable vbus\n");
+				return ret;
+			}
+		} else {
+			ret = regulator_disable(anx7688->supplies[ANX7688_VBUS_INDEX].consumer);
+			if (ret) {
+				dev_err(anx7688->dev, "failed to disable vbus\n");
+				return ret;
+			}
+		}
+
+		anx7688->pwr_role = vbus_on ? TYPEC_SOURCE : TYPEC_SINK;
+		typec_set_pwr_role(anx7688->port, anx7688->pwr_role);
+		anx7688->vbus_on = vbus_on;
+	}
+
+	if (anx7688->vconn_on != vconn_on) {
+		dev_dbg(anx7688->dev, "VCONN role change to %s\n",
+			vconn_on ? "SOURCE" : "SINK");
+
+		if (vconn_on) {
+			ret = regulator_enable(anx7688->supplies[ANX7688_VCONN_INDEX].consumer);
+			if (ret) {
+				dev_err(anx7688->dev, "failed to enable vconn\n");
+				return ret;
+			}
+		} else {
+			ret = regulator_disable(anx7688->supplies[ANX7688_VCONN_INDEX].consumer);
+			if (ret) {
+				dev_err(anx7688->dev, "failed to disable vconn\n");
+				return ret;
+			}
+		}
+
+		typec_set_vconn_role(anx7688->port, vconn_on ? TYPEC_SOURCE : TYPEC_SINK);
+		anx7688->vconn_on = vconn_on;
+	}
+
+	anx7688->data_role = dr_dfp ? TYPEC_HOST : TYPEC_DEVICE;
+	typec_set_data_role(anx7688->port, anx7688->data_role);
+
+	if (usb_role_switch_get_role(anx7688->role_sw) !=
+	    (dr_dfp ? USB_ROLE_HOST : USB_ROLE_DEVICE)) {
+		dev_dbg(anx7688->dev, "DATA role change requested to %s\n",
+			dr_dfp ? "DFP" : "UFP");
+
+		ret = usb_role_switch_set_role(anx7688->role_sw,
+					       dr_dfp ? USB_ROLE_HOST : USB_ROLE_DEVICE);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+
+static irqreturn_t anx7688_irq_status_handler(int irq, void *data)
+{
+#if DISABLE_OCM
+        struct anx7688 *anx7688 = data;
+        struct device *dev = anx7688->dev;
+        int ext2_status;
+
+        mutex_lock(&anx7688->lock);
+
+        if (!test_bit(ANX7688_F_CONNECTED, anx7688->flags)) {
+                /*
+		 * The chip should be disabled and powered off, nothing
+                 * more to do.
+		 */
+                dev_dbg(dev, "spurious status irq\n");
+                goto out_unlock;
+        }
+
+        //dev_dbg(dev, "status irq\n");
+
+        ext2_status = anx7688_reg_read(anx7688, ANX7688_REG_IRQ_EXT_SOURCE2);
+	dev_dbg(dev, "  ext2 = 0x%02x\n", ext2_status);
+	anx7688_reg_write(anx7688, ANX7688_REG_IRQ_EXT_SOURCE2, ext2_status);
+
+out_unlock:
+        mutex_unlock(&anx7688->lock);
+
+        return IRQ_HANDLED;
+#else
+        struct anx7688 *anx7688 = data;
+        struct device *dev = anx7688->dev;
+        int tcpc_status, ext2_status, soft_status;
+
+        mutex_lock(&anx7688->lock);
+
+        if (!test_bit(ANX7688_F_CONNECTED, anx7688->flags)) {
+                dev_dbg(dev, "spurious status irq\n");
+                /* anx chip should be disabled and power off, nothing
+                 * more to do */
+                goto out_unlock;
+        }
+
+        //dev_dbg(dev, "status irq\n");
+
+        // clear tcpc interrupt
+        tcpc_status = anx7688_tcpc_reg_read(anx7688, ANX7688_TCPC_REG_ALERT0);
+        if (tcpc_status > 0) {
+                //dev_dbg(dev, "  tcpc = 0x%02x\n", tcpc_status);
+                anx7688_tcpc_reg_write(anx7688, ANX7688_TCPC_REG_ALERT0, tcpc_status);
+        }
+
+        ext2_status = anx7688_reg_read(anx7688, ANX7688_REG_IRQ_EXT_SOURCE2);
+        if (ext2_status & ANX7688_IRQ2_SOFT_INT) {
+                soft_status = anx7688_reg_read(anx7688, ANX7688_REG_STATUS_INT);
+                anx7688_reg_write(anx7688, ANX7688_REG_STATUS_INT, 0);
+
+                //dev_dbg(dev, "  soft = 0x%02x\n", soft_status);
+
+		if (soft_status > 0) {
+			soft_status &= ANX7688_SOFT_INT_MASK;
+
+			if (soft_status & ANX7688_IRQS_RECEIVED_MSG)
+				anx7688_receive_msg(anx7688);
+
+			if (soft_status & (ANX7688_IRQS_CC_STATUS_CHANGE |
+					   ANX7688_IRQS_VBUS_CHANGE |
+					   ANX7688_IRQS_VCONN_CHANGE |
+					   ANX7688_IRQS_DATA_ROLE_CHANGE)) {
+				anx7688_update_status(anx7688);
+			}
+		}
+
+                anx7688_reg_write(anx7688, ANX7688_REG_IRQ_EXT_SOURCE2, ANX7688_IRQ2_SOFT_INT);
+        }
+
+out_unlock:
+        mutex_unlock(&anx7688->lock);
+
+        return IRQ_HANDLED;
+#endif
+}
+
+static int anx7688_dr_set(struct typec_port *port, enum typec_data_role role)
+{
+        struct anx7688 *anx7688 = typec_get_drvdata(port);
+	int ret = 0;
+
+        dev_info(anx7688->dev, "data role set %d\n", role);
+
+	if (anx7688->data_role != role) {
+		mutex_lock(&anx7688->lock);
+		ret = anx7688_send_ocm_message(anx7688, ANX7688_OCM_MSG_DSWAP_REQ, 0, 0);
+		mutex_unlock(&anx7688->lock);
+	}
+
+	return ret;
+}
+
+static int anx7688_pr_set(struct typec_port *port, enum typec_role role)
+{
+        struct anx7688 *anx7688 = typec_get_drvdata(port);
+	int ret = 0;
+
+        dev_info(anx7688->dev, "power role set %d\n", role);
+
+	if (anx7688->pwr_role != role) {
+		mutex_lock(&anx7688->lock);
+		ret = anx7688_send_ocm_message(anx7688, ANX7688_OCM_MSG_PSWAP_REQ, 0, 0);
+		mutex_unlock(&anx7688->lock);
+	}
+
+	return ret;
+}
+
+/*
+ * Calls to the eerpom functions need to be taken under the anx7688 lock.
+ */
+
+static int anx7688_eeprom_set_address(struct anx7688 *anx7688, u16 addr)
+{
+        int ret;
+
+        ret = anx7688_reg_write(anx7688, 0xe0, (addr >> 8) & 0xff);
+        if (ret < 0)
+                return ret;
+
+        return anx7688_reg_write(anx7688, 0xe1, addr & 0xff);
+}
+
+static int anx7688_eeprom_wait_done(struct anx7688 *anx7688)
+{
+        ktime_t timeout;
+        int ret;
+
+        // wait for read to be done
+        timeout = ktime_add_us(ktime_get(), 50000);
+        while (true) {
+                ret = anx7688_reg_read(anx7688, 0xe2);
+                if (ret < 0)
+                        return ret;
+
+                if (ret & BIT(3))
+                        return 0;
+
+                if (ktime_after(ktime_get(), timeout)) {
+                        dev_err(anx7688->dev, "timeout waiting for eeprom\n");
+                        return -ETIMEDOUT;
+                }
+        }
+}
+
+/* wait for internal FSM of EEPROM to be in a state ready for
+ * programming/reading
+ */
+static int anx7688_eeprom_wait_ready(struct anx7688 *anx7688)
+{
+        ktime_t timeout;
+        int ret;
+
+        // wait until eeprom is ready
+        timeout = ktime_add_us(ktime_get(), 1000000);
+        while (true) {
+                ret = anx7688_reg_read(anx7688, 0x7f);
+                if (ret < 0)
+                        return ret;
+
+                if ((ret & 0x0f) == 7)
+                        return 0;
+
+                if (ktime_after(ktime_get(), timeout)) {
+                        dev_err(anx7688->dev, "timeout waiting for eeprom to initialize\n");
+                        return -ETIMEDOUT;
+                }
+
+                msleep(5);
+        }
+}
+
+static int anx7688_eeprom_read(struct anx7688 *anx7688, unsigned addr, u8 buf[16])
+{
+        int ret;
+
+        ret = anx7688_eeprom_set_address(anx7688, addr);
+        if (ret)
+                return ret;
+
+        // initiate read
+        ret = anx7688_reg_write(anx7688, 0xe2, 0x06);
+        if (ret < 0)
+                return ret;
+
+        ret = anx7688_eeprom_wait_done(anx7688);
+        if (ret)
+                return ret;
+
+        ret = i2c_smbus_read_i2c_block_data(anx7688->client, 0xd0, 16, buf);
+        if (ret < 0) {
+                dev_err(anx7688->dev,
+                        "failed to read eeprom data (err=%d)\n", ret);
+                return ret;
+        }
+
+        return 0;
+}
+
+static int anx7688_eeprom_write(struct anx7688 *anx7688, unsigned addr,
+                                const u8 buf[16])
+{
+        int ret;
+
+        ret = anx7688_eeprom_set_address(anx7688, addr);
+        if (ret)
+                return ret;
+
+        ret = i2c_smbus_write_i2c_block_data(anx7688->client, 0xd0, 16, buf);
+        if (ret < 0) {
+                dev_err(anx7688->dev,
+                        "failed to write eeprom data (err=%d)\n", ret);
+                return ret;
+        }
+
+        dev_info(anx7688->dev, "eeprom wr %x %*ph\n", addr, 16, buf);
+
+        // initiate write
+        ret = anx7688_reg_write(anx7688, 0xe2, 0x01);
+        if (ret < 0)
+                return ret;
+
+        ret = anx7688_eeprom_wait_done(anx7688);
+        if (ret)
+                return ret;
+
+	udelay(1500);
+	udelay(1000);
+
+        return 0;
+}
+
+/*
+ * The firmware is flashed as is from address 0x10 up to 0xffff.
+ */
+static int anx7688_flash_firmware(struct anx7688 *anx7688)
+{
+        const char* fw_name = "anx7688-fw.bin";
+        const struct firmware *fw;
+        unsigned addr;
+        u8 buf[16];
+        int ret;
+
+        ret = request_firmware(&fw, fw_name, anx7688->dev);
+        if (ret < 0)
+                return ret;
+
+        if (fw->size > 0x10000 - 16) {
+                dev_err(anx7688->dev, "Firmware is too big %s\n", fw_name);
+                ret = -E2BIG;
+                goto err_release;
+        }
+
+        mutex_lock(&anx7688->lock);
+
+	/*
+	 * Cabledet changes will not be processed, since we're holding the
+	 * lock, so the firmware flashing is safe from interruptions.
+	 */
+
+	if (test_bit(ANX7688_F_CONNECTED, anx7688->flags))
+                anx7688_disconnect(anx7688);
+
+	msleep(20);
+
+	anx7688_power_enable(anx7688);
+
+        // reset OCM
+        ret = anx7688_reg_update_bits(anx7688, ANX7688_REG_USBC_RESET_CTRL,
+                                      ANX7688_USBC_RESET_CTRL_OCM_RESET,
+                                      ANX7688_USBC_RESET_CTRL_OCM_RESET);
+        if (ret < 0)
+                goto err_unlock;
+
+        ret = anx7688_eeprom_wait_ready(anx7688);
+        if (ret)
+                goto err_unlock;
+
+        msleep(10);
+
+	/*
+	 * Write to some magic registers to unlock flashing the EEPROM.
+	 */
+        ret = anx7688_reg_update_bits(anx7688, 0x3f, BIT(5), BIT(5));
+        if (ret < 0)
+                goto err_unlock;
+
+        ret = anx7688_reg_update_bits(anx7688, 0x44,
+                                      BIT(0) | BIT(7),
+                                      BIT(0) | BIT(7));
+        if (ret < 0)
+                goto err_unlock;
+
+        ret = anx7688_reg_update_bits(anx7688, 0x66, BIT(3), BIT(3));
+        if (ret < 0)
+                goto err_unlock;
+
+        msleep(50);
+
+        ret = anx7688_eeprom_wait_done(anx7688);
+        if (ret)
+                goto err_unlock;
+
+        for (addr = 0; addr < fw->size; addr += sizeof buf) {
+                memset(buf, 0, sizeof buf);
+                memcpy(buf, fw->data + addr, min_t(unsigned, fw->size - addr, sizeof buf));
+
+                ret = anx7688_eeprom_write(anx7688, addr + 0x10, buf);
+                if (ret < 0)
+                        goto err_unlock;
+        }
+
+	clear_bit(ANX7688_F_FW_FAILED, anx7688->flags);
+
+err_unlock:
+	anx7688_power_disable(anx7688);
+	schedule_delayed_work(&anx7688->work, msecs_to_jiffies(20));
+        mutex_unlock(&anx7688->lock);
+
+err_release:
+        release_firmware(fw);
+        return ret;
+}
+
+static const struct typec_operations anx7688_typec_ops = {
+        .dr_set = anx7688_dr_set,
+        .pr_set = anx7688_pr_set,
+};
+
+static ssize_t flash_eeprom_show(struct device *dev,
+                           struct device_attribute *attr, char *buf)
+{
+        return scnprintf(buf, PAGE_SIZE, "Write 1 to this file to initiate firmware flashing. Consult dmesg for results.\n");
+}
+
+static ssize_t flash_eeprom_store(struct device *dev,
+                            struct device_attribute *attr,
+                            const char *buf, size_t len)
+{
+        struct anx7688 *anx7688 = i2c_get_clientdata(to_i2c_client(dev));
+        unsigned val;
+        int ret;
+
+        ret = kstrtouint(buf, 0, &val);
+        if (ret)
+                return ret;
+
+        if (val == 1) {
+                ret = anx7688_flash_firmware(anx7688);
+                if (ret)
+                        return ret;
+        }
+
+        return len;
+}
+static DEVICE_ATTR_RW(flash_eeprom);
+
+static ssize_t reg_update_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t len)
+{
+        struct anx7688 *anx7688 = i2c_get_clientdata(to_i2c_client(dev));
+        unsigned val, addr, devaddr, data;
+        int ret;
+
+        ret = kstrtouint(buf, 16, &val);
+        if (ret)
+                return ret;
+
+	data = val & 0xff;
+	addr = (val >> 8) & 0xff;
+	devaddr = (val >> 16) & 0xff;
+
+	mutex_lock(&anx7688->lock);
+
+	if (!test_bit(ANX7688_F_POWERED, anx7688->flags)) {
+		ret = -ENODEV;
+		goto out_unlock;
+	}
+
+	if (devaddr == 0x50)
+		ret = anx7688_reg_write(anx7688, addr, val);
+	else if (devaddr == 0x58)
+		ret = anx7688_tcpc_reg_write(anx7688, addr, val);
+	else
+		ret = -EINVAL;
+
+out_unlock:
+	mutex_unlock(&anx7688->lock);
+
+        return ret ? ret : len;
+}
+static DEVICE_ATTR_WO(reg_update);
+
+static ssize_t hwreset_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t len)
+{
+        struct anx7688 *anx7688 = i2c_get_clientdata(to_i2c_client(dev));
+
+	mutex_lock(&anx7688->lock);
+
+	if (test_bit(ANX7688_F_CONNECTED, anx7688->flags))
+                anx7688_disconnect(anx7688);
+
+	schedule_delayed_work(&anx7688->work, msecs_to_jiffies(20));
+	mutex_unlock(&anx7688->lock);
+
+        return len;
+}
+static DEVICE_ATTR_WO(hwreset);
+
+static struct attribute *anx7688_attrs[] = {
+        &dev_attr_flash_eeprom.attr,
+        &dev_attr_reg_update.attr,
+        &dev_attr_hwreset.attr,
+        NULL,
+};
+
+ATTRIBUTE_GROUPS(anx7688);
+
+/*
+ * This function has to work when the ANX7688 is active, and when
+ * it is powered down. It power cycles the chip and asserts the OCM
+ * reset, to prevent OCM FW interfering with EEPROM reading.
+ *
+ * After reading EEPROM, the reconnection is scheduled.
+ */
+static int anx7688_firmware_show(struct seq_file *s, void *data)
+{
+        struct anx7688 *anx7688 = s->private;
+        unsigned addr;
+        u8 buf[16];
+        int ret;
+
+        mutex_lock(&anx7688->lock);
+
+	if (test_bit(ANX7688_F_CONNECTED, anx7688->flags))
+		anx7688_disconnect(anx7688);
+
+	msleep(20);
+
+	anx7688_power_enable(anx7688);
+
+	ret = anx7688_reg_update_bits(anx7688, ANX7688_REG_USBC_RESET_CTRL,
+				      ANX7688_USBC_RESET_CTRL_OCM_RESET,
+				      ANX7688_USBC_RESET_CTRL_OCM_RESET);
+	if (ret < 0)
+		goto out_powerdown;
+
+        ret = anx7688_eeprom_wait_ready(anx7688);
+        if (ret)
+                goto out_powerdown;
+
+	msleep(10);
+
+        for (addr = 0x10; addr < 0x10000; addr += 16) {
+                // set address
+                ret = anx7688_eeprom_read(anx7688, addr, buf);
+                if (ret < 0)
+                        goto out_powerdown;
+
+                seq_write(s, buf, sizeof buf);
+        }
+
+out_powerdown:
+	anx7688_power_disable(anx7688);
+        schedule_delayed_work(&anx7688->work, 0);
+        mutex_unlock(&anx7688->lock);
+
+        return ret;
+}
+DEFINE_SHOW_ATTRIBUTE(anx7688_firmware);
+
+static int anx7688_regs_show(struct seq_file *s, void *data)
+{
+        struct anx7688 *anx7688 = s->private;
+        u8 buf[16];
+        unsigned i, addr;
+        int ret = -ENODEV;
+
+        mutex_lock(&anx7688->lock);
+
+	if (!test_bit(ANX7688_F_POWERED, anx7688->flags))
+		goto out_unlock;
+
+        for (addr = 0; addr < 256; addr += 16) {
+                ret = i2c_smbus_read_i2c_block_data(anx7688->client, addr,
+                                                    sizeof buf, buf);
+                if (ret < 0) {
+                        dev_err(anx7688->dev,
+                                "failed to read registers (err=%d)\n", ret);
+                        goto out_unlock;
+                }
+
+                for (i = 0; i < 16; i++)
+                        seq_printf(s, "50%02x: %02x\n", addr + i, buf[i]);
+        }
+
+        for (addr = 0; addr < 256; addr += 16) {
+                ret = i2c_smbus_read_i2c_block_data(anx7688->client_tcpc, addr,
+                                                    sizeof buf, buf);
+                if (ret < 0) {
+                        dev_err(anx7688->dev,
+                                "failed to read registers (err=%d)\n", ret);
+                        goto out_unlock;
+                }
+
+                for (i = 0; i < 16; i++)
+                        seq_printf(s, "58%02x: %02x\n", addr + i, buf[i]);
+        }
+
+out_unlock:
+        mutex_unlock(&anx7688->lock);
+
+        return ret;
+}
+DEFINE_SHOW_ATTRIBUTE(anx7688_regs);
+
+static int anx7688_status_show(struct seq_file *s, void *data)
+{
+        struct anx7688 *anx7688 = s->private;
+
+        mutex_lock(&anx7688->lock);
+
+	seq_printf(s, "not much\n");
+
+        mutex_unlock(&anx7688->lock);
+
+        return 0;
+}
+DEFINE_SHOW_ATTRIBUTE(anx7688_status);
+
+/*
+ * This is just a 1s watchdog checking the state if cabledet pin.
+ */
+static void anx7688_cabledet_timer_fn(struct timer_list *t)
+{
+	struct anx7688 *anx7688 = from_timer(anx7688, t, work_timer);
+
+	schedule_delayed_work(&anx7688->work, 0);
+	mod_timer(t, jiffies + msecs_to_jiffies(1000));
+}
+
+static void anx7688_handle_vbus_in_notify(struct anx7688* anx7688)
+{
+	union power_supply_propval psy_val = {0,};
+	struct device *dev = anx7688->dev;
+	int ret;
+
+	/* PD charger doesn't like this for some reason, so it's disabled for now */
+	if (anx7688->input_current_limit && false) {
+		ret = power_supply_get_property(anx7688->vbus_in_supply,
+						POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT,
+						&psy_val);
+		if (ret) {
+			dev_err(dev, "failed to get vbus_in current\n");
+			return;
+		}
+
+		if (psy_val.intval == anx7688->input_current_limit)
+			goto check_type;
+
+		psy_val.intval = anx7688->input_current_limit * 1000;
+		dev_dbg(dev, "setting vbus_in current limit to %d mA\n",
+			psy_val.intval / 1000);
+		ret = power_supply_set_property(anx7688->vbus_in_supply,
+						POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT,
+						&psy_val);
+		if (ret)
+			dev_err(dev, "failed to set vbus_in current to %d mA\n",
+				psy_val.intval / 1000);
+	}
+
+check_type:
+	ret = power_supply_get_property(anx7688->vbus_in_supply,
+					POWER_SUPPLY_PROP_USB_TYPE,
+					&psy_val);
+	if (ret) {
+		dev_err(dev, "failed to get USB BC1.2 result\n");
+		return;
+	}
+
+	if (anx7688->last_bc_result == psy_val.intval)
+		return;
+
+	anx7688->last_bc_result = psy_val.intval;
+
+	switch (psy_val.intval) {
+	case POWER_SUPPLY_USB_TYPE_DCP:
+	case POWER_SUPPLY_USB_TYPE_CDP:
+		dev_dbg(dev, "BC 1.2 result: DCP or CDP\n");
+		break;
+	case POWER_SUPPLY_USB_TYPE_SDP:
+	default:
+		dev_dbg(dev, "BC 1.2 result: SDP\n");
+		break;
+	}
+}
+
+static int anx7688_cc_status(unsigned v)
+{
+	switch (v) {
+	case 0: return -1;
+	case 1: return -1;
+	case 2: return -1;
+	case 4: return TYPEC_PWR_MODE_USB;
+	case 8: return TYPEC_PWR_MODE_1_5A;
+	case 12: return TYPEC_PWR_MODE_3_0A;
+	default: return -1;
+	}
+}
+
+static const char* anx7688_get_power_mode_name(enum typec_pwr_opmode mode)
+{
+	switch (mode) {
+		case TYPEC_PWR_MODE_USB: return "USB";
+		case TYPEC_PWR_MODE_1_5A: return "1.5A";
+		case TYPEC_PWR_MODE_3_0A: return "3.0A";
+		case TYPEC_PWR_MODE_PD: return "PD";
+		default: return "Unknown";
+	}
+}
+
+/*
+ * This is called after 500ms after connection when the PD contract should have
+ * been negotiated. We should inspect CC pins or PD status here and decide what
+ * input current limit to set.
+ */
+static void anx7688_handle_current_update(struct anx7688* anx7688)
+{
+	unsigned cc_status = anx7688->last_cc_status;
+	union power_supply_propval val = {0,};
+        struct device *dev = anx7688->dev;
+	int pwr_mode, ret, current_limit = 0;
+
+	if (anx7688->pd_capable) {
+		pwr_mode = TYPEC_PWR_MODE_PD;
+	} else if (cc_status < 0) {
+		pwr_mode = TYPEC_PWR_MODE_USB;
+	} else {
+		pwr_mode = anx7688_cc_status(cc_status & 0xf);
+		if (pwr_mode < 0)
+			pwr_mode = anx7688_cc_status((cc_status >> 4) & 0xf);
+		if (pwr_mode < 0)
+			pwr_mode = TYPEC_PWR_MODE_USB;
+	}
+
+	if (pwr_mode == TYPEC_PWR_MODE_1_5A)
+		current_limit = 1500;
+	else if (pwr_mode == TYPEC_PWR_MODE_3_0A)
+		current_limit = 3000;
+	else if (pwr_mode == TYPEC_PWR_MODE_PD)
+		current_limit = anx7688->pd_current_limit;
+
+	anx7688->input_current_limit = current_limit;
+
+	dev_info(anx7688->dev, "updating power mode to %s, current limit %dmA (0 => BC1.2)\n",
+		 anx7688_get_power_mode_name(pwr_mode), current_limit);
+
+	if (current_limit) {
+		/*
+		 * Disable BC1.2 detection, because we'll be setting
+		 * a current limit determined by USB-PD
+		 */
+		val.intval = 0;
+		dev_dbg(dev, "disabling USB BC 1.2 detection\n");
+		ret = power_supply_set_property(anx7688->vbus_in_supply,
+						POWER_SUPPLY_PROP_USB_BC_ENABLED,
+						&val);
+		if (ret)
+			dev_err(dev, "failed to disable USB BC1.2 detection\n");
+
+		val.intval = current_limit * 1000;
+		dev_dbg(dev, "setting vbus_in current limit to %d mA\n", current_limit);
+		ret = power_supply_set_property(anx7688->vbus_in_supply,
+						POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT,
+						&val);
+		if (ret)
+			dev_err(dev, "failed to set vbus_in current to %d mA\n",
+				current_limit);
+	} else {
+		/*
+		 * Use the result of BC1.2 detection performed by PMIC.
+		 */
+		ret = power_supply_get_property(anx7688->vbus_in_supply,
+						POWER_SUPPLY_PROP_USB_BC_ENABLED,
+						&val);
+		if (ret)
+			dev_err(dev, "failed to get USB BC1.2 detection status\n");
+
+		if (ret != 0 || val.intval == 0) {
+			/*
+			 * If BC is disabled or we can't get its status,
+			 * set conservative 500mA limit. Otherwise leave
+			 * the limit to BC1.2.
+			 */
+			val.intval = 500 * 1000;
+			dev_dbg(dev, "setting vbus_in current limit to %d mA\n",
+				val.intval / 1000);
+			ret = power_supply_set_property(anx7688->vbus_in_supply,
+							POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT,
+							&val);
+			if (ret)
+				dev_err(dev, "failed to set vbus_in current to %d mA\n",
+					val.intval / 1000);
+		}
+	}
+
+	/* Turn on VBUS power path inside PMIC. */
+	val.intval = 1;
+	dev_dbg(dev, "enabling vbus_in power path\n");
+	ret = power_supply_set_property(anx7688->vbus_in_supply,
+					POWER_SUPPLY_PROP_ONLINE,
+					&val);
+	if (ret)
+		dev_err(anx7688->dev, "failed to enable vbus_in\n");
+
+	typec_set_pwr_opmode(anx7688->port, pwr_mode);
+}
+
+static int anx7688_vbus_in_notify(struct notifier_block *nb,
+				  unsigned long val, void *v)
+{
+	struct anx7688 *anx7688 = container_of(nb, struct anx7688, vbus_in_nb);
+	struct power_supply *psy = v;
+
+	/* atomic context */
+	if (val == PSY_EVENT_PROP_CHANGED && psy == anx7688->vbus_in_supply) {
+		set_bit(ANX7688_F_PWRSUPPLY_CHANGE, anx7688->flags);
+		schedule_delayed_work(&anx7688->work, 0);
+	}
+
+	return NOTIFY_OK;
+}
+
+static void anx7688_work(struct work_struct *work)
+{
+        struct anx7688 *anx7688 = container_of(work, struct anx7688, work.work);
+
+	if (test_bit(ANX7688_F_FW_FAILED, anx7688->flags))
+		return;
+
+	mutex_lock(&anx7688->lock);
+
+	if (test_and_clear_bit(ANX7688_F_PWRSUPPLY_CHANGE, anx7688->flags))
+		anx7688_handle_vbus_in_notify(anx7688);
+
+        anx7688_handle_cable_change(anx7688);
+
+	if (test_bit(ANX7688_F_CONNECTED, anx7688->flags)) {
+		/*
+		 * We check status periodically outside of interrupt, just to
+		 * be sure we didn't miss any status interrupts
+		 */
+		anx7688_update_status(anx7688);
+
+		if (anx7688->current_update_deadline &&
+			ktime_after(ktime_get(), anx7688->current_update_deadline)) {
+			anx7688->current_update_deadline = 0;
+			anx7688_handle_current_update(anx7688);
+		}
+	}
+
+	mutex_unlock(&anx7688->lock);
+}
+
+static int anx7688_i2c_probe(struct i2c_client *client,
+                             const struct i2c_device_id *id)
+{
+        struct anx7688 *anx7688;
+        struct device *dev = &client->dev;
+        struct typec_capability typec_cap = { };
+	union power_supply_propval psy_val;
+        int i, vid_h, vid_l;
+        int irq_cabledet;
+        int ret = 0;
+
+        anx7688 = devm_kzalloc(dev, sizeof(*anx7688), GFP_KERNEL);
+        if (!anx7688)
+                return -ENOMEM;
+
+        i2c_set_clientdata(client, anx7688);
+        anx7688->client = client;
+        anx7688->dev = &client->dev;
+        mutex_init(&anx7688->lock);
+        INIT_DELAYED_WORK(&anx7688->work, anx7688_work);
+
+	ret = of_property_read_variable_u32_array(dev->of_node, "source-caps",
+						  anx7688->src_caps,
+						  1, ARRAY_SIZE(anx7688->src_caps));
+	if (ret < 0) {
+		dev_err(dev, "failed to get source-caps from DT\n");
+		return ret;
+	}
+	anx7688->n_src_caps = ret;
+
+	ret = of_property_read_variable_u32_array(dev->of_node, "sink-caps",
+						  anx7688->snk_caps,
+						  1, ARRAY_SIZE(anx7688->snk_caps));
+	if (ret < 0) {
+		dev_err(dev, "failed to get sink-caps from DT\n");
+		return ret;
+	}
+	anx7688->n_snk_caps = ret;
+
+        for (i = 0; i < ANX7688_NUM_SUPPLIES; i++)
+                anx7688->supplies[i].supply = anx7688_supply_names[i];
+        ret = devm_regulator_bulk_get(dev, ANX7688_NUM_SUPPLIES,
+                                      anx7688->supplies);
+        if (ret)
+                return ret;
+
+	anx7688->vbus_in_supply =
+		devm_power_supply_get_by_phandle(dev, "vbus_in-supply");
+	if (IS_ERR(anx7688->vbus_in_supply)) {
+		dev_err(dev, "Couldn't get the VBUS power supply\n");
+		return PTR_ERR(anx7688->vbus_in_supply);
+	}
+
+	if (!anx7688->vbus_in_supply)
+		return -EPROBE_DEFER;
+
+        anx7688->gpio_enable = devm_gpiod_get(dev, "enable", GPIOD_OUT_LOW);
+        if (IS_ERR(anx7688->gpio_enable)) {
+                dev_err(dev, "Could not get enable gpio\n");
+                return PTR_ERR(anx7688->gpio_enable);
+        }
+
+        anx7688->gpio_reset = devm_gpiod_get(dev, "reset", GPIOD_OUT_HIGH);
+        if (IS_ERR(anx7688->gpio_reset)) {
+                dev_err(dev, "Could not get reset gpio\n");
+                return PTR_ERR(anx7688->gpio_reset);
+        }
+
+        anx7688->gpio_cabledet = devm_gpiod_get(dev, "cabledet", GPIOD_IN);
+        if (IS_ERR(anx7688->gpio_cabledet)) {
+                dev_err(dev, "Could not get cabledet gpio\n");
+                return PTR_ERR(anx7688->gpio_cabledet);
+        }
+
+        irq_cabledet = gpiod_to_irq(anx7688->gpio_cabledet);
+        if (irq_cabledet < 0) {
+                dev_err(dev, "Could not get cabledet irq\n");
+                return irq_cabledet;
+        }
+
+        ret = devm_device_add_groups(&client->dev, anx7688_groups);
+        if (ret)
+                return ret;
+
+	// Initialize extcon device
+	anx7688->extcon = devm_extcon_dev_allocate(dev, anx7688_extcon_cable);
+	if (IS_ERR(anx7688->extcon))
+		return -ENOMEM;
+
+	ret = devm_extcon_dev_register(dev, anx7688->extcon);
+	if (ret) {
+		dev_err(dev, "failed to register extcon device\n");
+		return ret;
+	}
+
+        // Register the TCPC i2c interface as second interface (0x58)
+        anx7688->client_tcpc = i2c_new_dummy_device(client->adapter, 0x2c);
+        if (IS_ERR(anx7688->client_tcpc)) {
+                dev_err(dev, "Could not register tcpc i2c client\n");
+                return PTR_ERR(anx7688->client_tcpc);
+        }
+        i2c_set_clientdata(anx7688->client_tcpc, anx7688);
+
+        // powerup and probe the ANX chip
+
+        ret = regulator_bulk_enable(ANX7688_NUM_ALWAYS_ON_SUPPLIES,
+                                    anx7688->supplies);
+        if (ret) {
+                dev_err(dev, "Could not enable regulators\n");
+                goto err_dummy_dev;
+        }
+
+        msleep(10);
+
+        anx7688_power_enable(anx7688);
+
+        vid_l = anx7688_tcpc_reg_read(anx7688, ANX7688_TCPC_REG_VENDOR_ID0);
+        vid_h = anx7688_tcpc_reg_read(anx7688, ANX7688_TCPC_REG_VENDOR_ID1);
+	if (vid_l < 0 || vid_h < 0) {
+		ret = vid_l < 0 ? vid_l : vid_h;
+		anx7688_power_disable(anx7688);
+		goto err_disable_reg;
+	}
+
+        dev_info(dev, "Vendor id 0x%04x\n", vid_l | vid_h << 8);
+
+        anx7688_power_disable(anx7688);
+
+	anx7688->role_sw = usb_role_switch_get(dev);
+	if (IS_ERR(anx7688->role_sw)) {
+                dev_err(dev, "Could not get role switch\n");
+		ret = PTR_ERR(anx7688->role_sw);
+		goto err_disable_reg;
+	}
+
+	// setup a typec port device
+        typec_cap.revision = USB_TYPEC_REV_1_2;
+        typec_cap.pd_revision = 0x200;
+        typec_cap.prefer_role = TYPEC_NO_PREFERRED_ROLE;
+        typec_cap.type = TYPEC_PORT_DRP;
+        typec_cap.data = TYPEC_PORT_DRD;
+        typec_cap.driver_data = anx7688;
+        typec_cap.ops = &anx7688_typec_ops;
+
+        anx7688->port = typec_register_port(dev, &typec_cap);
+        if (IS_ERR(anx7688->port)) {
+                dev_err(dev, "Could not register type-c port\n");
+                ret = PTR_ERR(anx7688->port);
+                goto err_role_sw;
+        }
+
+	anx7688->pwr_role = TYPEC_SINK;
+	anx7688->data_role = TYPEC_DEVICE;
+        typec_set_pwr_role(anx7688->port, anx7688->pwr_role);
+        typec_set_data_role(anx7688->port, anx7688->data_role);
+        typec_set_pwr_opmode(anx7688->port, TYPEC_PWR_MODE_USB);
+        typec_set_vconn_role(anx7688->port, TYPEC_SINK);
+
+	// make sure BC1.2 detection in PMIC is enabled
+	anx7688->last_bc_result = -1;
+	psy_val.intval = 1;
+	dev_dbg(dev, "enabling USB BC 1.2 detection\n");
+	ret = power_supply_set_property(anx7688->vbus_in_supply,
+			POWER_SUPPLY_PROP_USB_BC_ENABLED,
+			&psy_val);
+	if (ret) {
+		dev_err(anx7688->dev, "failed to enable BC1.2 detection\n");
+		goto err_cport;
+	}
+
+        ret = devm_request_irq(dev, irq_cabledet, anx7688_irq_plug_handler,
+                               IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING,
+                               "anx7688-cabledet", anx7688);
+        if (ret < 0) {
+                dev_err(dev, "Could not request cabledet irq (%d)\n", ret);
+                goto err_cport;
+        }
+
+        ret = devm_request_threaded_irq(dev, client->irq,
+                                        NULL, anx7688_irq_status_handler,
+                                        IRQF_ONESHOT, NULL, anx7688);
+        if (ret < 0) {
+                dev_err(dev, "Could not request irq (%d)\n", ret);
+                goto err_cport;
+        }
+
+	anx7688->vbus_in_nb.notifier_call = anx7688_vbus_in_notify;
+	anx7688->vbus_in_nb.priority = 0;
+	ret = power_supply_reg_notifier(&anx7688->vbus_in_nb);
+	if (ret)
+		goto err_cport;
+
+        anx7688->debug_root = debugfs_create_dir("anx7688", NULL);
+        debugfs_create_file("firmware", 0444, anx7688->debug_root, anx7688,
+                            &anx7688_firmware_fops);
+        debugfs_create_file("regs", 0444, anx7688->debug_root, anx7688,
+                            &anx7688_regs_fops);
+        debugfs_create_file("status", 0444, anx7688->debug_root, anx7688,
+                            &anx7688_status_fops);
+
+        schedule_delayed_work(&anx7688->work, msecs_to_jiffies(10));
+
+	timer_setup(&anx7688->work_timer, anx7688_cabledet_timer_fn, 0);
+	mod_timer(&anx7688->work_timer, jiffies + msecs_to_jiffies(1000));
+
+        return 0;
+
+err_cport:
+        typec_unregister_port(anx7688->port);
+err_role_sw:
+	usb_role_switch_put(anx7688->role_sw);
+err_disable_reg:
+        regulator_bulk_disable(ANX7688_NUM_ALWAYS_ON_SUPPLIES, anx7688->supplies);
+err_dummy_dev:
+        i2c_unregister_device(anx7688->client_tcpc);
+        return ret;
+}
+
+static int anx7688_i2c_remove(struct i2c_client *client)
+{
+        struct anx7688 *anx7688 = i2c_get_clientdata(client);
+
+	mutex_lock(&anx7688->lock);
+
+	power_supply_unreg_notifier(&anx7688->vbus_in_nb);
+
+	del_timer_sync(&anx7688->work_timer);
+
+        cancel_delayed_work_sync(&anx7688->work);
+
+	if (test_bit(ANX7688_F_CONNECTED, anx7688->flags))
+		anx7688_disconnect(anx7688);
+
+	typec_unregister_partner(anx7688->partner);
+        typec_unregister_port(anx7688->port);
+	usb_role_switch_put(anx7688->role_sw);
+
+        regulator_bulk_disable(ANX7688_NUM_ALWAYS_ON_SUPPLIES, anx7688->supplies);
+        i2c_unregister_device(anx7688->client_tcpc);
+
+        debugfs_remove(anx7688->debug_root);
+
+	mutex_unlock(&anx7688->lock);
+
+        return 0;
+}
+
+static int __maybe_unused anx7688_suspend(struct device *dev)
+{
+	struct anx7688 *anx7688 = i2c_get_clientdata(to_i2c_client(dev));
+
+	del_timer_sync(&anx7688->work_timer);
+	cancel_delayed_work_sync(&anx7688->work);
+
+	if (test_bit(ANX7688_F_POWERED, anx7688->flags))
+		regulator_disable(anx7688->supplies[ANX7688_I2C_INDEX].consumer);
+
+	return 0;
+}
+
+static int __maybe_unused anx7688_resume(struct device *dev)
+{
+	struct anx7688 *anx7688 = i2c_get_clientdata(to_i2c_client(dev));
+	int ret;
+
+	if (test_bit(ANX7688_F_POWERED, anx7688->flags)) {
+		ret = regulator_enable(anx7688->supplies[ANX7688_I2C_INDEX].consumer);
+		if (ret)
+			dev_warn(anx7688->dev,
+				 "failed to enable I2C regulator (%d)\n", ret);
+	}
+
+	// check status right after resume, since it could have changed during
+	// sleep
+	schedule_delayed_work(&anx7688->work, msecs_to_jiffies(50));
+	mod_timer(&anx7688->work_timer, jiffies + msecs_to_jiffies(1000));
+
+	return 0;
+}
+
+static const struct dev_pm_ops anx7688_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(anx7688_suspend, anx7688_resume)
+};
+
+static const struct i2c_device_id anx7688_ids[] = {
+        { "anx7688", 0 },
+        { }
+};
+MODULE_DEVICE_TABLE(i2c, anx7688_ids);
+
+static struct of_device_id anx7688_of_match_table[] = {
+        { .compatible = "analogix,anx7688" },
+        { },
+};
+MODULE_DEVICE_TABLE(of, anx7688_of_match_table);
+
+static struct i2c_driver anx7688_driver = {
+        .driver = {
+                .name = "anx7688",
+                .of_match_table = anx7688_of_match_table,
+		.pm = &anx7688_pm_ops,
+        },
+        .probe = anx7688_i2c_probe,
+        .remove = anx7688_i2c_remove,
+        .id_table = anx7688_ids,
+};
+
+module_i2c_driver(anx7688_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Martijn Braam <martijn@brixit.nl>");
+MODULE_AUTHOR("Ondrej Jirman <megous@megous.com>");
+MODULE_DESCRIPTION("Analogix ANX7688 USB-C DisplayPort bridge");
diff -Nuar -r --no-dereference linux-5.15.139/drivers/usb/typec/Kconfig linux/drivers/usb/typec/Kconfig
--- linux-5.15.139/drivers/usb/typec/Kconfig	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/usb/typec/Kconfig	2024-01-03 16:06:25.935131000 +0800
@@ -52,6 +52,17 @@
 
 source "drivers/usb/typec/tipd/Kconfig"
 
+config TYPEC_ANX7688
+	tristate "Analogix ANX7688 Type-C DRP Port controller and mux driver"
+	depends on I2C
+	depends on USB_ROLE_SWITCH
+	help
+	  Say Y or M here if your system has Analogix ANX7688 Type-C Bridge
+	  controller driver.
+
+	  If you choose to build this driver as a dynamically linked module, the
+	  module will be called anx7688.ko.
+
 config TYPEC_HD3SS3220
 	tristate "TI HD3SS3220 Type-C DRP Port controller driver"
 	depends on I2C
diff -Nuar -r --no-dereference linux-5.15.139/drivers/usb/gadget/composite.c linux/drivers/usb/gadget/composite.c
--- linux-5.15.139/drivers/usb/gadget/composite.c	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/usb/gadget/composite.c	2024-01-03 16:06:25.935131000 +0800
@@ -2569,7 +2569,7 @@
 
 static char *composite_default_mfr(struct usb_gadget *gadget)
 {
-	return kasprintf(GFP_KERNEL, "%s %s with %s", init_utsname()->sysname,
+	return kasprintf(GFP_KERNEL, "%s %s with %s", "Armbian Linux",
 			 init_utsname()->release, gadget->name);
 }
 
diff -Nuar -r --no-dereference linux-5.15.139/drivers/usb/core/quirks.c linux/drivers/usb/core/quirks.c
--- linux-5.15.139/drivers/usb/core/quirks.c	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/usb/core/quirks.c	2024-01-03 16:06:25.935131000 +0800
@@ -542,6 +542,9 @@
 	/* INTEL VALUE SSD */
 	{ USB_DEVICE(0x8086, 0xf1a5), .driver_info = USB_QUIRK_RESET_RESUME },
 
+	/* Quectel EG25G Modem */
+	{ USB_DEVICE(0x2c7c, 0x0125), .driver_info = USB_QUIRK_RESET },
+
 	{ }  /* terminating entry must be last */
 };
 
diff -Nuar -r --no-dereference linux-5.15.139/drivers/usb/dwc3/core.c linux/drivers/usb/dwc3/core.c
--- linux-5.15.139/drivers/usb/dwc3/core.c	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/usb/dwc3/core.c	2024-01-03 16:06:25.935131000 +0800
@@ -1127,6 +1127,10 @@
 		if (dwc->parkmode_disable_ss_quirk)
 			reg |= DWC3_GUCTL1_PARKMODE_DISABLE_SS;
 
+		if (dwc->maximum_speed == USB_SPEED_HIGH ||
+		    dwc->maximum_speed == USB_SPEED_FULL)
+			reg |= DWC3_GUCTL1_DEV_FORCE_20_CLK_FOR_30_CLK;
+
 		dwc3_writel(dwc->regs, DWC3_GUCTL1, reg);
 	}
 
diff -Nuar -r --no-dereference linux-5.15.139/drivers/usb/dwc3/core.h linux/drivers/usb/dwc3/core.h
--- linux-5.15.139/drivers/usb/dwc3/core.h	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/usb/dwc3/core.h	2024-01-03 16:06:25.935131000 +0800
@@ -255,6 +255,7 @@
 /* Global User Control 1 Register */
 #define DWC3_GUCTL1_DEV_DECOUPLE_L1L2_EVT	BIT(31)
 #define DWC3_GUCTL1_TX_IPGAP_LINECHECK_DIS	BIT(28)
+#define DWC3_GUCTL1_DEV_FORCE_20_CLK_FOR_30_CLK	BIT(26)
 #define DWC3_GUCTL1_DEV_L1_EXIT_BY_HW		BIT(24)
 #define DWC3_GUCTL1_PARKMODE_DISABLE_SS		BIT(17)
 #define DWC3_GUCTL1_RESUME_OPMODE_HS_HOST	BIT(10)
diff -Nuar -r --no-dereference linux-5.15.139/drivers/mfd/Makefile linux/drivers/mfd/Makefile
--- linux-5.15.139/drivers/mfd/Makefile	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/mfd/Makefile	2024-01-03 16:06:25.935131000 +0800
@@ -142,6 +142,7 @@
 obj-$(CONFIG_MFD_DA9052_I2C)	+= da9052-i2c.o
 
 obj-$(CONFIG_MFD_AC100)		+= ac100.o
+obj-$(CONFIG_MFD_AC200)		+= sunxi-ac200.o
 obj-$(CONFIG_MFD_AXP20X)	+= axp20x.o
 obj-$(CONFIG_MFD_AXP20X_I2C)	+= axp20x-i2c.o
 obj-$(CONFIG_MFD_AXP20X_RSB)	+= axp20x-rsb.o
diff -Nuar -r --no-dereference linux-5.15.139/drivers/mfd/sun4i-gpadc.c linux/drivers/mfd/sun4i-gpadc.c
--- linux-5.15.139/drivers/mfd/sun4i-gpadc.c	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/mfd/sun4i-gpadc.c	2024-01-03 16:06:25.935131000 +0800
@@ -54,6 +54,7 @@
 static struct mfd_cell sun5i_gpadc_cells[] = {
 	{
 		.name	= "sun5i-a13-gpadc-iio",
+		.of_compatible	= "allwinner,sun5i-a13-gpadc-iio",
 		.resources = adc_resources,
 		.num_resources = ARRAY_SIZE(adc_resources),
 	},
diff -Nuar -r --no-dereference linux-5.15.139/drivers/mfd/ac100.c linux/drivers/mfd/ac100.c
--- linux-5.15.139/drivers/mfd/ac100.c	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/mfd/ac100.c	2024-01-03 16:06:25.935131000 +0800
@@ -80,6 +80,9 @@
 		.name		= "ac100-codec",
 		.of_compatible	= "x-powers,ac100-codec",
 	}, {
+		.name		= "ac100-codec-analog",
+		.of_compatible	= "x-powers,ac100-codec-analog",
+	}, {
 		.name		= "ac100-rtc",
 		.of_compatible	= "x-powers,ac100-rtc",
 	},
diff -Nuar -r --no-dereference linux-5.15.139/drivers/mfd/Kconfig linux/drivers/mfd/Kconfig
--- linux-5.15.139/drivers/mfd/Kconfig	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/mfd/Kconfig	2024-01-03 16:06:25.935131000 +0800
@@ -179,6 +179,15 @@
 	  This driver include only the core APIs. You have to select individual
 	  components like codecs or RTC under the corresponding menus.
 
+config MFD_AC200
+	bool "X-Powers AC200"
+	select MFD_CORE
+	depends on I2C
+	help
+	  If you say Y here you get support for the X-Powers AC200 IC.
+	  This driver include only the core APIs. You have to select individual
+	  components like Ethernet PHY or RTC under the corresponding menus.
+
 config MFD_AXP20X
 	tristate
 	select MFD_CORE
diff -Nuar -r --no-dereference linux-5.15.139/drivers/mfd/sunxi-ac200.c linux/drivers/mfd/sunxi-ac200.c
--- linux-5.15.139/drivers/mfd/sunxi-ac200.c	1970-01-01 08:00:00.000000000 +0800
+++ linux/drivers/mfd/sunxi-ac200.c	2024-01-03 16:06:25.935131000 +0800
@@ -0,0 +1,184 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * MFD core driver for X-Powers' AC200 IC
+ *
+ * The AC200 is a chip which is co-packaged with Allwinner H6 SoC and
+ * includes analog audio codec, analog TV encoder, ethernet PHY, eFuse
+ * and RTC.
+ *
+ * Copyright (c) 2020 Jernej Skrabec <jernej.skrabec@siol.net>
+ */
+
+#include <linux/i2c.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/mfd/core.h>
+#include <linux/mfd/ac200.h>
+#include <linux/module.h>
+#include <linux/of.h>
+
+/* Interrupts */
+#define AC200_IRQ_RTC  0
+#define AC200_IRQ_EPHY 1
+#define AC200_IRQ_TVE  2
+
+/* IRQ enable register */
+#define AC200_SYS_IRQ_ENABLE_OUT_EN BIT(15)
+#define AC200_SYS_IRQ_ENABLE_RTC    BIT(12)
+#define AC200_SYS_IRQ_ENABLE_EPHY   BIT(8)
+#define AC200_SYS_IRQ_ENABLE_TVE    BIT(4)
+
+static const struct regmap_range_cfg ac200_range_cfg[] = {
+	{
+		.range_min = AC200_SYS_VERSION,
+		.range_max = AC200_IC_CHARA1,
+		.selector_reg = AC200_TWI_REG_ADDR_H,
+		.selector_mask = 0xff,
+		.selector_shift = 0,
+		.window_start = 0,
+		.window_len = 256,
+	}
+};
+
+static const struct regmap_config ac200_regmap_config = {
+	.name = "ac200",
+	.reg_bits	= 8,
+	.val_bits	= 16,
+	.ranges		= ac200_range_cfg,
+	.num_ranges	= ARRAY_SIZE(ac200_range_cfg),
+	.max_register	= AC200_IC_CHARA1,
+};
+
+static const struct regmap_irq ac200_regmap_irqs[] = {
+	REGMAP_IRQ_REG(AC200_IRQ_RTC,  0, AC200_SYS_IRQ_ENABLE_RTC),
+	REGMAP_IRQ_REG(AC200_IRQ_EPHY, 0, AC200_SYS_IRQ_ENABLE_EPHY),
+	REGMAP_IRQ_REG(AC200_IRQ_TVE,  0, AC200_SYS_IRQ_ENABLE_TVE),
+};
+
+static const struct regmap_irq_chip ac200_regmap_irq_chip = {
+	.name			= "ac200_irq_chip",
+	.status_base		= AC200_SYS_IRQ_STATUS,
+	.mask_base		= AC200_SYS_IRQ_ENABLE,
+	.mask_invert		= true,
+	.irqs			= ac200_regmap_irqs,
+	.num_irqs		= ARRAY_SIZE(ac200_regmap_irqs),
+	.num_regs		= 1,
+};
+
+static const struct resource ephy_resource[] = {
+	DEFINE_RES_IRQ(AC200_IRQ_EPHY),
+};
+
+static const struct mfd_cell ac200_cells[] = {
+	{
+		.name		= "ac200-ephy",
+		.num_resources	= ARRAY_SIZE(ephy_resource),
+		.resources	= ephy_resource,
+		.of_compatible	= "x-powers,ac200-ephy",
+	},
+	{
+		.name = "acx00-codec",
+		.of_compatible	= "x-powers,ac200-codec",
+	},
+};
+
+static int ac200_i2c_probe(struct i2c_client *i2c,
+			   const struct i2c_device_id *id)
+{
+	struct device *dev = &i2c->dev;
+	struct ac200_dev *ac200;
+	int ret;
+
+	ac200 = devm_kzalloc(dev, sizeof(*ac200), GFP_KERNEL);
+	if (!ac200)
+		return -ENOMEM;
+
+	i2c_set_clientdata(i2c, ac200);
+
+	ac200->regmap = devm_regmap_init_i2c(i2c, &ac200_regmap_config);
+	if (IS_ERR(ac200->regmap)) {
+		ret = PTR_ERR(ac200->regmap);
+		dev_err(dev, "regmap init failed: %d\n", ret);
+		return ret;
+	}
+
+	ac200->clk = devm_clk_get(dev, NULL);
+	if (IS_ERR(ac200->clk)) {
+	      dev_err(dev, "Can't obtain the clock!\n");
+	      return PTR_ERR(ac200->clk);
+	}
+
+	ret = clk_prepare_enable(ac200->clk);
+	if (ret)
+	      return ret;
+
+	/* do a reset to put chip in a known state */
+	ret = regmap_write(ac200->regmap, AC200_SYS_CONTROL, 0);
+	if (ret)
+		return ret;
+
+	ret = regmap_write(ac200->regmap, AC200_SYS_CONTROL, 1);
+	if (ret)
+		return ret;
+
+	/* enable interrupt pin */
+
+	ret = regmap_write(ac200->regmap, AC200_SYS_IRQ_ENABLE,
+			   AC200_SYS_IRQ_ENABLE_OUT_EN);
+	if (ret)
+		return ret;
+
+	ret = regmap_add_irq_chip(ac200->regmap, i2c->irq, IRQF_ONESHOT, 0,
+				  &ac200_regmap_irq_chip, &ac200->regmap_irqc);
+	if (ret)
+		return ret;
+
+	ret = devm_mfd_add_devices(dev, PLATFORM_DEVID_NONE, ac200_cells,
+				   ARRAY_SIZE(ac200_cells), NULL, 0, NULL);
+	if (ret) {
+		dev_err(dev, "failed to add MFD devices: %d\n", ret);
+		regmap_del_irq_chip(i2c->irq, ac200->regmap_irqc);
+		return ret;
+	}
+
+	return 0;
+}
+
+static int ac200_i2c_remove(struct i2c_client *i2c)
+{
+	struct ac200_dev *ac200 = i2c_get_clientdata(i2c);
+
+	regmap_write(ac200->regmap, AC200_SYS_CONTROL, 0);
+
+	mfd_remove_devices(&i2c->dev);
+	regmap_del_irq_chip(i2c->irq, ac200->regmap_irqc);
+
+	return 0;
+}
+
+static const struct i2c_device_id ac200_ids[] = {
+	{ "ac200", },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(i2c, ac200_ids);
+
+static const struct of_device_id ac200_of_match[] = {
+	{ .compatible = "x-powers,ac200" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, ac200_of_match);
+
+static struct i2c_driver ac200_i2c_driver = {
+	.driver = {
+		.name	= "ac200",
+		.of_match_table	= of_match_ptr(ac200_of_match),
+	},
+	.probe	= ac200_i2c_probe,
+	.remove = ac200_i2c_remove,
+	.id_table = ac200_ids,
+};
+module_i2c_driver(ac200_i2c_driver);
+
+MODULE_DESCRIPTION("MFD core driver for AC200");
+MODULE_AUTHOR("Jernej Skrabec <jernej.skrabec@siol.net>");
+MODULE_LICENSE("GPL v2");
diff -Nuar -r --no-dereference linux-5.15.139/drivers/mfd/axp20x.c linux/drivers/mfd/axp20x.c
--- linux-5.15.139/drivers/mfd/axp20x.c	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/mfd/axp20x.c	2024-01-03 16:06:25.935131000 +0800
@@ -79,6 +79,7 @@
 	regmap_reg_range(AXP20X_IRQ1_EN, AXP20X_IRQ5_STATE),
 	regmap_reg_range(AXP20X_ACIN_V_ADC_H, AXP20X_IPSOUT_V_HIGH_L),
 	regmap_reg_range(AXP20X_GPIO20_SS, AXP20X_GPIO3_CTRL),
+	regmap_reg_range(AXP20X_CHRG_CC_31_24, AXP20X_DISCHRG_CC_7_0),
 	regmap_reg_range(AXP20X_FG_RES, AXP20X_RDC_L),
 };
 
@@ -179,6 +180,15 @@
 	DEFINE_RES_IRQ_NAMED(AXP20X_IRQ_ACIN_OVER_V, "ACIN_OVER_V"),
 };
 
+static const struct resource axp20x_battery_resources[] = {
+	DEFINE_RES_IRQ_NAMED(AXP20X_IRQ_BATT_PLUGIN, "BATT_PLUGIN"),
+	DEFINE_RES_IRQ_NAMED(AXP20X_IRQ_BATT_REMOVAL, "BATT_REMOVAL"),
+	DEFINE_RES_IRQ_NAMED(AXP20X_IRQ_BATT_ENT_ACT_MODE, "BATT_HEALTH_DEAD"),
+	DEFINE_RES_IRQ_NAMED(AXP20X_IRQ_BATT_EXIT_ACT_MODE, "BATT_HEALTH_GOOD"),
+	DEFINE_RES_IRQ_NAMED(AXP20X_IRQ_CHARG, "BATT_CHARGING"),
+	DEFINE_RES_IRQ_NAMED(AXP20X_IRQ_CHARG_DONE, "BATT_CHARGING_DONE"),
+};
+
 static const struct resource axp20x_pek_resources[] = {
 	DEFINE_RES_IRQ_NAMED(AXP20X_IRQ_PEK_RIS_EDGE, "PEK_DBR"),
 	DEFINE_RES_IRQ_NAMED(AXP20X_IRQ_PEK_FAL_EDGE, "PEK_DBF"),
@@ -200,6 +210,8 @@
 static const struct resource axp803_usb_power_supply_resources[] = {
 	DEFINE_RES_IRQ_NAMED(AXP803_IRQ_VBUS_PLUGIN, "VBUS_PLUGIN"),
 	DEFINE_RES_IRQ_NAMED(AXP803_IRQ_VBUS_REMOVAL, "VBUS_REMOVAL"),
+	DEFINE_RES_IRQ_NAMED(AXP803_IRQ_BC_USB_CHNG, "BC_USB_CHNG"),
+	DEFINE_RES_IRQ_NAMED(AXP803_IRQ_MV_CHNG, "MV_CHNG"),
 };
 
 static const struct resource axp22x_pek_resources[] = {
@@ -221,6 +233,25 @@
 	DEFINE_RES_IRQ(AXP288_IRQ_WL1),
 };
 
+static const struct resource axp803_battery_resources[] = {
+	DEFINE_RES_IRQ_NAMED(AXP803_IRQ_BATT_PLUGIN, "BATT_PLUGIN"),
+	DEFINE_RES_IRQ_NAMED(AXP803_IRQ_BATT_REMOVAL, "BATT_REMOVAL"),
+	DEFINE_RES_IRQ_NAMED(AXP803_IRQ_BATT_ENT_ACT_MODE, "BATT_HEALTH_DEAD"),
+	DEFINE_RES_IRQ_NAMED(AXP803_IRQ_BATT_EXIT_ACT_MODE, "BATT_HEALTH_GOOD"),
+	DEFINE_RES_IRQ_NAMED(AXP803_IRQ_CHARG, "BATT_CHARGING"),
+	DEFINE_RES_IRQ_NAMED(AXP803_IRQ_CHARG_DONE, "BATT_CHARGING_DONE"),
+	DEFINE_RES_IRQ_NAMED(AXP803_IRQ_BATT_CHG_TEMP_HIGH, "BATT_CHG_TEMP_HIGH"),
+	DEFINE_RES_IRQ_NAMED(AXP803_IRQ_BATT_CHG_TEMP_HIGH_END, "BATT_CHG_TEMP_HIGH_END"),
+	DEFINE_RES_IRQ_NAMED(AXP803_IRQ_BATT_CHG_TEMP_LOW, "BATT_CHG_TEMP_LOW"),
+	DEFINE_RES_IRQ_NAMED(AXP803_IRQ_BATT_CHG_TEMP_LOW_END, "BATT_CHG_TEMP_LOW_END"),
+	DEFINE_RES_IRQ_NAMED(AXP803_IRQ_BATT_ACT_TEMP_HIGH, "BATT_ACT_TEMP_HIGH"),
+	DEFINE_RES_IRQ_NAMED(AXP803_IRQ_BATT_ACT_TEMP_HIGH_END, "BATT_ACT_TEMP_HIGH_END"),
+	DEFINE_RES_IRQ_NAMED(AXP803_IRQ_BATT_ACT_TEMP_LOW, "BATT_ACT_TEMP_LOW"),
+	DEFINE_RES_IRQ_NAMED(AXP803_IRQ_BATT_ACT_TEMP_LOW_END, "BATT_ACT_TEMP_LOW_END"),
+	DEFINE_RES_IRQ_NAMED(AXP803_IRQ_LOW_PWR_LVL1, "BATT_LOW_PWR_LVL1"),
+	DEFINE_RES_IRQ_NAMED(AXP803_IRQ_LOW_PWR_LVL2, "BATT_LOW_PWR_LVL2"),
+};
+
 static const struct resource axp803_pek_resources[] = {
 	DEFINE_RES_IRQ_NAMED(AXP803_IRQ_PEK_RIS_EDGE, "PEK_DBR"),
 	DEFINE_RES_IRQ_NAMED(AXP803_IRQ_PEK_FAL_EDGE, "PEK_DBF"),
@@ -604,6 +635,8 @@
 	}, {
 		.name		= "axp20x-battery-power-supply",
 		.of_compatible	= "x-powers,axp209-battery-power-supply",
+		.num_resources	= ARRAY_SIZE(axp20x_battery_resources),
+		.resources	= axp20x_battery_resources,
 	}, {
 		.name		= "axp20x-ac-power-supply",
 		.of_compatible	= "x-powers,axp202-ac-power-supply",
@@ -635,6 +668,8 @@
 	}, {
 		.name		= "axp20x-battery-power-supply",
 		.of_compatible	= "x-powers,axp221-battery-power-supply",
+		.num_resources	= ARRAY_SIZE(axp20x_battery_resources),
+		.resources	= axp20x_battery_resources,
 	}, {
 		.name		= "axp20x-usb-power-supply",
 		.of_compatible	= "x-powers,axp221-usb-power-supply",
@@ -654,6 +689,8 @@
 	}, {
 		.name		= "axp20x-battery-power-supply",
 		.of_compatible	= "x-powers,axp221-battery-power-supply",
+		.num_resources	= ARRAY_SIZE(axp20x_battery_resources),
+		.resources	= axp20x_battery_resources,
 	}, {
 		.name		= "axp20x-regulator",
 	}, {
@@ -753,6 +790,8 @@
 	}, {
 		.name		= "axp20x-battery-power-supply",
 		.of_compatible	= "x-powers,axp813-battery-power-supply",
+		.num_resources	= ARRAY_SIZE(axp803_battery_resources),
+		.resources	= axp803_battery_resources,
 	}, {
 		.name		= "axp20x-ac-power-supply",
 		.of_compatible	= "x-powers,axp813-ac-power-supply",
@@ -810,6 +849,8 @@
 	}, {
 		.name		= "axp20x-battery-power-supply",
 		.of_compatible	= "x-powers,axp813-battery-power-supply",
+		.num_resources	= ARRAY_SIZE(axp803_battery_resources),
+		.resources	= axp803_battery_resources,
 	}, {
 		.name		= "axp20x-ac-power-supply",
 		.of_compatible	= "x-powers,axp813-ac-power-supply",
@@ -820,6 +861,9 @@
 		.num_resources	= ARRAY_SIZE(axp803_usb_power_supply_resources),
 		.resources	= axp803_usb_power_supply_resources,
 		.of_compatible	= "x-powers,axp813-usb-power-supply",
+	}, {
+		.name		= "axp20x-charger-led",
+		.of_compatible	= "x-powers,axp813-charger-led",
 	},
 };
 
@@ -836,6 +880,611 @@
 	msleep(500);
 }
 
+#define kobj_to_device(x) container_of(x, struct device, kobj)
+
+int axp20x_get_adc_freq(struct axp20x_dev *axp)
+{
+	unsigned int res;
+	int ret, freq = 25;
+
+	ret = regmap_read(axp->regmap, AXP20X_ADC_RATE, &res);
+	if (ret < 0) {
+		dev_warn(axp->dev, "Unable to read ADC sampling frequency: %d\n", ret);
+		return freq;
+	}
+	switch ((res & 0xC0) >> 6) {
+	case 0:
+		freq = 25;
+		break;
+	case 1:
+		freq = 50;
+		break;
+	case 2:
+		freq = 100;
+		break;
+	case 3:
+		freq = 200;
+		break;
+	}
+	return freq;
+}
+
+static ssize_t axp20x_sysfs_read_bin_file(struct file *filp,
+				struct kobject *kobj,
+				struct bin_attribute *bin_attr,
+				char *buf, loff_t off, size_t count)
+{
+	int ret;
+
+	struct device *dev = kobj_to_device(kobj);
+	struct axp20x_dev *axp = dev_get_drvdata(dev);
+
+	ret = regmap_raw_read(axp->regmap, AXP20X_OCV(off), buf, count);
+	if (ret < 0)
+	{
+		dev_warn(axp->dev, "read_bin_file: error reading: %d\n", ret);
+		return ret;
+	}
+	return count;
+}
+
+static ssize_t axp20x_sysfs_write_bin_file(struct file *filp,
+				struct kobject *kobj,
+				struct bin_attribute *bin_attr,
+				char *buf, loff_t off, size_t count)
+{
+	int ret;
+
+	struct device *dev = kobj_to_device(kobj);
+	struct axp20x_dev *axp = dev_get_drvdata(dev);
+
+	ret = regmap_raw_write(axp->regmap, AXP20X_OCV(off), buf, count);
+	if (ret < 0)
+	{
+		dev_warn(axp->dev, "write_bin_file: error writing: %d\n", ret);
+		return ret;
+	}
+	return count;
+}
+
+static ssize_t axp20x_read_special(struct kobject *kobj, struct kobj_attribute *attr, char *buf)
+{
+	int i, freq, ret = 0;
+	unsigned int res;
+	u32 lval1, lval2;
+	s64 llval;
+	u64 ullval;
+
+	const char *subsystem = kobject_name(kobj);
+	struct device *dev = kobj_to_device(kobj->parent);
+	struct axp20x_dev *axp = dev_get_drvdata(dev);
+
+	dev_dbg(axp->dev, "read_special: reading attribute %s of object %s\n", attr->attr.name, subsystem);
+
+	if (strcmp(subsystem, "battery") == 0) {
+		if (strcmp(attr->attr.name, "power") == 0) {
+			lval1 = 0;
+			for (i = 0; i < 3; i++) {
+				ret |= regmap_read(axp->regmap, AXP20X_PWR_BATT_H + i, &res);
+				lval1 |= res << ((2 - i) * 8);
+			}
+			llval = lval1 * 1100 / 1000;
+		} else if (strcmp(attr->attr.name, "charge") == 0) {
+			ret = regmap_raw_read(axp->regmap, AXP20X_CHRG_CC_31_24, &lval1, sizeof(lval1));
+			ret |= regmap_raw_read(axp->regmap, AXP20X_DISCHRG_CC_31_24, &lval2, sizeof(lval2));
+			be32_to_cpus(&lval1);
+			be32_to_cpus(&lval2);
+			ullval = abs((s64)lval1 - (s64)lval2) * 65536 * 500;
+			freq = axp20x_get_adc_freq(axp);
+			do_div(ullval, 3600 * freq);
+			llval = (lval1 < lval2) ? -ullval : ullval;
+		} else if (strcmp(attr->attr.name, "capacity") == 0) {
+			ret = regmap_read(axp->regmap, AXP20X_FG_RES, &res);
+			llval = res & 0x7f;
+		} else
+			return -EINVAL;
+	} else
+		return -EINVAL;
+
+	if (ret < 0) {
+		dev_warn(axp->dev, "Unable to read parameter: %d\n", ret);
+		return ret;
+	}
+	return sprintf(buf, "%lld\n", llval);
+}
+
+static ssize_t axp20x_write_int(struct kobject *kobj, struct kobj_attribute *attr, const char *buf, size_t count)
+{
+	int reg, var, ret = 0, scale, width = 12, offset = 0;
+	unsigned int res;
+
+	const char *subsystem = kobject_name(kobj);
+	struct device *dev = kobj_to_device(kobj->parent);
+	struct axp20x_dev *axp = dev_get_drvdata(dev);
+
+	dev_dbg(axp->dev, "write_int: writing attribute %s of object %s\n", attr->attr.name, subsystem);
+
+	ret = kstrtoint(buf, 10, &var);
+	if (ret < 0)
+		return ret;
+
+	if (strcmp(subsystem, "control") == 0) {
+		if (strcmp(attr->attr.name, "battery_rdc") == 0) {
+			reg = AXP20X_RDC_H;
+			scale = 1074;
+			width = 13;
+			offset = 537;
+			/* TODO: Disable & enable fuel gauge */
+		} else
+			return -EINVAL;
+	} else
+		return -EINVAL;
+
+	res = (var + offset) / scale;
+
+	ret = regmap_write_bits(axp->regmap, reg, (1U << (width - 8)) - 1, (res >> 8) & 0xFF);
+	ret |= regmap_write_bits(axp->regmap, reg + 1, 0xFF, res & 0xFF);
+
+	if (ret < 0) {
+		dev_warn(axp->dev, "Unable to write parameter: %d\n", ret);
+		return ret;
+	}
+	return count;
+}
+
+static ssize_t axp20x_read_bool(struct kobject *kobj, struct kobj_attribute *attr, char *buf)
+{
+	int val, ret, reg, bit;
+	unsigned int res;
+
+	const char *subsystem = kobject_name(kobj);
+	struct device *dev = kobj_to_device(kobj->parent);
+	struct axp20x_dev *axp = dev_get_drvdata(dev);
+
+	dev_dbg(axp->dev, "read_bool: reading attribute %s of object %s\n", attr->attr.name, subsystem);
+
+	if (strcmp(subsystem, "ac") == 0) {
+		if (strcmp(attr->attr.name, "connected") == 0) {
+			reg = AXP20X_PWR_INPUT_STATUS;
+			bit = 7;
+		} else if (strcmp(attr->attr.name, "used") == 0) {
+			reg = AXP20X_PWR_INPUT_STATUS;
+			bit = 6;
+		} else
+			return -EINVAL;
+	} else if (strcmp(subsystem, "vbus") == 0) {
+		if (strcmp(attr->attr.name, "connected") == 0) {
+			reg = AXP20X_PWR_INPUT_STATUS;
+			bit = 5;
+		} else if (strcmp(attr->attr.name, "used") == 0) {
+			reg = AXP20X_PWR_INPUT_STATUS;
+			bit = 4;
+		} else if (strcmp(attr->attr.name, "strong") == 0) {
+			reg = AXP20X_PWR_INPUT_STATUS;
+			bit = 3;
+		} else
+			return -EINVAL;
+	} else if (strcmp(subsystem, "battery") == 0) {
+		if (strcmp(attr->attr.name, "connected") == 0) {
+			reg = AXP20X_PWR_OP_MODE;
+			bit = 5;
+		} else if (strcmp(attr->attr.name, "charging") == 0) {
+			reg = AXP20X_PWR_INPUT_STATUS;
+			bit = 2;
+		} else
+			return -EINVAL;
+	} else if (strcmp(subsystem, "pmu") == 0) {
+		if (strcmp(attr->attr.name, "overheat") == 0) {
+			reg = AXP20X_PWR_OP_MODE;
+			bit = 7;
+		} else
+			return -EINVAL;
+	} else if (strcmp(subsystem, "charger") == 0) {
+		if (strcmp(attr->attr.name, "charging") == 0) {
+			reg = AXP20X_PWR_OP_MODE;
+			bit = 6;
+		} else if (strcmp(attr->attr.name, "cell_activation") == 0) {
+			reg = AXP20X_PWR_OP_MODE;
+			bit = 3;
+		} else if (strcmp(attr->attr.name, "low_power") == 0) {
+			reg = AXP20X_PWR_OP_MODE;
+			bit = 2;
+		} else
+			return -EINVAL;
+	} else if (strcmp(subsystem, "control") == 0) {
+		if (strcmp(attr->attr.name, "set_vbus_direct_mode") == 0) {
+			reg = AXP20X_VBUS_IPSOUT_MGMT;
+			bit = 6;
+		} else if (strcmp(attr->attr.name, "reset_charge_counter") == 0) {
+			reg = AXP20X_CC_CTRL;
+			bit = 5;
+		} else if (strcmp(attr->attr.name, "charge_rtc_battery") == 0) {
+			reg = AXP20X_CHRG_BAK_CTRL;
+			bit = 7;
+		} else if (strcmp(attr->attr.name, "disable_fuel_gauge") == 0) {
+			reg = AXP20X_FG_RES;
+			bit = 7;
+		} else
+			return -EINVAL;
+	} else
+		return -EINVAL;
+
+	ret = regmap_read(axp->regmap, reg, &res);
+	if (ret < 0) {
+		dev_warn(axp->dev, "Unable to read parameter: %d\n", ret);
+		return ret;
+	}
+	val = (res & BIT(bit)) == BIT(bit) ? 1 : 0;
+	return sprintf(buf, "%d\n", val);
+}
+
+static ssize_t axp20x_write_bool(struct kobject *kobj, struct kobj_attribute *attr, const char *buf, size_t count)
+{
+	int var, ret, reg, bit;
+
+	const char *subsystem = kobject_name(kobj);
+	struct device *dev = kobj_to_device(kobj->parent);
+	struct axp20x_dev *axp = dev_get_drvdata(dev);
+
+	dev_dbg(axp->dev, "write_bool: writing attribute %s of object %s", attr->attr.name, subsystem);
+
+	ret = kstrtoint(buf, 10, &var);
+	if (ret < 0)
+		return ret;
+
+	if (strcmp(subsystem, "control") == 0) {
+		if (strcmp(attr->attr.name, "set_vbus_direct_mode") == 0) {
+			reg = AXP20X_VBUS_IPSOUT_MGMT;
+			bit = 6;
+		} else if (strcmp(attr->attr.name, "reset_charge_counter") == 0) {
+			reg = AXP20X_CC_CTRL;
+			bit = 5;
+		} else if (strcmp(attr->attr.name, "charge_rtc_battery") == 0) {
+			reg = AXP20X_CHRG_BAK_CTRL;
+			bit = 7;
+		} else if (strcmp(attr->attr.name, "disable_fuel_gauge") == 0) {
+			reg = AXP20X_FG_RES;
+			bit = 7;
+		} else
+			return -EINVAL;
+	} else
+		return -EINVAL;
+
+	ret = regmap_update_bits(axp->regmap, reg, BIT(bit), var ? BIT(bit) : 0);
+	if (ret)
+		dev_warn(axp->dev, "Unable to write value: %d", ret);
+	return count;
+}
+
+static int axp20x_averaging_helper(struct regmap *reg_map, int reg_h,
+	int width)
+{
+	long acc = 0;
+	int ret, i;
+
+	for (i = 0; i < 3; i++) {
+		ret = axp20x_read_variable_width(reg_map, reg_h, width);
+		if (ret < 0)
+			return ret;
+		acc += ret;
+		msleep(20); /* For 100Hz sampling frequency */
+	}
+	return (int)(acc / 3);
+}
+
+static ssize_t axp20x_read_int(struct kobject *kobj, struct kobj_attribute *attr, char *buf)
+{
+	int val, ret, scale, reg, width = 12, offset = 0;
+
+	const char *subsystem = kobject_name(kobj);
+	struct device *dev = kobj_to_device(kobj->parent);
+	struct axp20x_dev *axp = dev_get_drvdata(dev);
+
+	dev_dbg(axp->dev, "read_int: reading attribute %s of object %s\n", attr->attr.name, subsystem);
+
+	if (strcmp(subsystem, "ac") == 0) {
+		if (strcmp(attr->attr.name, "voltage") == 0) {
+			reg = AXP20X_ACIN_V_ADC_H;
+			scale = 1700;
+		} else if (strcmp(attr->attr.name, "amperage") == 0) {
+			reg = AXP20X_ACIN_I_ADC_H;
+			scale = 625;
+		} else
+			return -EINVAL;
+	} else if (strcmp(subsystem, "vbus") == 0) {
+		if (strcmp(attr->attr.name, "voltage") == 0) {
+			reg = AXP20X_VBUS_V_ADC_H;
+			scale = 1700;
+		} else if (strcmp(attr->attr.name, "amperage") == 0) {
+			reg = AXP20X_VBUS_I_ADC_H;
+			scale = 375;
+		} else
+			return -EINVAL;
+	} else if (strcmp(subsystem, "battery") == 0) {
+		if (strcmp(attr->attr.name, "voltage") == 0) {
+			reg = AXP20X_BATT_V_H;
+			scale = 1100;
+		} else if (strcmp(attr->attr.name, "amperage") == 0) {
+			reg = AXP20X_BATT_DISCHRG_I_H;
+			scale = 500;
+			width = 13;
+		} else if (strcmp(attr->attr.name, "ts_voltage") == 0) {
+			reg = AXP20X_TS_IN_H;
+			scale = 800;
+		} else
+			return -EINVAL;
+	} else if (strcmp(subsystem, "pmu") == 0) {
+		if (strcmp(attr->attr.name, "temp") == 0) {
+			reg = AXP20X_TEMP_ADC_H;
+			scale = 100;
+			offset = 144700;
+		} else if (strcmp(attr->attr.name, "voltage") == 0) {
+			reg = AXP20X_IPSOUT_V_HIGH_H;
+			scale = 1400;
+		} else
+			return -EINVAL;
+	} else if (strcmp(subsystem, "charger") == 0) {
+		if (strcmp(attr->attr.name, "amperage") == 0) {
+			reg = AXP20X_BATT_CHRG_I_H;
+			scale = 500;
+		} else
+			return -EINVAL;
+	} else if (strcmp(subsystem, "control") == 0) {
+		if (strcmp(attr->attr.name, "battery_rdc") == 0) {
+			reg = AXP20X_RDC_H;
+			width = 13;
+			scale = 1074;
+			offset = 537;
+		} else
+			return -EINVAL;
+	} else
+		return -EINVAL;
+
+	ret = axp20x_averaging_helper(axp->regmap, reg, width);
+
+	if (ret < 0) {
+		dev_warn(axp->dev, "Unable to read parameter: %d\n", ret);
+		return ret;
+	}
+	val = ret * scale - offset;
+	return sprintf(buf, "%d\n", val);
+}
+
+/* AC IN */
+static struct kobj_attribute ac_in_voltage = __ATTR(voltage, S_IRUGO, axp20x_read_int, NULL);
+static struct kobj_attribute ac_in_amperage = __ATTR(amperage, S_IRUGO, axp20x_read_int, NULL);
+static struct kobj_attribute ac_in_connected = __ATTR(connected, S_IRUGO, axp20x_read_bool, NULL);
+static struct kobj_attribute ac_in_used = __ATTR(used, S_IRUGO, axp20x_read_bool, NULL);
+
+static struct attribute *axp20x_attributes_ac[] = {
+	&ac_in_voltage.attr,
+	&ac_in_amperage.attr,
+	&ac_in_connected.attr,
+	&ac_in_used.attr,
+	NULL,
+};
+
+static const struct attribute_group axp20x_group_ac = {
+	.attrs = axp20x_attributes_ac,
+};
+
+/* Vbus */
+static struct kobj_attribute vbus_voltage = __ATTR(voltage, S_IRUGO, axp20x_read_int, NULL);
+static struct kobj_attribute vbus_amperage = __ATTR(amperage, S_IRUGO, axp20x_read_int, NULL);
+static struct kobj_attribute vbus_connected = __ATTR(connected, S_IRUGO, axp20x_read_bool, NULL);
+static struct kobj_attribute vbus_used = __ATTR(used, S_IRUGO, axp20x_read_bool, NULL);
+static struct kobj_attribute vbus_strong = __ATTR(strong, S_IRUGO, axp20x_read_bool, NULL);
+
+static struct attribute *axp20x_attributes_vbus[] = {
+	&vbus_voltage.attr,
+	&vbus_amperage.attr,
+	&vbus_connected.attr,
+	&vbus_used.attr,
+	&vbus_strong.attr,
+	NULL,
+};
+
+static const struct attribute_group axp20x_group_vbus = {
+	.attrs = axp20x_attributes_vbus,
+};
+
+/* Battery */
+static struct kobj_attribute batt_voltage = __ATTR(voltage, S_IRUGO, axp20x_read_int, NULL);
+static struct kobj_attribute batt_amperage = __ATTR(amperage, S_IRUGO, axp20x_read_int, NULL);
+static struct kobj_attribute batt_ts_voltage = __ATTR(ts_voltage, S_IRUGO, axp20x_read_int, NULL);
+static struct kobj_attribute batt_power = __ATTR(power, S_IRUGO, axp20x_read_special, NULL);
+static struct kobj_attribute batt_charge = __ATTR(charge, S_IRUGO, axp20x_read_special, NULL);
+static struct kobj_attribute batt_capacity = __ATTR(capacity, S_IRUGO, axp20x_read_special, NULL);
+static struct kobj_attribute batt_connected = __ATTR(connected, S_IRUGO, axp20x_read_bool, NULL);
+static struct kobj_attribute batt_charging = __ATTR(charging, S_IRUGO, axp20x_read_bool, NULL);
+
+static struct attribute *axp20x_attributes_battery[] = {
+	&batt_voltage.attr,
+	&batt_amperage.attr,
+	&batt_ts_voltage.attr,
+	&batt_power.attr,
+	&batt_charge.attr,
+	&batt_capacity.attr,
+	&batt_connected.attr,
+	&batt_charging.attr,
+	NULL,
+};
+
+static const struct attribute_group axp20x_group_battery = {
+	.attrs = axp20x_attributes_battery,
+};
+
+/* PMU */
+static struct kobj_attribute pmu_temp = __ATTR(temp, S_IRUGO, axp20x_read_int, NULL);
+static struct kobj_attribute pmu_voltage = __ATTR(voltage, S_IRUGO, axp20x_read_int, NULL);
+static struct kobj_attribute pmu_overheat = __ATTR(overheat, S_IRUGO, axp20x_read_bool, NULL);
+
+static struct attribute *axp20x_attributes_pmu[] = {
+	&pmu_temp.attr,
+	&pmu_voltage.attr,
+	&pmu_overheat.attr,
+	NULL,
+};
+
+static const struct attribute_group axp20x_group_pmu = {
+	.attrs = axp20x_attributes_pmu,
+};
+
+/* Charger */
+static struct kobj_attribute charger_amperage = __ATTR(amperage, S_IRUGO, axp20x_read_int, NULL);
+static struct kobj_attribute charger_charging = __ATTR(charging, S_IRUGO, axp20x_read_bool, NULL);
+static struct kobj_attribute charger_cell_activation = __ATTR(cell_activation, S_IRUGO, axp20x_read_bool, NULL);
+static struct kobj_attribute charger_low_power = __ATTR(low_power, S_IRUGO, axp20x_read_bool, NULL);
+
+static struct attribute *axp20x_attributes_charger[] = {
+	&charger_amperage.attr,
+	&charger_charging.attr,
+	&charger_cell_activation.attr,
+	&charger_low_power.attr,
+	NULL,
+};
+
+static const struct attribute_group axp20x_group_charger = {
+	.attrs = axp20x_attributes_charger,
+};
+
+/* Control (writeable) */
+static struct kobj_attribute control_vbus_direct_mode = __ATTR(set_vbus_direct_mode, (S_IRUGO | S_IWUSR),
+	axp20x_read_bool, axp20x_write_bool);
+static struct kobj_attribute control_reset_charge_counter = __ATTR(reset_charge_counter, (S_IRUGO | S_IWUSR),
+	axp20x_read_bool, axp20x_write_bool);
+static struct kobj_attribute control_charge_rtc_battery = __ATTR(charge_rtc_battery, (S_IRUGO | S_IWUSR),
+	axp20x_read_bool, axp20x_write_bool);
+static struct kobj_attribute control_disable_fuel_gauge = __ATTR(disable_fuel_gauge, (S_IRUGO | S_IWUSR),
+	axp20x_read_bool, axp20x_write_bool);
+static struct kobj_attribute control_battery_rdc = __ATTR(battery_rdc, (S_IRUGO | S_IWUSR),
+	axp20x_read_int, axp20x_write_int);
+
+static struct attribute *axp20x_attributes_control[] = {
+	&control_vbus_direct_mode.attr,
+	&control_reset_charge_counter.attr,
+	&control_charge_rtc_battery.attr,
+	&control_disable_fuel_gauge.attr,
+	&control_battery_rdc.attr,
+	NULL,
+};
+
+static const struct attribute_group axp20x_group_control = {
+	.attrs = axp20x_attributes_control,
+};
+
+static struct {
+	struct kobject *ac;
+	struct kobject *vbus;
+	struct kobject *battery;
+	struct kobject *pmu;
+	struct kobject *charger;
+	struct kobject *control;
+} subsystems;
+
+static struct bin_attribute axp20x_ocv_curve = __BIN_ATTR(ocv_curve, S_IRUGO | S_IWUSR,
+	axp20x_sysfs_read_bin_file, axp20x_sysfs_write_bin_file, AXP20X_OCV_MAX + 1);
+
+static void axp20x_sysfs_create_subgroup(const char name[], struct axp20x_dev *axp,
+	struct kobject *subgroup, const struct attribute_group *attrs)
+{
+	int ret;
+	struct kobject *parent = &axp->dev->kobj;
+	subgroup = kobject_create_and_add(name, parent);
+	if (subgroup != NULL) {
+		ret = sysfs_create_group(subgroup, attrs);
+		if (ret) {
+			dev_warn(axp->dev, "Unable to register sysfs group: %s: %d", name, ret);
+			kobject_put(subgroup);
+		}
+	}
+}
+
+static void axp20x_sysfs_remove_subgroup(struct kobject *subgroup,
+	const struct attribute_group *attrs)
+{
+	sysfs_remove_group(subgroup, attrs);
+	kobject_put(subgroup);
+}
+
+static int axp20x_sysfs_init(struct axp20x_dev *axp)
+{
+	int ret;
+	unsigned int res;
+
+	/* Enable all ADC channels in the first register */
+	ret = regmap_write(axp->regmap, AXP20X_ADC_EN1, 0xFF);
+	if (ret)
+		dev_warn(axp->dev, "Unable to enable ADC: %d", ret);
+
+	/*
+	 * Set ADC sampling frequency to 100Hz (default is 25)
+	 * Always measure battery temperature (default: only when charging)
+	 */
+	ret = regmap_update_bits(axp->regmap, AXP20X_ADC_RATE, 0xC3, 0x82);
+	if (ret)
+		dev_warn(axp->dev, "Unable to set ADC frequency and TS current output: %d", ret);
+
+	/* Enable fuel gauge and charge counter */
+	ret = regmap_update_bits(axp->regmap, AXP20X_FG_RES, 0x80, 0x00);
+	if (ret)
+		dev_warn(axp->dev, "Unable to enable battery fuel gauge: %d", ret);
+	/* ret = regmap_update_bits(axp->regmap, AXP20X_CC_CTRL, 0xC0, 0x00); */
+	ret |= regmap_update_bits(axp->regmap, AXP20X_CC_CTRL, 0xC0, 0x80);
+	if (ret)
+		dev_warn(axp->dev, "Unable to enable battery charge counter: %d", ret);
+
+	/* Enable battery detection */
+	ret = regmap_read(axp->regmap, AXP20X_OFF_CTRL, &res);
+	if (ret == 0) {
+		if ((res & 0x40) != 0x40) {
+			dev_info(axp->dev, "Battery detection is disabled, enabling");
+			ret = regmap_update_bits(axp->regmap, AXP20X_OFF_CTRL, 0x40, 0x40);
+			if (ret)
+				dev_warn(axp->dev, "Unable to enable battery detection: %d", ret);
+		}
+	} else
+		dev_warn(axp->dev, "Unable to read register AXP20X_OFF_CTRL: %d", ret);
+
+	/* Get info about backup (RTC) battery */
+	ret = regmap_read(axp->regmap, AXP20X_CHRG_BAK_CTRL, &res);
+	if (ret == 0) {
+		dev_info(axp->dev, "Backup (RTC) battery charging is %s",
+			(res & 0x80) == 0x80 ? "enabled" : "disabled");
+		if ((res & 0x60) != 0x20)
+			dev_warn(axp->dev, "Backup (RTC) battery target voltage is not 3.0V");
+	} else
+		dev_warn(axp->dev, "Unable to read register AXP20X_CHRG_BAK_CTRL: %d", ret);
+
+	axp20x_sysfs_create_subgroup("ac", axp, subsystems.ac, &axp20x_group_ac);
+	axp20x_sysfs_create_subgroup("vbus", axp, subsystems.vbus, &axp20x_group_vbus);
+	axp20x_sysfs_create_subgroup("battery", axp, subsystems.battery, &axp20x_group_battery);
+	axp20x_sysfs_create_subgroup("pmu", axp, subsystems.pmu, &axp20x_group_pmu);
+	axp20x_sysfs_create_subgroup("charger", axp, subsystems.charger, &axp20x_group_charger);
+	axp20x_sysfs_create_subgroup("control", axp, subsystems.control, &axp20x_group_control);
+
+	ret = sysfs_create_bin_file(&axp->dev->kobj, &axp20x_ocv_curve);
+	if (ret)
+		dev_warn(axp->dev, "Unable to create sysfs ocv_curve file: %d", ret);
+
+	ret = sysfs_create_link_nowarn(power_kobj, &axp->dev->kobj, "axp_pmu");
+	if (ret)
+		dev_warn(axp->dev, "Unable to create sysfs symlink: %d", ret);
+	return ret;
+}
+
+static void axp20x_sysfs_exit(struct axp20x_dev *axp)
+{
+	sysfs_delete_link(power_kobj, &axp->dev->kobj, "axp_pmu");
+	sysfs_remove_bin_file(&axp->dev->kobj, &axp20x_ocv_curve);
+	axp20x_sysfs_remove_subgroup(subsystems.control, &axp20x_group_control);
+	axp20x_sysfs_remove_subgroup(subsystems.charger, &axp20x_group_charger);
+	axp20x_sysfs_remove_subgroup(subsystems.pmu, &axp20x_group_pmu);
+	axp20x_sysfs_remove_subgroup(subsystems.battery, &axp20x_group_battery);
+	axp20x_sysfs_remove_subgroup(subsystems.vbus, &axp20x_group_vbus);
+	axp20x_sysfs_remove_subgroup(subsystems.ac, &axp20x_group_ac);
+}
+
 int axp20x_match_device(struct axp20x_dev *axp20x)
 {
 	struct device *dev = axp20x->dev;
@@ -1005,6 +1654,10 @@
 		pm_power_off = axp20x_power_off;
 	}
 
+	if (axp20x->variant == AXP209_ID || axp20x->variant == AXP202_ID) {
+		axp20x_sysfs_init(axp20x);
+	}
+
 	dev_info(axp20x->dev, "AXP20X driver loaded\n");
 
 	return 0;
@@ -1018,6 +1671,10 @@
 		pm_power_off = NULL;
 	}
 
+	if (axp20x->variant == AXP209_ID || axp20x->variant == AXP202_ID) {
+		axp20x_sysfs_exit(axp20x);
+	}
+
 	mfd_remove_devices(axp20x->dev);
 	regmap_del_irq_chip(axp20x->irq, axp20x->regmap_irqc);
 }
diff -Nuar -r --no-dereference linux-5.15.139/drivers/pwm/pwm-sun4i.c linux/drivers/pwm/pwm-sun4i.c
--- linux-5.15.139/drivers/pwm/pwm-sun4i.c	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/pwm/pwm-sun4i.c	2024-01-03 16:06:25.935131000 +0800
@@ -89,7 +89,6 @@
 	void __iomem *base;
 	spinlock_t ctrl_lock;
 	const struct sun4i_pwm_data *data;
-	unsigned long next_period[2];
 };
 
 static inline struct sun4i_pwm_chip *to_sun4i_pwm_chip(struct pwm_chip *chip)
@@ -228,6 +227,20 @@
 	return 0;
 }
 
+static void sun4i_pwm_wait(unsigned long next_period) {
+	unsigned int delay_us;
+	unsigned long now;
+
+	now = jiffies;
+	if (time_before(now, next_period)) {
+		delay_us = jiffies_to_usecs(next_period - now);
+		if ((delay_us / 500) > MAX_UDELAY_MS)
+			msleep(delay_us / 1000 + 1);
+		else
+			usleep_range(delay_us, delay_us * 2);
+	}
+}
+
 static int sun4i_pwm_apply(struct pwm_chip *chip, struct pwm_device *pwm,
 			   const struct pwm_state *state)
 {
@@ -235,8 +248,8 @@
 	struct pwm_state cstate;
 	u32 ctrl, duty = 0, period = 0, val;
 	int ret;
-	unsigned int delay_us, prescaler = 0;
-	unsigned long now;
+	unsigned int prescaler = 0;
+	unsigned long next_period;
 	bool bypass;
 
 	pwm_get_state(pwm, &cstate);
@@ -284,8 +297,7 @@
 
 	val = (duty & PWM_DTY_MASK) | PWM_PRD(period);
 	sun4i_pwm_writel(sun4i_pwm, val, PWM_CH_PRD(pwm->hwpwm));
-	sun4i_pwm->next_period[pwm->hwpwm] = jiffies +
-		nsecs_to_jiffies(cstate.period + 1000);
+	next_period = jiffies + nsecs_to_jiffies(cstate.period + 1000);
 
 	if (state->polarity != PWM_POLARITY_NORMAL)
 		ctrl &= ~BIT_CH(PWM_ACT_STATE, pwm->hwpwm);
@@ -305,15 +317,7 @@
 		return 0;
 
 	/* We need a full period to elapse before disabling the channel. */
-	now = jiffies;
-	if (time_before(now, sun4i_pwm->next_period[pwm->hwpwm])) {
-		delay_us = jiffies_to_usecs(sun4i_pwm->next_period[pwm->hwpwm] -
-					   now);
-		if ((delay_us / 500) > MAX_UDELAY_MS)
-			msleep(delay_us / 1000 + 1);
-		else
-			usleep_range(delay_us, delay_us * 2);
-	}
+	sun4i_pwm_wait(next_period);
 
 	spin_lock(&sun4i_pwm->ctrl_lock);
 	ctrl = sun4i_pwm_readl(sun4i_pwm, PWM_CTRL_REG);
diff -Nuar -r --no-dereference linux-5.15.139/drivers/soc/sunxi/sunxi_sram.c linux/drivers/soc/sunxi/sunxi_sram.c
--- linux-5.15.139/drivers/soc/sunxi/sunxi_sram.c	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/soc/sunxi/sunxi_sram.c	2024-01-03 16:06:25.935131000 +0800
@@ -70,6 +70,12 @@
 				  SUNXI_SRAM_MAP(0x7fffffff, 1, "ve")),
 };
 
+static struct sunxi_sram_desc sun50i_h616_sram_c1 = {
+	.data	= SUNXI_SRAM_DATA("C1", 0x0, 0x0, 31,
+				  SUNXI_SRAM_MAP(0x7fffffff, 0, "cpu"),
+				  SUNXI_SRAM_MAP(0, 1, "ve")),
+};
+
 static struct sunxi_sram_desc sun4i_a10_sram_d = {
 	.data	= SUNXI_SRAM_DATA("D", 0x4, 0x0, 1,
 				  SUNXI_SRAM_MAP(0, 0, "cpu"),
@@ -99,6 +105,10 @@
 		.compatible	= "allwinner,sun50i-a64-sram-c",
 		.data		= &sun50i_a64_sram_c.data,
 	},
+	{
+		.compatible	= "allwinner,sun50i-h616-sram-c1",
+		.data		= &sun50i_h616_sram_c1.data,
+	},
 	{}
 };
 
diff -Nuar -r --no-dereference linux-5.15.139/drivers/mmc/core/mmc.c linux/drivers/mmc/core/mmc.c
--- linux-5.15.139/drivers/mmc/core/mmc.c	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/mmc/core/mmc.c	2024-01-03 16:06:25.935131000 +0800
@@ -1813,6 +1813,8 @@
 	 */
 	mmc_select_powerclass(card);
 
+	msleep(20);
+
 	/*
 	 * Enable HPI feature (if supported)
 	 */
@@ -1831,6 +1833,8 @@
 		}
 	}
 
+	msleep(20);
+
 	/*
 	 * If cache size is higher than 0, this indicates the existence of cache
 	 * and it can be turned on. Note that some eMMCs from Micron has been
diff -Nuar -r --no-dereference linux-5.15.139/drivers/mmc/host/sunxi-mmc.c linux/drivers/mmc/host/sunxi-mmc.c
--- linux-5.15.139/drivers/mmc/host/sunxi-mmc.c	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/mmc/host/sunxi-mmc.c	2024-01-03 16:06:25.935131000 +0800
@@ -949,9 +949,15 @@
 {
 	struct sunxi_mmc_host *host = mmc_priv(mmc);
 
+	if (ios->power_mode == MMC_POWER_OFF)
+		sunxi_mmc_reset_host(host);
+
 	sunxi_mmc_card_power(host, ios);
 	sunxi_mmc_set_bus_width(host, ios->bus_width);
 	sunxi_mmc_set_clk(host, ios);
+
+	if (ios->power_mode == MMC_POWER_UP)
+		sunxi_mmc_init_host(host);
 }
 
 static int sunxi_mmc_volt_switch(struct mmc_host *mmc, struct mmc_ios *ios)
@@ -977,8 +983,8 @@
 	unsigned long flags;
 	u32 imask;
 
-	if (enable)
-		pm_runtime_get_noresume(host->dev);
+	//if (enable)
+		//pm_runtime_get_noresume(host->dev);
 
 	spin_lock_irqsave(&host->lock, flags);
 
@@ -993,8 +999,8 @@
 	mmc_writel(host, REG_IMASK, imask);
 	spin_unlock_irqrestore(&host->lock, flags);
 
-	if (!enable)
-		pm_runtime_put_noidle(host->mmc->parent);
+	//if (!enable)
+		//pm_runtime_put_noidle(host->mmc->parent);
 }
 
 static void sunxi_mmc_hw_reset(struct mmc_host *mmc)
@@ -1200,6 +1206,13 @@
 	.needs_new_timings = true,
 };
 
+static const struct sunxi_mmc_cfg sun50i_h5_emmc_cfg = {
+	.idma_des_size_bits = 13,
+	.clk_delays = NULL,
+	.can_calibrate = true,
+	.needs_new_timings = false,
+};
+
 static const struct of_device_id sunxi_mmc_of_match[] = {
 	{ .compatible = "allwinner,sun4i-a10-mmc", .data = &sun4i_a10_cfg },
 	{ .compatible = "allwinner,sun5i-a13-mmc", .data = &sun5i_a13_cfg },
@@ -1208,6 +1221,8 @@
 	{ .compatible = "allwinner,sun9i-a80-mmc", .data = &sun9i_a80_cfg },
 	{ .compatible = "allwinner,sun50i-a64-mmc", .data = &sun50i_a64_cfg },
 	{ .compatible = "allwinner,sun50i-a64-emmc", .data = &sun50i_a64_emmc_cfg },
+	{ .compatible = "allwinner,sun50i-h5-emmc", .data = &sun50i_h5_emmc_cfg },
+	{ .compatible = "allwinner,sun50i-h6-emmc", .data = &sun50i_a64_emmc_cfg },
 	{ .compatible = "allwinner,sun50i-a100-mmc", .data = &sun50i_a100_cfg },
 	{ .compatible = "allwinner,sun50i-a100-emmc", .data = &sun50i_a100_emmc_cfg },
 	{ /* sentinel */ }
@@ -1421,7 +1436,7 @@
 				  MMC_CAP_SDIO_IRQ;
 
 	/*
-	 * Some H5 devices do not have signal traces precise enough to
+	 * Some H5 and H6 devices do not have signal traces precise enough to
 	 * use HS DDR mode for their eMMC chips.
 	 *
 	 * We still enable HS DDR modes for all the other controller
@@ -1429,7 +1444,11 @@
 	 */
 	if ((host->cfg->clk_delays || host->use_new_timings) &&
 	    !of_device_is_compatible(pdev->dev.of_node,
-				     "allwinner,sun50i-h5-emmc"))
+				     "allwinner,sun50i-h5-emmc") &&
+	    !of_device_is_compatible(pdev->dev.of_node,
+				     "allwinner,sun50i-h6-emmc") &&
+	    !of_machine_is_compatible("allwinner,sun7i-a20") &&
+	    !of_machine_is_compatible("olimex,a64-olinuxino-2ge8g"))
 		mmc->caps      |= MMC_CAP_1_8V_DDR | MMC_CAP_3_3V_DDR;
 
 	ret = mmc_of_parse(mmc);
@@ -1455,10 +1474,10 @@
 	if (ret)
 		goto error_free_dma;
 
-	pm_runtime_set_active(&pdev->dev);
-	pm_runtime_set_autosuspend_delay(&pdev->dev, 50);
-	pm_runtime_use_autosuspend(&pdev->dev);
-	pm_runtime_enable(&pdev->dev);
+	//pm_runtime_set_active(&pdev->dev);
+	//pm_runtime_set_autosuspend_delay(&pdev->dev, 50);
+	//pm_runtime_use_autosuspend(&pdev->dev);
+	//pm_runtime_enable(&pdev->dev);
 
 	ret = mmc_add_host(mmc);
 	if (ret)
@@ -1483,11 +1502,11 @@
 	struct sunxi_mmc_host *host = mmc_priv(mmc);
 
 	mmc_remove_host(mmc);
-	pm_runtime_disable(&pdev->dev);
-	if (!pm_runtime_status_suspended(&pdev->dev)) {
+	//pm_runtime_disable(&pdev->dev);
+	//if (!pm_runtime_status_suspended(&pdev->dev)) {
 		disable_irq(host->irq);
 		sunxi_mmc_disable(host);
-	}
+	//}
 	dma_free_coherent(&pdev->dev, PAGE_SIZE, host->sg_cpu, host->sg_dma);
 	mmc_free_host(mmc);
 
@@ -1524,7 +1543,6 @@
 	 * Disabling the irq  will prevent this.
 	 */
 	disable_irq(host->irq);
-	sunxi_mmc_reset_host(host);
 	sunxi_mmc_disable(host);
 
 	return 0;
@@ -1532,8 +1550,6 @@
 #endif
 
 static const struct dev_pm_ops sunxi_mmc_pm_ops = {
-	SET_SYSTEM_SLEEP_PM_OPS(pm_runtime_force_suspend,
-				pm_runtime_force_resume)
 	SET_RUNTIME_PM_OPS(sunxi_mmc_runtime_suspend,
 			   sunxi_mmc_runtime_resume,
 			   NULL)
@@ -1543,8 +1559,8 @@
 	.driver = {
 		.name	= "sunxi-mmc",
 		.probe_type = PROBE_PREFER_ASYNCHRONOUS,
-		.of_match_table = sunxi_mmc_of_match,
-		.pm = &sunxi_mmc_pm_ops,
+		.of_match_table = of_match_ptr(sunxi_mmc_of_match),
+		//.pm = &sunxi_mmc_pm_ops,
 	},
 	.probe		= sunxi_mmc_probe,
 	.remove		= sunxi_mmc_remove,
diff -Nuar -r --no-dereference linux-5.15.139/drivers/mmc/host/sdhci-of-arasan.c linux/drivers/mmc/host/sdhci-of-arasan.c
--- linux-5.15.139/drivers/mmc/host/sdhci-of-arasan.c	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/mmc/host/sdhci-of-arasan.c	2024-01-03 16:06:25.935131000 +0800
@@ -19,6 +19,7 @@
 #include <linux/mfd/syscon.h>
 #include <linux/module.h>
 #include <linux/of_device.h>
+#include <linux/pm_runtime.h>
 #include <linux/phy/phy.h>
 #include <linux/regmap.h>
 #include <linux/of.h>
@@ -28,6 +29,7 @@
 #include "sdhci-cqhci.h"
 #include "sdhci-pltfm.h"
 
+#define SDHCI_ARASAN_AUTOSUSPEND_DELAY	2000 /* ms */
 #define SDHCI_ARASAN_VENDOR_REGISTER	0x78
 
 #define SDHCI_ARASAN_ITAPDLY_REGISTER	0xF0F8
@@ -457,6 +459,70 @@
 			SDHCI_QUIRK2_CLOCK_DIV_ZERO_BROKEN,
 };
 
+#ifdef CONFIG_PM
+static int sdhci_arasan_runtime_suspend(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct sdhci_host *host = platform_get_drvdata(pdev);
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_arasan_data *sdhci_arasan = sdhci_pltfm_priv(pltfm_host);
+	int ret;
+
+	if (sdhci_arasan->has_cqe) {
+		ret = cqhci_suspend(host->mmc);
+		if (ret)
+			return ret;
+	}
+
+	ret = sdhci_runtime_suspend_host(host);
+	if (ret)
+		return ret;
+
+	if (host->tuning_mode != SDHCI_TUNING_MODE_3)
+		mmc_retune_needed(host->mmc);
+
+	clk_disable(pltfm_host->clk);
+	clk_disable(sdhci_arasan->clk_ahb);
+
+	return 0;
+}
+
+static int sdhci_arasan_runtime_resume(struct device *dev)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct sdhci_host *host = platform_get_drvdata(pdev);
+	struct sdhci_pltfm_host *pltfm_host = sdhci_priv(host);
+	struct sdhci_arasan_data *sdhci_arasan = sdhci_pltfm_priv(pltfm_host);
+	int ret;
+
+	ret = clk_enable(sdhci_arasan->clk_ahb);
+	if (ret) {
+		dev_err(dev, "Cannot enable AHB clock.\n");
+		return ret;
+	}
+
+	ret = clk_enable(pltfm_host->clk);
+	if (ret) {
+		dev_err(dev, "Cannot enable SD clock.\n");
+		return ret;
+	}
+
+	ret = sdhci_runtime_resume_host(host, 0);
+	if (ret)
+		goto out;
+
+	if (sdhci_arasan->has_cqe)
+		return cqhci_resume(host->mmc);
+
+	return 0;
+out:
+	clk_disable(pltfm_host->clk);
+	clk_disable(sdhci_arasan->clk_ahb);
+
+	return ret;
+}
+#endif /* ! CONFIG_PM */
+
 #ifdef CONFIG_PM_SLEEP
 /**
  * sdhci_arasan_suspend - Suspend method for the driver
@@ -553,8 +619,10 @@
 }
 #endif /* ! CONFIG_PM_SLEEP */
 
-static SIMPLE_DEV_PM_OPS(sdhci_arasan_dev_pm_ops, sdhci_arasan_suspend,
-			 sdhci_arasan_resume);
+static const struct dev_pm_ops sdhci_arasan_dev_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(sdhci_arasan_suspend, sdhci_arasan_resume)
+	SET_RUNTIME_PM_OPS(sdhci_arasan_runtime_suspend,
+			   sdhci_arasan_runtime_resume, NULL) };
 
 /**
  * sdhci_arasan_sdcardclk_recalc_rate - Return the card clock rate
@@ -1682,13 +1750,25 @@
 			host->mmc->caps2 |= MMC_CAP2_CQE_DCMD;
 	}
 
+	pm_runtime_get_noresume(&pdev->dev);
+	pm_runtime_set_active(&pdev->dev);
+	pm_runtime_enable(&pdev->dev);
+	pm_runtime_set_autosuspend_delay(&pdev->dev,
+					 SDHCI_ARASAN_AUTOSUSPEND_DELAY);
+	pm_runtime_use_autosuspend(&pdev->dev);
+
 	ret = sdhci_arasan_add_host(sdhci_arasan);
 	if (ret)
 		goto err_add_host;
 
+	pm_runtime_put_autosuspend(&pdev->dev);
+
 	return 0;
 
 err_add_host:
+	pm_runtime_disable(&pdev->dev);
+	pm_runtime_set_suspended(&pdev->dev);
+	pm_runtime_put_noidle(&pdev->dev);
 	if (!IS_ERR(sdhci_arasan->phy))
 		phy_exit(sdhci_arasan->phy);
 unreg_clk:
@@ -1716,6 +1796,10 @@
 		phy_exit(sdhci_arasan->phy);
 	}
 
+	pm_runtime_get_sync(&pdev->dev);
+	pm_runtime_disable(&pdev->dev);
+	pm_runtime_put_noidle(&pdev->dev);
+
 	sdhci_arasan_unregister_sdclk(&pdev->dev);
 
 	ret = sdhci_pltfm_unregister(pdev);
diff -Nuar -r --no-dereference linux-5.15.139/drivers/clk/clk.c linux/drivers/clk/clk.c
--- linux-5.15.139/drivers/clk/clk.c	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/clk/clk.c	2024-01-03 16:06:25.935131000 +0800
@@ -4338,6 +4338,37 @@
 EXPORT_SYMBOL_GPL(devm_clk_hw_get_clk);
 
 /*
+ * clk-conf helpers
+ */
+
+int __clk_protect(struct clk *clk)
+{
+	struct clk_core *core = clk->core;
+	int ret = 0;
+
+	clk_prepare_lock();
+
+	/*
+	 * If CLK_IS_CRITICAL was set in the clock's init data, then
+	 * the clock was already prepared/enabled when it was added.
+	 */
+	if (core->flags & CLK_IS_CRITICAL)
+		goto out;
+
+	core->flags |= CLK_IS_CRITICAL;
+	ret = clk_core_prepare(core);
+	if (ret)
+		goto out;
+
+	ret = clk_core_enable_lock(core);
+
+out:
+	clk_prepare_unlock();
+
+	return ret;
+}
+
+/*
  * clkdev helpers
  */
 
diff -Nuar -r --no-dereference linux-5.15.139/drivers/clk/clk.h linux/drivers/clk/clk.h
--- linux-5.15.139/drivers/clk/clk.h	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/clk/clk.h	2024-01-03 16:06:25.935131000 +0800
@@ -24,6 +24,7 @@
 #ifdef CONFIG_COMMON_CLK
 struct clk *clk_hw_create_clk(struct device *dev, struct clk_hw *hw,
 			      const char *dev_id, const char *con_id);
+int __clk_protect(struct clk *clk);
 void __clk_put(struct clk *clk);
 #else
 /* All these casts to avoid ifdefs in clkdev... */
@@ -33,6 +34,7 @@
 {
 	return (struct clk *)hw;
 }
+static inline int __clk_protect(struct clk *clk) { return 0; }
 static inline void __clk_put(struct clk *clk) { }
 
 #endif
diff -Nuar -r --no-dereference linux-5.15.139/drivers/clk/clk-conf.c linux/drivers/clk/clk-conf.c
--- linux-5.15.139/drivers/clk/clk-conf.c	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/clk/clk-conf.c	2024-01-03 16:06:25.935131000 +0800
@@ -11,6 +11,54 @@
 #include <linux/of.h>
 #include <linux/printk.h>
 
+#include "clk.h"
+
+static int __set_clk_flags(struct device_node *node)
+{
+	struct of_phandle_args clkspec;
+	struct property *prop;
+	int i, index = 0, rc;
+	const __be32 *cur;
+	struct clk *clk;
+	u32 nr_cells;
+
+	rc = of_property_read_u32(node, "#clock-cells", &nr_cells);
+	if (rc < 0) {
+		pr_err("clk: missing #clock-cells property on %pOF\n", node);
+		return rc;
+	}
+
+	clkspec.np         = node;
+	clkspec.args_count = nr_cells;
+
+	of_property_for_each_u32(node, "protected-clocks", prop, cur, clkspec.args[0]) {
+		/* read the remainder of the clock specifier */
+		for (i = 1; i < nr_cells; ++i) {
+			cur = of_prop_next_u32(prop, cur, &clkspec.args[i]);
+			if (!cur) {
+				pr_err("clk: invalid value of protected-clocks"
+				       " property at %pOF\n", node);
+				return -EINVAL;
+			}
+		}
+		clk = of_clk_get_from_provider(&clkspec);
+		if (IS_ERR(clk)) {
+			if (PTR_ERR(clk) != -EPROBE_DEFER)
+				pr_err("clk: couldn't get protected clock"
+				       " %u for %pOF\n", index, node);
+			return PTR_ERR(clk);
+		}
+
+		rc = __clk_protect(clk);
+		if (rc < 0)
+			pr_warn("clk: failed to protect %s: %d\n",
+				__clk_get_name(clk), rc);
+		clk_put(clk);
+		index++;
+	}
+	return 0;
+}
+
 static int __set_clk_parents(struct device_node *node, bool clk_supplier)
 {
 	struct of_phandle_args clkspec;
@@ -143,6 +191,12 @@
 	if (!node)
 		return 0;
 
+	if (clk_supplier) {
+		rc = __set_clk_flags(node);
+		if (rc < 0)
+			return rc;
+	}
+
 	rc = __set_clk_parents(node, clk_supplier);
 	if (rc < 0)
 		return rc;
diff -Nuar -r --no-dereference linux-5.15.139/drivers/clk/sunxi-ng/ccu-sun50i-a64.h linux/drivers/clk/sunxi-ng/ccu-sun50i-a64.h
--- linux-5.15.139/drivers/clk/sunxi-ng/ccu-sun50i-a64.h	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/clk/sunxi-ng/ccu-sun50i-a64.h	2024-01-03 16:06:25.935131000 +0800
@@ -51,8 +51,6 @@
 
 #define CLK_USB_OHCI1_12M		92
 
-#define CLK_DRAM			94
-
 /* All the DRAM gates are exported */
 
 /* And the DSI and GPU module clock is exported */
diff -Nuar -r --no-dereference linux-5.15.139/drivers/clk/sunxi-ng/ccu-sun8i-h3.h linux/drivers/clk/sunxi-ng/ccu-sun8i-h3.h
--- linux-5.15.139/drivers/clk/sunxi-ng/ccu-sun8i-h3.h	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/clk/sunxi-ng/ccu-sun8i-h3.h	2024-01-03 16:06:25.935131000 +0800
@@ -42,8 +42,6 @@
 
 /* The first bunch of module clocks are exported */
 
-#define CLK_DRAM		96
-
 /* All the DRAM gates are exported */
 
 /* Some more module clocks are exported */
diff -Nuar -r --no-dereference linux-5.15.139/drivers/clk/sunxi-ng/ccu_common.c linux/drivers/clk/sunxi-ng/ccu_common.c
--- linux-5.15.139/drivers/clk/sunxi-ng/ccu_common.c	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/clk/sunxi-ng/ccu_common.c	2024-01-03 16:06:25.935131000 +0800
@@ -194,6 +194,28 @@
 	return 0;
 }
 
+static int ccu_rate_reset_notifier_cb(struct notifier_block *nb,
+				      unsigned long event, void *data)
+{
+	struct ccu_rate_reset_nb *rate_reset = to_ccu_rate_reset_nb(nb);
+
+	if (event == PRE_RATE_CHANGE) {
+		rate_reset->saved_rate = clk_get_rate(rate_reset->target_clk);
+	} else if (event == POST_RATE_CHANGE) {
+		clk_set_rate(rate_reset->target_clk, rate_reset->saved_rate);
+	}
+
+	return NOTIFY_DONE;
+}
+
+int ccu_rate_reset_notifier_register(struct ccu_rate_reset_nb *rate_reset_nb)
+{
+	rate_reset_nb->clk_nb.notifier_call = ccu_rate_reset_notifier_cb;
+
+	return clk_notifier_register(rate_reset_nb->common->hw.clk,
+				     &rate_reset_nb->clk_nb);
+}
+
 void of_sunxi_ccu_probe(struct device_node *node, void __iomem *reg,
 			const struct sunxi_ccu_desc *desc)
 {
diff -Nuar -r --no-dereference linux-5.15.139/drivers/clk/sunxi-ng/ccu-sun50i-a64.c linux/drivers/clk/sunxi-ng/ccu-sun50i-a64.c
--- linux-5.15.139/drivers/clk/sunxi-ng/ccu-sun50i-a64.c	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/clk/sunxi-ng/ccu-sun50i-a64.c	2024-01-03 16:06:25.935131000 +0800
@@ -47,15 +47,35 @@
  * With sigma-delta modulation for fractional-N on the audio PLL,
  * we have to use specific dividers. This means the variable divider
  * can no longer be used, as the audio codec requests the exact clock
- * rates we support through this mechanism. So we now hard code the
- * variable divider to 1. This means the clock rates will no longer
- * match the clock names.
+ * rates we support through this mechanism.
+ *
+ * For the audio codec to work correctly, pll-audio must be exactly
+ * 22579200 Hz or 24576000 Hz, and pll-audio-4x (1x the base) must be
+ * between 3x and 8x that frequency. For the SRC to work at 96 kHz,
+ * pll-audio-4x must be at least 6x pll-audio.
+ *
+ * For now, hard code the variable divider to 3.
  */
 #define SUN50I_A64_PLL_AUDIO_REG	0x008
+#define SUN50I_A64_PLL_AUDIO_BIAS_REG	0x224
 
 static struct ccu_sdm_setting pll_audio_sdm_table[] = {
-	{ .rate = 22579200, .pattern = 0xc0010d84, .m = 8, .n = 7 },
-	{ .rate = 24576000, .pattern = 0xc000ac02, .m = 14, .n = 14 },
+	/* 24000000 * (  7 + 0x10d84 / 131072 ) /  8 / 1 - 22579200 == -6.9Hz */
+	{ .rate =  22579200, .pattern = 0xc0010d84, .m =  8, .n =  7 },
+	/* 24000000 * ( 14 + 0x0ac02 / 131072 ) / 14 / 1 - 24576000 == -2.5Hz */
+	{ .rate =  24576000, .pattern = 0xc000ac08, .m = 14, .n = 14 },
+	/* 24000000 * (  8 + 0x0ef35 / 131072 ) /  3 / 3 - 22579200 ==  3.3Hz */
+	{ .rate =  67737600, .pattern = 0xc000ef35, .m =  3, .n =  8 },
+	/* 24000000 * ( 15 + 0x0b852 / 131072 ) /  5 / 3 - 24576000 ==  1.0Hz */
+	{ .rate =  73728000, .pattern = 0xc000b852, .m =  5, .n = 15 },
+	/* 24000000 * (  7 + 0x10d84 / 131072 ) /  2 / 4 - 22579200 == -6.9Hz */
+	{ .rate =  90316800, .pattern = 0xc0010d84, .m =  2, .n =  7 },
+	/* 24000000 * ( 16 + 0x0c49c / 131072 ) /  4 / 4 - 24576000 ==  4.0Hz */
+	{ .rate =  98304000, .pattern = 0xc000c49c, .m =  4, .n = 16 },
+	/* 24000000 * (  5 + 0x14a23 / 131072 ) /  1 / 6 - 22579200 == -6.9Hz */
+	{ .rate = 135475200, .pattern = 0xc0014a23, .m =  1, .n =  5 },
+	/* 24000000 * ( 12 + 0x09375 / 131072 ) /  2 / 6 - 24576000 ==  4.0Hz */
+	{ .rate = 147456000, .pattern = 0xc0009375, .m =  2, .n = 12 },
 };
 
 static SUNXI_CCU_NM_WITH_SDM_GATE_LOCK(pll_audio_base_clk, "pll-audio-base",
@@ -176,6 +196,8 @@
 	.n		= _SUNXI_CCU_MULT(8, 4),
 	.k		= _SUNXI_CCU_MULT_MIN(4, 2, 2),
 	.m		= _SUNXI_CCU_DIV(0, 4),
+	.min_rate	= 300000000,
+	.max_rate	= 1400000000,
 	.common		= {
 		.reg		= 0x040,
 		.hw.init	= CLK_HW_INIT("pll-mipi", "pll-video0",
@@ -528,6 +550,16 @@
 				 0x104, 0, 4, 24, 3, BIT(31),
 				 CLK_SET_RATE_PARENT);
 
+#define SUN50I_A64_TCON0_REG	0x118
+
+/*
+ * When using PLL-Video0 as the parent of tcon0 clock, tcon0 clock will
+ * conflict with HDMI PHY clock (also a child of PLL-Video0) which is on
+ * another display pipeline. Force tcon0 to use PLL-MIPI as parent here
+ * to prevent this. As the parent of PLL-MIPI is still PLL-Video0, a notifier
+ * is required to restore the rate of TCON0 when the rate of PLL-Video0
+ * changed.
+ */
 static const char * const tcon0_parents[] = { "pll-mipi", "pll-video0-2x" };
 static const u8 tcon0_table[] = { 0, 2, };
 static SUNXI_CCU_MUX_TABLE_WITH_GATE(tcon0_clk, "tcon0", tcon0_parents,
@@ -604,10 +636,10 @@
 	&pll_audio_base_clk.common.hw
 };
 
-/* We hardcode the divider to 1 for now */
+/* We hardcode the divider to 3 for now */
 static CLK_FIXED_FACTOR_HWS(pll_audio_clk, "pll-audio",
 			    clk_parent_pll_audio,
-			    1, 1, CLK_SET_RATE_PARENT);
+			    3, 1, CLK_SET_RATE_PARENT);
 static CLK_FIXED_FACTOR_HWS(pll_audio_2x_clk, "pll-audio-2x",
 			    clk_parent_pll_audio,
 			    2, 1, CLK_SET_RATE_PARENT);
@@ -936,6 +968,12 @@
 	.bypass_index	= 1, /* index of 24 MHz oscillator */
 };
 
+static struct ccu_rate_reset_nb sun50i_a64_pll_video0_reset_tcon0_nb = {
+	.common		= &pll_video0_clk.common,
+};
+
+#define CCU_MIPI_DSI_CLK 0x168
+
 static int sun50i_a64_ccu_probe(struct platform_device *pdev)
 {
 	struct resource *res;
@@ -948,12 +986,29 @@
 	if (IS_ERR(reg))
 		return PTR_ERR(reg);
 
-	/* Force the PLL-Audio-1x divider to 1 */
+	/* Force the pll-audio variable divider to 3 */
 	val = readl(reg + SUN50I_A64_PLL_AUDIO_REG);
 	val &= ~GENMASK(19, 16);
-	writel(val | (0 << 16), reg + SUN50I_A64_PLL_AUDIO_REG);
+	writel(val | (2 << 16), reg + SUN50I_A64_PLL_AUDIO_REG);
 
-	writel(0x515, reg + SUN50I_A64_PLL_MIPI_REG);
+	/* Decrease the PLL AUDIO bias current to reduce noise. */
+	writel(0x10040000, reg + SUN50I_A64_PLL_AUDIO_BIAS_REG);
+
+	ret = of_property_read_u32_index(of_chosen, "p-boot,framebuffer-start", 0, &val);
+	if (ret) {
+		writel(0x515, reg + SUN50I_A64_PLL_MIPI_REG);
+
+		/* Set MIPI-DSI clock parent to periph0(1x), so that video0(1x) is free to change. */
+		val = readl(reg + CCU_MIPI_DSI_CLK);
+		val &= 0x30f;
+		val |= (2 << 8) | ((4 - 1) << 0); /* M-1 */
+		writel(val, reg + CCU_MIPI_DSI_CLK);
+	}
+
+	/* Force the parent of TCON0 to PLL-MIPI */
+//	val = readl(reg + SUN50I_A64_TCON0_REG);
+//	val &= ~GENMASK(26, 24);
+//	writel(val | (0 << 24), reg + SUN50I_A64_TCON0_REG);
 
 	ret = devm_sunxi_ccu_probe(&pdev->dev, reg, &sun50i_a64_ccu_desc);
 	if (ret)
@@ -966,6 +1021,10 @@
 	ccu_mux_notifier_register(pll_cpux_clk.common.hw.clk,
 				  &sun50i_a64_cpu_nb);
 
+	/* Reset the rate of TCON0 clock when PLL-VIDEO0 is changed */
+//	sun50i_a64_pll_video0_reset_tcon0_nb.target_clk = tcon0_clk.common.hw.clk;
+//	ccu_rate_reset_notifier_register(&sun50i_a64_pll_video0_reset_tcon0_nb);
+
 	return 0;
 }
 
diff -Nuar -r --no-dereference linux-5.15.139/drivers/clk/sunxi-ng/ccu-sun8i-a83t.h linux/drivers/clk/sunxi-ng/ccu-sun8i-a83t.h
--- linux-5.15.139/drivers/clk/sunxi-ng/ccu-sun8i-a83t.h	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/clk/sunxi-ng/ccu-sun8i-a83t.h	2024-01-03 16:06:25.935131000 +0800
@@ -42,12 +42,8 @@
 
 /* module and usb clocks exported */
 
-#define CLK_DRAM		82
-
 /* dram gates and more module clocks exported */
 
-#define CLK_MBUS		95
-
 /* more module clocks exported */
 
 #define CLK_NUMBER		(CLK_GPU_HYD + 1)
diff -Nuar -r --no-dereference linux-5.15.139/drivers/clk/sunxi-ng/ccu_common.h linux/drivers/clk/sunxi-ng/ccu_common.h
--- linux-5.15.139/drivers/clk/sunxi-ng/ccu_common.h	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/clk/sunxi-ng/ccu_common.h	2024-01-03 16:06:25.935131000 +0800
@@ -63,6 +63,18 @@
 
 int ccu_pll_notifier_register(struct ccu_pll_nb *pll_nb);
 
+struct ccu_rate_reset_nb {
+	struct notifier_block	clk_nb;
+	struct ccu_common	*common;
+
+	struct clk		*target_clk;
+	unsigned long		saved_rate;
+};
+
+#define to_ccu_rate_reset_nb(_nb) container_of(_nb, struct ccu_rate_reset_nb, clk_nb)
+
+int ccu_rate_reset_notifier_register(struct ccu_rate_reset_nb *rate_reset_nb);
+
 int devm_sunxi_ccu_probe(struct device *dev, void __iomem *reg,
 			 const struct sunxi_ccu_desc *desc);
 void of_sunxi_ccu_probe(struct device_node *node, void __iomem *reg,
diff -Nuar -r --no-dereference linux-5.15.139/drivers/clk/sunxi-ng/ccu_nkm.c linux/drivers/clk/sunxi-ng/ccu_nkm.c
--- linux-5.15.139/drivers/clk/sunxi-ng/ccu_nkm.c	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/clk/sunxi-ng/ccu_nkm.c	2024-01-03 16:06:25.935131000 +0800
@@ -119,6 +119,11 @@
 	_nkm.min_m = 1;
 	_nkm.max_m = nkm->m.max ?: 1 << nkm->m.width;
 
+	if (rate < nkm->min_rate)
+		rate = nkm->min_rate;
+	if (nkm->max_rate && (rate > nkm->max_rate))
+		rate = nkm->max_rate;
+
 	if (nkm->common.features & CCU_FEATURE_FIXED_POSTDIV)
 		rate *= nkm->fixed_post_div;
 
diff -Nuar -r --no-dereference linux-5.15.139/drivers/clk/sunxi-ng/ccu-sun8i-h3.c linux/drivers/clk/sunxi-ng/ccu-sun8i-h3.c
--- linux-5.15.139/drivers/clk/sunxi-ng/ccu-sun8i-h3.c	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/clk/sunxi-ng/ccu-sun8i-h3.c	2024-01-03 16:06:25.935131000 +0800
@@ -23,15 +23,21 @@
 
 #include "ccu-sun8i-h3.h"
 
-static SUNXI_CCU_NKMP_WITH_GATE_LOCK(pll_cpux_clk, "pll-cpux",
-				     "osc24M", 0x000,
-				     8, 5,	/* N */
-				     4, 2,	/* K */
-				     0, 2,	/* M */
-				     16, 2,	/* P */
-				     BIT(31),	/* gate */
-				     BIT(28),	/* lock */
-				     CLK_SET_RATE_UNGATE);
+static struct ccu_nkmp pll_cpux_clk = {
+	.enable		= BIT(31),
+	.lock		= BIT(28),
+	.n		= _SUNXI_CCU_MULT(8, 5),
+	.k		= _SUNXI_CCU_MULT(4, 2),
+	.m		= _SUNXI_CCU_DIV_MAX(0, 2, 1),
+	.p		= _SUNXI_CCU_DIV_MAX(16, 2, 1),
+	.common		= {
+		.reg		= 0x000,
+		.hw.init	= CLK_HW_INIT("pll-cpux",
+					      "osc24M",
+					      &ccu_nkmp_ops,
+					      CLK_SET_RATE_UNGATE),
+	},
+};
 
 /*
  * The Audio PLL is supposed to have 4 outputs: 3 fixed factors from
@@ -1123,20 +1129,6 @@
 	.num_resets	= ARRAY_SIZE(sun50i_h5_ccu_resets),
 };
 
-static struct ccu_pll_nb sun8i_h3_pll_cpu_nb = {
-	.common	= &pll_cpux_clk.common,
-	/* copy from pll_cpux_clk */
-	.enable	= BIT(31),
-	.lock	= BIT(28),
-};
-
-static struct ccu_mux_nb sun8i_h3_cpu_nb = {
-	.common		= &cpux_clk.common,
-	.cm		= &cpux_clk.mux,
-	.delay_us	= 1, /* > 8 clock cycles at 24 MHz */
-	.bypass_index	= 1, /* index of 24 MHz oscillator */
-};
-
 static void __init sunxi_h3_h5_ccu_init(struct device_node *node,
 					const struct sunxi_ccu_desc *desc)
 {
@@ -1155,13 +1147,6 @@
 	writel(val | (0 << 16), reg + SUN8I_H3_PLL_AUDIO_REG);
 
 	of_sunxi_ccu_probe(node, reg, desc);
-
-	/* Gate then ungate PLL CPU after any rate changes */
-	ccu_pll_notifier_register(&sun8i_h3_pll_cpu_nb);
-
-	/* Reparent CPU during PLL CPU rate changes */
-	ccu_mux_notifier_register(pll_cpux_clk.common.hw.clk,
-				  &sun8i_h3_cpu_nb);
 }
 
 static void __init sun8i_h3_ccu_setup(struct device_node *node)
diff -Nuar -r --no-dereference linux-5.15.139/drivers/clk/sunxi-ng/ccu_nkm.h linux/drivers/clk/sunxi-ng/ccu_nkm.h
--- linux-5.15.139/drivers/clk/sunxi-ng/ccu_nkm.h	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/clk/sunxi-ng/ccu_nkm.h	2024-01-03 16:06:25.935131000 +0800
@@ -28,6 +28,9 @@
 
 	unsigned int		fixed_post_div;
 
+	unsigned int		min_rate;
+	unsigned int		max_rate;
+
 	struct ccu_common	common;
 };
 
diff -Nuar -r --no-dereference linux-5.15.139/drivers/thermal/sun8i_thermal.c linux/drivers/thermal/sun8i_thermal.c
--- linux-5.15.139/drivers/thermal/sun8i_thermal.c	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/thermal/sun8i_thermal.c	2024-01-03 16:06:25.935131000 +0800
@@ -108,6 +108,12 @@
 		return -1590 * reg / 10 + 276000;
 }
 
+static int sun50i_h616_calc_temp(struct ths_device *tmdev,
+			       int id, int reg)
+{
+	return (reg + tmdev->chip->offset) * tmdev->chip->scale;
+}
+
 static int sun8i_ths_get_temp(void *data, int *temp)
 {
 	struct tsensor *s = data;
@@ -278,6 +284,64 @@
 	return 0;
 }
 
+static int sun50i_h616_ths_calibrate(struct ths_device *tmdev,
+				   u16 *caldata, int callen)
+{
+	struct device *dev = tmdev->dev;
+	int i, ft_temp;
+
+	if (!caldata[0])
+		return -EINVAL;
+
+	/*
+	 * h616 efuse THS calibration data layout:
+	 *
+	 * 0      11  16     27   32     43   48    57
+	 * +----------+-----------+-----------+-----------+
+	 * |  temp |  |sensor0|   |sensor1|   |sensor2|   |
+	 * +----------+-----------+-----------+-----------+
+	 *                      ^           ^           ^
+	 *                      |           |           |
+	 *                      |           |           sensor3[11:8]
+	 *                      |           sensor3[7:4]
+	 *                      sensor3[3:0]
+	 *
+	 * The calibration data on the H616 is the ambient temperature and
+	 * sensor values that are filled during the factory test stage.
+	 *
+	 * The unit of stored FT temperature is 0.1 degreee celusis.
+	 */
+	ft_temp = caldata[0] & FT_TEMP_MASK;
+
+	for (i = 0; i < tmdev->chip->sensor_num; i++) {
+		int delta, cdata, offset, reg;
+
+		if (i == 3)
+			reg = (caldata[1] >> 12)
+			      | (caldata[2] >> 12 << 4)
+			      | (caldata[3] >> 12 << 8);
+		else
+			reg = (int)caldata[i + 1] & TEMP_CALIB_MASK;
+
+		delta = (ft_temp * 100 - tmdev->chip->calc_temp(tmdev, i, reg))
+			/ tmdev->chip->scale;
+		cdata = CALIBRATE_DEFAULT - delta;
+		if (cdata & ~TEMP_CALIB_MASK) {
+			dev_warn(dev, "sensor%d is not calibrated.\n", i);
+
+			continue;
+		}
+		
+		offset = (i % 2) * 16;
+		regmap_update_bits(tmdev->regmap,
+				   SUN50I_H6_THS_TEMP_CALIB + (i / 2 * 4),
+				   0xfff << offset,
+				   cdata << offset);
+	}
+
+	return 0;
+}
+
 static int sun8i_ths_calibrate(struct ths_device *tmdev)
 {
 	struct nvmem_cell *calcell;
@@ -288,8 +352,13 @@
 
 	calcell = devm_nvmem_cell_get(dev, "calibration");
 	if (IS_ERR(calcell)) {
+		dev_err_probe(dev, PTR_ERR(calcell),
+			      "Failed to get calibration nvmem cell (%pe)\n",
+			      calcell);
+
 		if (PTR_ERR(calcell) == -EPROBE_DEFER)
 			return -EPROBE_DEFER;
+
 		/*
 		 * Even if the external calibration data stored in sid is
 		 * not accessible, the THS hardware can still work, although
@@ -309,6 +378,8 @@
 	caldata = nvmem_cell_read(calcell, &callen);
 	if (IS_ERR(caldata)) {
 		ret = PTR_ERR(caldata);
+		dev_err(dev, "Failed to read calibration data (%pe)\n",
+			caldata);
 		goto out;
 	}
 
@@ -336,13 +407,17 @@
 		return PTR_ERR(base);
 
 	tmdev->regmap = devm_regmap_init_mmio(dev, base, &config);
-	if (IS_ERR(tmdev->regmap))
+	if (IS_ERR(tmdev->regmap)) {
+		dev_err(dev, "Failed to init regmap (%pe)\n", tmdev->regmap);
 		return PTR_ERR(tmdev->regmap);
+	}
 
 	if (tmdev->chip->has_bus_clk_reset) {
 		tmdev->reset = devm_reset_control_get(dev, NULL);
-		if (IS_ERR(tmdev->reset))
+		if (IS_ERR(tmdev->reset)) {
+			dev_err(dev, "Failed to get reset (%pe)\n", tmdev->reset);
 			return PTR_ERR(tmdev->reset);
+		}
 
 		ret = reset_control_deassert(tmdev->reset);
 		if (ret)
@@ -354,14 +429,20 @@
 			return ret;
 
 		tmdev->bus_clk = devm_clk_get_enabled(&pdev->dev, "bus");
-		if (IS_ERR(tmdev->bus_clk))
+		if (IS_ERR(tmdev->bus_clk)) {
+			dev_err(dev, "Failed to get bus clock (%pe)\n",
+				tmdev->bus_clk);
 			return PTR_ERR(tmdev->bus_clk);
+		}
 	}
 
 	if (tmdev->chip->has_mod_clk) {
 		tmdev->mod_clk = devm_clk_get_enabled(&pdev->dev, "mod");
-		if (IS_ERR(tmdev->mod_clk))
+		if (IS_ERR(tmdev->mod_clk)) {
+			dev_err(dev, "Failed to get mod clock (%pe)\n",
+				tmdev->mod_clk);
 			return PTR_ERR(tmdev->mod_clk);
+		}
 	}
 
 	ret = clk_set_rate(tmdev->mod_clk, 24000000);
@@ -453,6 +534,30 @@
 	return 0;
 }
 
+static int sun50i_h616_thermal_init(struct ths_device *tmdev)
+{
+	int val;
+
+	/*
+	 * For sun50iw9p1:
+	 * It is necessary that reg[0x03000000] bit[16] is 0.
+	 */
+	regmap_write(tmdev->regmap, SUN50I_THS_CTRL0,
+		     SUN8I_THS_CTRL0_T_ACQ0(47) | SUN8I_THS_CTRL2_T_ACQ1(479));
+	regmap_write(tmdev->regmap, SUN50I_H6_THS_MFC,
+		     SUN50I_THS_FILTER_EN |
+		     SUN50I_THS_FILTER_TYPE(1));
+	regmap_write(tmdev->regmap, SUN50I_H6_THS_PC,
+		     SUN50I_H6_THS_PC_TEMP_PERIOD(365));
+	val = GENMASK(tmdev->chip->sensor_num - 1, 0);
+	regmap_write(tmdev->regmap, SUN50I_H6_THS_ENABLE, val);
+	/* thermal data interrupt enable */
+	val = GENMASK(tmdev->chip->sensor_num - 1, 0);
+	regmap_write(tmdev->regmap, SUN50I_H6_THS_DIC, val);
+
+	return 0;
+}
+
 static int sun8i_ths_register(struct ths_device *tmdev)
 {
 	int i;
@@ -465,8 +570,12 @@
 							     i,
 							     &tmdev->sensor[i],
 							     &ths_ops);
-		if (IS_ERR(tmdev->sensor[i].tzd))
+		if (IS_ERR(tmdev->sensor[i].tzd)) {
+			dev_err(tmdev->dev,
+				"Failed to register sensor %d (%pe)\n",
+				i, tmdev->sensor[i].tzd);
 			return PTR_ERR(tmdev->sensor[i].tzd);
+		}
 
 		if (devm_thermal_add_hwmon_sysfs(tmdev->sensor[i].tzd))
 			dev_warn(tmdev->dev,
@@ -517,8 +626,10 @@
 	ret = devm_request_threaded_irq(dev, irq, NULL,
 					sun8i_irq_thread,
 					IRQF_ONESHOT, "ths", tmdev);
-	if (ret)
+	if (ret) {
+		dev_err(dev, "Failed to request irq (%d)\n", ret);
 		return ret;
+	}
 
 	return 0;
 }
@@ -610,6 +721,19 @@
 	.calc_temp = sun8i_ths_calc_temp,
 };
 
+static const struct ths_thermal_chip sun50i_h616_ths = {
+	.sensor_num = 4,
+	.has_bus_clk_reset = true,
+	.ft_deviation = 8000,
+	.offset = -3255,
+	.scale = -81,
+	.temp_data_base = SUN50I_H6_THS_TEMP_DATA,
+	.calibrate = sun50i_h616_ths_calibrate,
+	.init = sun50i_h616_thermal_init,
+	.irq_ack = sun50i_h6_irq_ack,
+	.calc_temp = sun50i_h616_calc_temp,
+};
+
 static const struct of_device_id of_ths_match[] = {
 	{ .compatible = "allwinner,sun8i-a83t-ths", .data = &sun8i_a83t_ths },
 	{ .compatible = "allwinner,sun8i-h3-ths", .data = &sun8i_h3_ths },
@@ -618,6 +742,7 @@
 	{ .compatible = "allwinner,sun50i-a100-ths", .data = &sun50i_a100_ths },
 	{ .compatible = "allwinner,sun50i-h5-ths", .data = &sun50i_h5_ths },
 	{ .compatible = "allwinner,sun50i-h6-ths", .data = &sun50i_h6_ths },
+	{ .compatible = "allwinner,sun50i-h616-ths", .data = &sun50i_h616_ths },
 	{ /* sentinel */ },
 };
 MODULE_DEVICE_TABLE(of, of_ths_match);
diff -Nuar -r --no-dereference linux-5.15.139/drivers/rtc/rtc-sun6i.c linux/drivers/rtc/rtc-sun6i.c
--- linux-5.15.139/drivers/rtc/rtc-sun6i.c	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/rtc/rtc-sun6i.c	2024-01-03 16:06:25.935131000 +0800
@@ -48,7 +48,8 @@
 
 /* Alarm 0 (counter) */
 #define SUN6I_ALRM_COUNTER			0x0020
-#define SUN6I_ALRM_CUR_VAL			0x0024
+/* This holds the remaining alarm seconds on older SoCs (current value) */
+#define SUN6I_ALRM_COUNTER_HMS			0x0024
 #define SUN6I_ALRM_EN				0x0028
 #define SUN6I_ALRM_EN_CNT_EN			BIT(0)
 #define SUN6I_ALRM_IRQ_EN			0x002c
@@ -69,6 +70,10 @@
 #define SUN6I_LOSC_OUT_GATING			0x0060
 #define SUN6I_LOSC_OUT_GATING_EN_OFFSET		0
 
+/* General-purpose data */
+#define SUN6I_GP_DATA				0x0100
+#define SUN6I_GP_DATA_SIZE			0x40
+
 /*
  * Get date values
  */
@@ -110,6 +115,8 @@
 #define SUN6I_YEAR_MIN				1970
 #define SUN6I_YEAR_OFF				(SUN6I_YEAR_MIN - 1900)
 
+#define SECS_PER_DAY				(24 * 3600ULL)
+
 /*
  * There are other differences between models, including:
  *
@@ -130,14 +137,18 @@
 	unsigned int has_out_clk : 1;
 	unsigned int has_losc_en : 1;
 	unsigned int has_auto_swt : 1;
+	unsigned int no_ext_losc : 1;
 };
 
+#define RTC_LINEAR_DAY	BIT(0)
+
 struct sun6i_rtc_dev {
 	struct rtc_device *rtc;
 	const struct sun6i_rtc_clk_data *data;
 	void __iomem *base;
 	int irq;
 	time64_t alarm;
+	unsigned long flags;
 
 	struct clk_hw hw;
 	struct clk_hw *int_osc;
@@ -249,7 +260,7 @@
 	}
 
 	/* Switch to the external, more precise, oscillator, if present */
-	if (of_get_property(node, "clocks", NULL)) {
+	if (!rtc->data->no_ext_losc && of_get_property(node, "clocks", NULL)) {
 		reg |= SUN6I_LOSC_CTRL_EXT_OSC;
 		if (rtc->data->has_losc_en)
 			reg |= SUN6I_LOSC_CTRL_EXT_LOSC_EN;
@@ -273,14 +284,19 @@
 	}
 
 	parents[0] = clk_hw_get_name(rtc->int_osc);
-	/* If there is no external oscillator, this will be NULL and ... */
-	parents[1] = of_clk_get_parent_name(node, 0);
+	if (rtc->data->no_ext_losc) {
+		parents[1] = NULL;
+		init.num_parents = 1;
+	} else {
+		/* If there is no external oscillator, this will be NULL and */
+		parents[1] = of_clk_get_parent_name(node, 0);
+		/* ... number of clock parents will be 1. */
+		init.num_parents = of_clk_get_parent_count(node) + 1;
+	}
 
 	rtc->hw.init = &init;
 
 	init.parent_names = parents;
-	/* ... number of clock parents will be 1. */
-	init.num_parents = of_clk_get_parent_count(node) + 1;
 	of_property_read_string_index(node, "clock-output-names", 0,
 				      &init.name);
 
@@ -372,6 +388,22 @@
 CLK_OF_DECLARE_DRIVER(sun50i_h6_rtc_clk, "allwinner,sun50i-h6-rtc",
 		      sun50i_h6_rtc_clk_init);
 
+static const struct sun6i_rtc_clk_data sun50i_h616_rtc_data = {
+	.rc_osc_rate = 16000000,
+	.fixed_prescaler = 32,
+	.has_prescaler = 1,
+	.has_out_clk = 1,
+	.no_ext_losc = 1,
+};
+
+static void __init sun50i_h616_rtc_clk_init(struct device_node *node)
+{
+	sun6i_rtc_clk_init(node, &sun50i_h616_rtc_data);
+}
+
+CLK_OF_DECLARE_DRIVER(sun50i_h616_rtc_clk, "allwinner,sun50i-h616-rtc",
+		      sun50i_h616_rtc_clk_init);
+
 /*
  * The R40 user manual is self-conflicting on whether the prescaler is
  * fixed or configurable. The clock diagram shows it as fixed, but there
@@ -459,22 +491,30 @@
 	} while ((date != readl(chip->base + SUN6I_RTC_YMD)) ||
 		 (time != readl(chip->base + SUN6I_RTC_HMS)));
 
+	if (chip->flags & RTC_LINEAR_DAY) {
+		/*
+		 * Newer chips store a linear day number, the manual
+		 * does not mandate any epoch base. The BSP driver uses
+		 * the UNIX epoch, let's just copy that, as it's the
+		 * easiest anyway.
+		 */
+		rtc_time64_to_tm((date & 0xffff) * SECS_PER_DAY, rtc_tm);
+	} else {
+		rtc_tm->tm_mday = SUN6I_DATE_GET_DAY_VALUE(date);
+		rtc_tm->tm_mon  = SUN6I_DATE_GET_MON_VALUE(date) - 1;
+		rtc_tm->tm_year = SUN6I_DATE_GET_YEAR_VALUE(date);
+
+		/*
+		 * switch from (data_year->min)-relative offset to
+		 * a (1900)-relative one
+		 */
+		rtc_tm->tm_year += SUN6I_YEAR_OFF;
+	}
+
 	rtc_tm->tm_sec  = SUN6I_TIME_GET_SEC_VALUE(time);
 	rtc_tm->tm_min  = SUN6I_TIME_GET_MIN_VALUE(time);
 	rtc_tm->tm_hour = SUN6I_TIME_GET_HOUR_VALUE(time);
 
-	rtc_tm->tm_mday = SUN6I_DATE_GET_DAY_VALUE(date);
-	rtc_tm->tm_mon  = SUN6I_DATE_GET_MON_VALUE(date);
-	rtc_tm->tm_year = SUN6I_DATE_GET_YEAR_VALUE(date);
-
-	rtc_tm->tm_mon  -= 1;
-
-	/*
-	 * switch from (data_year->min)-relative offset to
-	 * a (1900)-relative one
-	 */
-	rtc_tm->tm_year += SUN6I_YEAR_OFF;
-
 	return 0;
 }
 
@@ -502,32 +542,54 @@
 	struct sun6i_rtc_dev *chip = dev_get_drvdata(dev);
 	struct rtc_time *alrm_tm = &wkalrm->time;
 	struct rtc_time tm_now;
-	time64_t time_now, time_set;
+	time64_t time_set;
+	u32 counter_val, counter_val_hms;
 	int ret;
 
-	ret = sun6i_rtc_gettime(dev, &tm_now);
-	if (ret < 0) {
-		dev_err(dev, "Error in getting time\n");
-		return -EINVAL;
-	}
-
 	time_set = rtc_tm_to_time64(alrm_tm);
-	time_now = rtc_tm_to_time64(&tm_now);
-	if (time_set <= time_now) {
-		dev_err(dev, "Date to set in the past\n");
-		return -EINVAL;
-	}
 
-	if ((time_set - time_now) > U32_MAX) {
-		dev_err(dev, "Date too far in the future\n");
-		return -EINVAL;
+	if (chip->flags & RTC_LINEAR_DAY) {
+		/*
+		 * The alarm registers hold the actual alarm time, encoded
+		 * in the same way (linear day + HMS) as the current time.
+		 */
+		counter_val_hms = SUN6I_TIME_SET_SEC_VALUE(alrm_tm->tm_sec)  |
+				  SUN6I_TIME_SET_MIN_VALUE(alrm_tm->tm_min)  |
+				  SUN6I_TIME_SET_HOUR_VALUE(alrm_tm->tm_hour);
+		/* The division will cut off the H:M:S part of alrm_tm. */
+		counter_val = div_u64(rtc_tm_to_time64(alrm_tm), SECS_PER_DAY);
+	} else {
+		/* The alarm register holds the number of seconds left. */
+		time64_t time_now;
+
+		ret = sun6i_rtc_gettime(dev, &tm_now);
+		if (ret < 0) {
+			dev_err(dev, "Error in getting time\n");
+			return -EINVAL;
+		}
+
+		time_now = rtc_tm_to_time64(&tm_now);
+		if (time_set <= time_now) {
+			dev_err(dev, "Date to set in the past\n");
+			return -EINVAL;
+		}
+		if ((time_set - time_now) > U32_MAX) {
+			dev_err(dev, "Date too far in the future\n");
+			return -EINVAL;
+		}
+
+		counter_val = time_set - time_now;
 	}
 
 	sun6i_rtc_setaie(0, chip);
 	writel(0, chip->base + SUN6I_ALRM_COUNTER);
+	if (chip->flags & RTC_LINEAR_DAY)
+		writel(0, chip->base + SUN6I_ALRM_COUNTER_HMS);
 	usleep_range(100, 300);
 
-	writel(time_set - time_now, chip->base + SUN6I_ALRM_COUNTER);
+	writel(counter_val, chip->base + SUN6I_ALRM_COUNTER);
+	if (chip->flags & RTC_LINEAR_DAY)
+		writel(counter_val_hms, chip->base + SUN6I_ALRM_COUNTER_HMS);
 	chip->alarm = time_set;
 
 	sun6i_rtc_setaie(wkalrm->enabled, chip);
@@ -559,20 +621,25 @@
 	u32 date = 0;
 	u32 time = 0;
 
-	rtc_tm->tm_year -= SUN6I_YEAR_OFF;
-	rtc_tm->tm_mon += 1;
-
-	date = SUN6I_DATE_SET_DAY_VALUE(rtc_tm->tm_mday) |
-		SUN6I_DATE_SET_MON_VALUE(rtc_tm->tm_mon)  |
-		SUN6I_DATE_SET_YEAR_VALUE(rtc_tm->tm_year);
-
-	if (is_leap_year(rtc_tm->tm_year + SUN6I_YEAR_MIN))
-		date |= SUN6I_LEAP_SET_VALUE(1);
-
 	time = SUN6I_TIME_SET_SEC_VALUE(rtc_tm->tm_sec)  |
 		SUN6I_TIME_SET_MIN_VALUE(rtc_tm->tm_min)  |
 		SUN6I_TIME_SET_HOUR_VALUE(rtc_tm->tm_hour);
 
+	if (chip->flags & RTC_LINEAR_DAY) {
+		/* The division will cut off the H:M:S part of rtc_tm. */
+		date = div_u64(rtc_tm_to_time64(rtc_tm), SECS_PER_DAY);
+	} else {
+		rtc_tm->tm_year -= SUN6I_YEAR_OFF;
+		rtc_tm->tm_mon += 1;
+
+		date = SUN6I_DATE_SET_DAY_VALUE(rtc_tm->tm_mday) |
+			SUN6I_DATE_SET_MON_VALUE(rtc_tm->tm_mon)  |
+			SUN6I_DATE_SET_YEAR_VALUE(rtc_tm->tm_year);
+
+		if (is_leap_year(rtc_tm->tm_year + SUN6I_YEAR_MIN))
+			date |= SUN6I_LEAP_SET_VALUE(1);
+	}
+
 	/* Check whether registers are writable */
 	if (sun6i_rtc_wait(chip, SUN6I_LOSC_CTRL,
 			   SUN6I_LOSC_CTRL_ACC_MASK, 50)) {
@@ -629,7 +696,39 @@
 	.alarm_irq_enable	= sun6i_rtc_alarm_irq_enable
 };
 
-#ifdef CONFIG_PM_SLEEP
+static int sun6i_rtc_nvmem_read(void *priv, unsigned int offset, void *_val, size_t bytes)
+{
+	struct sun6i_rtc_dev *chip = priv;
+	u32 *val = _val;
+	int i;
+
+	for (i = 0; i < bytes / 4; ++i)
+		val[i] = readl(chip->base + SUN6I_GP_DATA + offset + 4 * i);
+
+	return 0;
+}
+
+static int sun6i_rtc_nvmem_write(void *priv, unsigned int offset, void *_val, size_t bytes)
+{
+	struct sun6i_rtc_dev *chip = priv;
+	u32 *val = _val;
+	int i;
+
+	for (i = 0; i < bytes / 4; ++i)
+		writel(val[i], chip->base + SUN6I_GP_DATA + offset + 4 * i);
+
+	return 0;
+}
+
+static struct nvmem_config sun6i_rtc_nvmem_cfg = {
+	.type		= NVMEM_TYPE_BATTERY_BACKED,
+	.reg_read	= sun6i_rtc_nvmem_read,
+	.reg_write	= sun6i_rtc_nvmem_write,
+	.size		= SUN6I_GP_DATA_SIZE,
+	.word_size	= 4,
+	.stride		= 4,
+};
+
 /* Enable IRQ wake on suspend, to wake up from RTC. */
 static int sun6i_rtc_suspend(struct device *dev)
 {
@@ -642,7 +741,7 @@
 }
 
 /* Disable IRQ wake on resume. */
-static int sun6i_rtc_resume(struct device *dev)
+static int __maybe_unused sun6i_rtc_resume(struct device *dev)
 {
 	struct sun6i_rtc_dev *chip = dev_get_drvdata(dev);
 
@@ -651,7 +750,6 @@
 
 	return 0;
 }
-#endif
 
 static SIMPLE_DEV_PM_OPS(sun6i_rtc_pm_ops,
 	sun6i_rtc_suspend, sun6i_rtc_resume);
@@ -666,6 +764,8 @@
 
 	platform_set_drvdata(pdev, chip);
 
+	chip->flags = (unsigned long)of_device_get_match_data(&pdev->dev);
+
 	chip->irq = platform_get_irq(pdev, 0);
 	if (chip->irq < 0)
 		return chip->irq;
@@ -712,17 +812,30 @@
 		return PTR_ERR(chip->rtc);
 
 	chip->rtc->ops = &sun6i_rtc_ops;
-	chip->rtc->range_max = 2019686399LL; /* 2033-12-31 23:59:59 */
+	if (chip->flags & RTC_LINEAR_DAY)
+		chip->rtc->range_max = (65536 * SECS_PER_DAY) - 1;
+	else
+		chip->rtc->range_max = 2019686399LL; /* 2033-12-31 23:59:59 */
 
 	ret = devm_rtc_register_device(chip->rtc);
 	if (ret)
 		return ret;
 
+	sun6i_rtc_nvmem_cfg.priv = chip;
+	ret = devm_rtc_nvmem_register(chip->rtc, &sun6i_rtc_nvmem_cfg);
+	if (ret)
+		return ret;
+
 	dev_info(&pdev->dev, "RTC enabled\n");
 
 	return 0;
 }
 
+static void sun6i_rtc_shutdown(struct platform_device *pdev)
+{
+	sun6i_rtc_suspend(&pdev->dev);
+}
+
 /*
  * As far as RTC functionality goes, all models are the same. The
  * datasheets claim that different models have different number of
@@ -737,12 +850,15 @@
 	{ .compatible = "allwinner,sun8i-v3-rtc" },
 	{ .compatible = "allwinner,sun50i-h5-rtc" },
 	{ .compatible = "allwinner,sun50i-h6-rtc" },
+	{ .compatible = "allwinner,sun50i-h616-rtc",
+		.data = (void *)RTC_LINEAR_DAY },
 	{ /* sentinel */ },
 };
 MODULE_DEVICE_TABLE(of, sun6i_rtc_dt_ids);
 
 static struct platform_driver sun6i_rtc_driver = {
 	.probe		= sun6i_rtc_probe,
+	.shutdown	= sun6i_rtc_shutdown,
 	.driver		= {
 		.name		= "sun6i-rtc",
 		.of_match_table = sun6i_rtc_dt_ids,
diff -Nuar -r --no-dereference linux-5.15.139/drivers/iio/industrialio-core.c linux/drivers/iio/industrialio-core.c
--- linux-5.15.139/drivers/iio/industrialio-core.c	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/iio/industrialio-core.c	2024-01-03 16:06:25.935131000 +0800
@@ -33,6 +33,16 @@
 #include <linux/iio/buffer.h>
 #include <linux/iio/buffer_impl.h>
 
+static int ignore_mount_matrix = 0;
+
+static int __init ignore_matrix(char *str)
+{
+	ignore_mount_matrix = 1;
+	return 1;
+}
+
+__setup("ignore_mount_matrix", ignore_matrix);
+
 /* IDA to assign each registered device a unique id */
 static DEFINE_IDA(iio_ida);
 
@@ -641,6 +651,7 @@
 	size_t len = ARRAY_SIZE(iio_mount_idmatrix.rotation);
 	int err;
 
+	if (!ignore_mount_matrix) {
 	err = device_property_read_string_array(dev, "mount-matrix", matrix->rotation, len);
 	if (err == len)
 		return 0;
@@ -652,6 +663,7 @@
 	if (err != -EINVAL)
 		/* Invalid matrix declaration format. */
 		return err;
+	}
 
 	/* Matrix was not declared at all: fallback to identity. */
 	return iio_setup_mount_idmatrix(dev, matrix);
diff -Nuar -r --no-dereference linux-5.15.139/drivers/iio/accel/bma180.c linux/drivers/iio/accel/bma180.c
--- linux-5.15.139/drivers/iio/accel/bma180.c	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/iio/accel/bma180.c	2024-01-03 16:06:25.935131000 +0800
@@ -1140,6 +1140,7 @@
 		.name	= "bma180",
 		.pm	= BMA180_PM_OPS,
 		.of_match_table = bma180_of_match,
+		.probe_type = PROBE_PREFER_ASYNCHRONOUS,
 	},
 	.probe		= bma180_probe,
 	.remove		= bma180_remove,
diff -Nuar -r --no-dereference linux-5.15.139/drivers/iio/adc/Kconfig linux/drivers/iio/adc/Kconfig
--- linux-5.15.139/drivers/iio/adc/Kconfig	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/iio/adc/Kconfig	2024-01-03 16:06:25.935131000 +0800
@@ -994,7 +994,7 @@
 config SUN4I_GPADC
 	tristate "Support for the Allwinner SoCs GPADC"
 	depends on IIO
-	depends on MFD_SUN4I_GPADC || MACH_SUN8I
+	depends on MFD_SUN4I_GPADC || MACH_SUN8I || MACH_SUN50I || MACH_SUN9I
 	depends on THERMAL || !THERMAL_OF
 	select REGMAP_IRQ
 	help
diff -Nuar -r --no-dereference linux-5.15.139/drivers/iio/adc/axp20x_adc.c linux/drivers/iio/adc/axp20x_adc.c
--- linux-5.15.139/drivers/iio/adc/axp20x_adc.c	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/iio/adc/axp20x_adc.c	2024-01-03 16:06:25.935131000 +0800
@@ -6,6 +6,7 @@
  */
 
 #include <linux/completion.h>
+#include <linux/hwmon.h>
 #include <linux/interrupt.h>
 #include <linux/io.h>
 #include <linux/module.h>
@@ -14,7 +15,6 @@
 #include <linux/pm_runtime.h>
 #include <linux/property.h>
 #include <linux/regmap.h>
-#include <linux/thermal.h>
 
 #include <linux/iio/iio.h>
 #include <linux/iio/driver.h>
@@ -39,6 +39,7 @@
 #define AXP813_TS_GPIO0_ADC_RATE_HZ(x)		AXP20X_ADC_RATE_HZ(x)
 #define AXP813_V_I_ADC_RATE_HZ(x)		((ilog2((x) / 100) << 4) & AXP813_V_I_ADC_RATE_MASK)
 #define AXP813_ADC_RATE_HZ(x)			(AXP20X_ADC_RATE_HZ(x) | AXP813_V_I_ADC_RATE_HZ(x))
+#define AXP20X_TS_FUNCTION_GPADC		BIT(2)
 
 #define AXP20X_ADC_CHANNEL(_channel, _name, _type, _reg)	\
 	{							\
@@ -582,6 +583,74 @@
 				 AXP813_ADC_RATE_HZ(rate));
 }
 
+
+static umode_t axp813_adc_hwmon_is_visible(const void *data,
+					   enum hwmon_sensor_types type,
+					   u32 attr, int channel)
+{
+	return (type == hwmon_temp && attr == hwmon_temp_input) ? 0444 : 0;
+}
+
+static int axp813_adc_hwmon_read(struct device *dev,
+				 enum hwmon_sensor_types type,
+				 u32 attr, int channel, long *temp)
+{
+	struct axp20x_adc_iio *info = dev_get_drvdata(dev);
+	int ret;
+	int raw;
+
+	switch (attr) {
+		case hwmon_temp_input:
+		raw = axp20x_read_variable_width(info->regmap, AXP22X_PMIC_TEMP_H, 12);
+		*temp = (raw - 2667) * 100;
+		ret = 0;
+		break;
+	default:
+		ret = -EOPNOTSUPP;
+		break;
+	}
+
+	return ret;
+}
+
+static u32 axp813_adc_hwmon_chip_config[] = {
+	HWMON_C_REGISTER_TZ,
+	0
+};
+
+static const struct hwmon_channel_info axp813_adc_hwmon_chip = {
+	.type = hwmon_chip,
+	.config = axp813_adc_hwmon_chip_config,
+};
+
+static u32 axp813_adc_hwmon_temp_config[] = {
+	HWMON_T_INPUT,
+	0
+};
+
+
+static const struct hwmon_channel_info axp813_adc_hwmon_temp = {
+	.type = hwmon_temp,
+	.config = axp813_adc_hwmon_temp_config,
+};
+
+
+static const struct hwmon_channel_info *axp813_adc_hwmon_info[] = {
+	&axp813_adc_hwmon_chip,
+	&axp813_adc_hwmon_temp,
+	NULL
+};
+
+static const struct hwmon_ops axp813_adc_hwmon_hwmon_ops = {
+	.is_visible = axp813_adc_hwmon_is_visible,
+	.read = axp813_adc_hwmon_read,
+};
+
+static const struct hwmon_chip_info axp813_adc_hwmon_chip_info = {
+	.ops = &axp813_adc_hwmon_hwmon_ops,
+	.info = axp813_adc_hwmon_info,
+};
+
 struct axp_data {
 	const struct iio_info		*iio_info;
 	int				num_channels;
@@ -590,6 +659,7 @@
 	int				(*adc_rate)(struct axp20x_adc_iio *info,
 						    int rate);
 	bool				adc_en2;
+	bool				hwmon_en;
 	struct iio_map			*maps;
 };
 
@@ -600,6 +670,7 @@
 	.adc_en1_mask = AXP20X_ADC_EN1_MASK,
 	.adc_rate = axp20x_adc_rate,
 	.adc_en2 = true,
+	.hwmon_en = false,
 	.maps = axp20x_maps,
 };
 
@@ -610,6 +681,7 @@
 	.adc_en1_mask = AXP22X_ADC_EN1_MASK,
 	.adc_rate = axp22x_adc_rate,
 	.adc_en2 = false,
+	.hwmon_en = false,
 	.maps = axp22x_maps,
 };
 
@@ -620,6 +692,7 @@
 	.adc_en1_mask = AXP22X_ADC_EN1_MASK,
 	.adc_rate = axp813_adc_rate,
 	.adc_en2 = false,
+	.hwmon_en = true,
 	.maps = axp22x_maps,
 };
 
@@ -682,6 +755,11 @@
 		regmap_update_bits(info->regmap, AXP20X_ADC_EN2,
 				   AXP20X_ADC_EN2_MASK, AXP20X_ADC_EN2_MASK);
 
+	if (of_property_read_bool(pdev->dev.of_node, "x-powers,ts-as-gpadc"))
+		regmap_update_bits(info->regmap, AXP20X_ADC_RATE,
+				   AXP20X_TS_FUNCTION_GPADC,
+				   AXP20X_TS_FUNCTION_GPADC);
+
 	/* Configure ADCs rate */
 	info->data->adc_rate(info, 100);
 
@@ -697,8 +775,23 @@
 		goto fail_register;
 	}
 
+	if (info->data->hwmon_en) {
+		/* Register hwmon device */
+		struct device *hwmon_dev;
+
+		hwmon_dev = devm_hwmon_device_register_with_info(&pdev->dev, "axp813_adc", info, &axp813_adc_hwmon_chip_info, NULL);
+		if (IS_ERR(hwmon_dev)) {
+			ret = PTR_ERR(hwmon_dev);
+			dev_err(&pdev->dev, "unable to register hwmon device %d\n", ret);
+			goto fail_hwmon;
+		}
+	}
+
 	return 0;
 
+fail_hwmon:
+	iio_device_unregister(indio_dev);
+
 fail_register:
 	iio_map_array_unregister(indio_dev);
 
diff -Nuar -r --no-dereference linux-5.15.139/drivers/iio/adc/sun4i-gpadc-iio.c linux/drivers/iio/adc/sun4i-gpadc-iio.c
--- linux-5.15.139/drivers/iio/adc/sun4i-gpadc-iio.c	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/iio/adc/sun4i-gpadc-iio.c	2024-01-03 16:06:25.935131000 +0800
@@ -19,15 +19,18 @@
  * shutdown for not being used.
  */
 
+#include <linux/clk.h>
 #include <linux/completion.h>
 #include <linux/interrupt.h>
 #include <linux/io.h>
 #include <linux/module.h>
+#include <linux/nvmem-consumer.h>
 #include <linux/of.h>
 #include <linux/of_device.h>
 #include <linux/platform_device.h>
 #include <linux/pm_runtime.h>
 #include <linux/regmap.h>
+#include <linux/reset.h>
 #include <linux/thermal.h>
 #include <linux/delay.h>
 
@@ -46,6 +49,18 @@
 	return SUN6I_GPADC_CTRL1_ADC_CHAN_SELECT(chan);
 }
 
+struct sun4i_gpadc_iio;
+
+/*
+ * Prototypes for these functions, which enable these functions to be
+ * referenced in gpadc_data structures.
+ */
+static int sun4i_gpadc_sample_start(struct sun4i_gpadc_iio *info);
+static int sun4i_gpadc_sample_end(struct sun4i_gpadc_iio *info);
+
+static int sunxi_ths_sample_start(struct sun4i_gpadc_iio *info);
+static int sunxi_ths_sample_end(struct sun4i_gpadc_iio *info);
+
 struct gpadc_data {
 	int		temp_offset;
 	int		temp_scale;
@@ -53,6 +68,21 @@
 	unsigned int	tp_adc_select;
 	unsigned int	(*adc_chan_select)(unsigned int chan);
 	unsigned int	adc_chan_mask;
+	unsigned int	temp_data[MAX_SENSOR_COUNT];
+	int		(*sample_start)(struct sun4i_gpadc_iio *info);
+	int		(*sample_end)(struct sun4i_gpadc_iio *info);
+	u32		ctrl0_map;
+	u32		ctrl2_map;
+	u32		sensor_en_map;
+	u32		filter_map;
+	u32		irq_clear_map;
+	u32		irq_control_map;
+	bool		has_bus_clk;
+	bool		has_bus_rst;
+	bool		has_mod_clk;
+	int		sensor_count;
+	bool		supports_nvmem;
+	bool		support_irq;
 };
 
 static const struct gpadc_data sun4i_gpadc_data = {
@@ -62,6 +92,12 @@
 	.tp_adc_select = SUN4I_GPADC_CTRL1_TP_ADC_SELECT,
 	.adc_chan_select = &sun4i_gpadc_chan_select,
 	.adc_chan_mask = SUN4I_GPADC_CTRL1_ADC_CHAN_MASK,
+	.temp_data = {SUN4I_GPADC_TEMP_DATA, 0, 0, 0},
+	.sample_start = sun4i_gpadc_sample_start,
+	.sample_end = sun4i_gpadc_sample_end,
+	.sensor_count = 1,
+	.supports_nvmem = false,
+	.support_irq = false,
 };
 
 static const struct gpadc_data sun5i_gpadc_data = {
@@ -71,6 +107,12 @@
 	.tp_adc_select = SUN4I_GPADC_CTRL1_TP_ADC_SELECT,
 	.adc_chan_select = &sun4i_gpadc_chan_select,
 	.adc_chan_mask = SUN4I_GPADC_CTRL1_ADC_CHAN_MASK,
+	.temp_data = {SUN4I_GPADC_TEMP_DATA, 0, 0, 0},
+	.sample_start = sun4i_gpadc_sample_start,
+	.sample_end = sun4i_gpadc_sample_end,
+	.sensor_count = 1,
+	.supports_nvmem = false,
+	.support_irq = false,
 };
 
 static const struct gpadc_data sun6i_gpadc_data = {
@@ -80,12 +122,171 @@
 	.tp_adc_select = SUN6I_GPADC_CTRL1_TP_ADC_SELECT,
 	.adc_chan_select = &sun6i_gpadc_chan_select,
 	.adc_chan_mask = SUN6I_GPADC_CTRL1_ADC_CHAN_MASK,
+	.temp_data = {SUN4I_GPADC_TEMP_DATA, 0, 0, 0},
+	.sample_start = sun4i_gpadc_sample_start,
+	.sample_end = sun4i_gpadc_sample_end,
+	.sensor_count = 1,
+	.supports_nvmem = false,
+	.support_irq = false,
 };
 
 static const struct gpadc_data sun8i_a33_gpadc_data = {
 	.temp_offset = -1662,
 	.temp_scale = 162,
-	.tp_mode_en = SUN8I_GPADC_CTRL1_CHOP_TEMP_EN,
+	.tp_mode_en = SUN8I_A33_GPADC_CTRL1_CHOP_TEMP_EN,
+	.temp_data = {SUN4I_GPADC_TEMP_DATA, 0, 0, 0},
+	.sample_start = sun4i_gpadc_sample_start,
+	.sample_end = sun4i_gpadc_sample_end,
+	.sensor_count = 1,
+	.supports_nvmem = false,
+	.support_irq = false,
+};
+
+static const struct gpadc_data sun8i_h3_ths_data = {
+	.temp_offset = -1791,
+	.temp_scale = -121,
+	.temp_data = {SUNXI_THS_TDATA0, 0, 0, 0},
+	.sample_start = sunxi_ths_sample_start,
+	.sample_end = sunxi_ths_sample_end,
+	.has_bus_clk = true,
+	.has_bus_rst = true,
+	.has_mod_clk = true,
+	.sensor_count = 1,
+	.supports_nvmem = true,
+	.support_irq = true,
+	.ctrl0_map = SUNXI_THS_ACQ0(0xff),
+	.ctrl2_map = SUNXI_THS_ACQ1(0x3f),
+	.sensor_en_map = SUNXI_THS_TEMP_SENSE_EN0,
+	.filter_map = SUNXI_THS_FILTER_EN |
+		SUNXI_THS_FILTER_TYPE(0x2),
+	.irq_clear_map = SUNXI_THS_INTS_ALARM_INT_0 |
+			SUNXI_THS_INTS_SHUT_INT_0   |
+			SUNXI_THS_INTS_TDATA_IRQ_0  |
+			SUNXI_THS_INTS_ALARM_OFF_0,
+	.irq_control_map = SUNXI_THS_INTC_TDATA_IRQ_EN0 |
+		SUNXI_THS_TEMP_PERIOD(0x7),
+};
+
+static const struct gpadc_data sun8i_a83t_ths_data = {
+	.temp_offset = -2724,
+	.temp_scale = -70,
+	.temp_data = {SUNXI_THS_TDATA0,
+		SUNXI_THS_TDATA1,
+		SUNXI_THS_TDATA2,
+		0},
+	.sample_start = sunxi_ths_sample_start,
+	.sample_end = sunxi_ths_sample_end,
+	.sensor_count = 3,
+	.supports_nvmem = false,
+	.support_irq = true,
+	.ctrl0_map = SUNXI_THS_ACQ0(0x1f3),
+	.ctrl2_map = SUNXI_THS_ACQ1(0x1f3),
+	.sensor_en_map = SUNXI_THS_TEMP_SENSE_EN0 |
+		SUNXI_THS_TEMP_SENSE_EN1 |
+		SUNXI_THS_TEMP_SENSE_EN2,
+	.filter_map = SUNXI_THS_FILTER_EN |
+		SUNXI_THS_FILTER_TYPE(0x2),
+	.irq_clear_map = SUNXI_THS_INTS_ALARM_INT_0 |
+		SUNXI_THS_INTS_ALARM_INT_1 |
+		SUNXI_THS_INTS_ALARM_INT_2 |
+		SUNXI_THS_INTS_SHUT_INT_0  |
+		SUNXI_THS_INTS_SHUT_INT_1  |
+		SUNXI_THS_INTS_SHUT_INT_2  |
+		SUNXI_THS_INTS_TDATA_IRQ_0 |
+		SUNXI_THS_INTS_TDATA_IRQ_1 |
+		SUNXI_THS_INTS_TDATA_IRQ_2,
+	.irq_control_map = SUNXI_THS_INTC_TDATA_IRQ_EN0 |
+		SUNXI_THS_INTC_TDATA_IRQ_EN1 |
+		SUNXI_THS_INTC_TDATA_IRQ_EN2 |
+		SUNXI_THS_TEMP_PERIOD(0x257),
+};
+
+static const struct gpadc_data sun9i_a80_ths_data = {
+	.temp_offset = -2794,
+	.temp_scale = -67,
+	.temp_data = {SUNXI_THS_TDATA0,
+		SUNXI_THS_TDATA1,
+		SUNXI_THS_TDATA2,
+		SUNXI_THS_TDATA3},
+	.sample_start = sunxi_ths_sample_start,
+	.sample_end = sunxi_ths_sample_end,
+	.has_bus_clk = true,
+	.has_bus_rst = true,
+	.has_mod_clk = true,
+	.sensor_count = 4,
+	.supports_nvmem = false,
+	.support_irq = true,
+	.ctrl0_map = SUNXI_THS_ACQ0(0x1f3),
+	.ctrl2_map = SUNXI_THS_TEMP_SENSE_EN0 |
+		SUNXI_THS_TEMP_SENSE_EN1 |
+		SUNXI_THS_TEMP_SENSE_EN2 |
+		SUNXI_THS_TEMP_SENSE_EN3 |
+		SUNXI_THS_ACQ1(0x1f3),
+	.filter_map = SUNXI_THS_FILTER_EN |
+		SUNXI_THS_FILTER_TYPE(0x2),
+	.irq_clear_map = SUNXI_THS_INTS_ALARM_INT_0 |
+		SUNXI_THS_INTS_ALARM_INT_1 |
+		SUNXI_THS_INTS_ALARM_INT_2 |
+		SUNXI_THS_INTS_ALARM_INT_3 |
+		SUNXI_THS_INTS_SHUT_INT_0  |
+		SUNXI_THS_INTS_SHUT_INT_1  |
+		SUNXI_THS_INTS_SHUT_INT_2  |
+		SUNXI_THS_INTS_SHUT_INT_3  |
+		SUNXI_THS_INTS_TDATA_IRQ_0 |
+		SUNXI_THS_INTS_TDATA_IRQ_1 |
+		SUNXI_THS_INTS_TDATA_IRQ_2 |
+		SUNXI_THS_INTS_TDATA_IRQ_3,
+	.irq_control_map = SUNXI_THS_INTC_TDATA_IRQ_EN0 |
+		SUNXI_THS_INTC_TDATA_IRQ_EN1 |
+		SUNXI_THS_INTC_TDATA_IRQ_EN2 |
+		SUNXI_THS_INTC_TDATA_IRQ_EN3 |
+		SUNXI_THS_TEMP_PERIOD(0x3a),
+};
+
+static const struct gpadc_data sun50i_a64_ths_data = {
+	.temp_offset = -2170,
+	.temp_scale = -117,
+	.temp_data = {SUNXI_THS_TDATA0,
+		SUNXI_THS_TDATA1,
+		SUNXI_THS_TDATA2,
+		0},
+	.sample_start = sunxi_ths_sample_start,
+	.sample_end = sunxi_ths_sample_end,
+	.has_bus_clk = true,
+	.has_bus_rst = true,
+	.has_mod_clk = true,
+	.sensor_count = 3,
+	.supports_nvmem = false,
+	.support_irq = true,
+
+	/* The final sample period is calculated as follows:
+	 * (THERMAL_PER + 1) * 4096 / 24MHz * 2^(FILTER_TYPE + 1)
+	 *
+	 * This results to about 1Hz with these settings.
+	 */
+	.ctrl0_map = SUNXI_THS_ACQ0(0xff),
+	.ctrl2_map = SUNXI_THS_TEMP_SENSE_EN0 |
+		SUNXI_THS_TEMP_SENSE_EN1 |
+		SUNXI_THS_TEMP_SENSE_EN2 |
+		SUNXI_THS_ACQ1(0x3f),
+	.filter_map = SUNXI_THS_FILTER_EN |
+		SUNXI_THS_FILTER_TYPE(0x1),
+	.irq_clear_map = SUNXI_THS_INTS_ALARM_INT_0 |
+		SUNXI_THS_INTS_ALARM_INT_1 |
+		SUNXI_THS_INTS_ALARM_INT_2 |
+		SUNXI_THS_INTS_SHUT_INT_0  |
+		SUNXI_THS_INTS_SHUT_INT_1  |
+		SUNXI_THS_INTS_SHUT_INT_2  |
+		SUNXI_THS_INTS_TDATA_IRQ_0 |
+		SUNXI_THS_INTS_TDATA_IRQ_1 |
+		SUNXI_THS_INTS_TDATA_IRQ_2 |
+		SUNXI_THS_INTS_ALARM_OFF_0 |
+		SUNXI_THS_INTS_ALARM_OFF_1 |
+		SUNXI_THS_INTS_ALARM_OFF_2,
+	.irq_control_map = SUNXI_THS_INTC_TDATA_IRQ_EN0 |
+		SUNXI_THS_INTC_TDATA_IRQ_EN1 |
+		SUNXI_THS_INTC_TDATA_IRQ_EN2 |
+		SUNXI_THS_TEMP_PERIOD(0x7),
 };
 
 struct sun4i_gpadc_iio {
@@ -100,6 +301,12 @@
 	atomic_t			ignore_temp_data_irq;
 	const struct gpadc_data		*data;
 	bool				no_irq;
+	struct clk			*bus_clk;
+	struct clk			*mod_clk;
+	struct reset_control		*reset;
+	int				sensor_id;
+	u32				calibration_data[2];
+	bool				has_calibration_data[2];
 	/* prevents concurrent reads of temperature and ADC */
 	struct mutex			mutex;
 	struct thermal_zone_device	*tzd;
@@ -267,14 +474,15 @@
 	return sun4i_gpadc_read(indio_dev, channel, val, info->fifo_data_irq);
 }
 
-static int sun4i_gpadc_temp_read(struct iio_dev *indio_dev, int *val)
+static int sun4i_gpadc_temp_read(struct iio_dev *indio_dev, int *val,
+				int sensor)
 {
 	struct sun4i_gpadc_iio *info = iio_priv(indio_dev);
 
 	if (info->no_irq) {
 		pm_runtime_get_sync(indio_dev->dev.parent);
 
-		regmap_read(info->regmap, SUN4I_GPADC_TEMP_DATA, val);
+		regmap_read(info->regmap, info->data->temp_data[sensor], val);
 
 		pm_runtime_mark_last_busy(indio_dev->dev.parent);
 		pm_runtime_put_autosuspend(indio_dev->dev.parent);
@@ -282,6 +490,11 @@
 		return 0;
 	}
 
+	if (info->data->support_irq) {
+		regmap_read(info->regmap, info->data->temp_data[sensor], val);
+		return 0;
+	}
+
 	return sun4i_gpadc_read(indio_dev, 0, val, info->temp_data_irq);
 }
 
@@ -321,7 +534,7 @@
 			ret = sun4i_gpadc_adc_read(indio_dev, chan->channel,
 						   val);
 		else
-			ret = sun4i_gpadc_temp_read(indio_dev, val);
+			ret = sun4i_gpadc_temp_read(indio_dev, val, 0);
 
 		if (ret)
 			return ret;
@@ -379,10 +592,19 @@
 	return IRQ_HANDLED;
 }
 
-static int sun4i_gpadc_runtime_suspend(struct device *dev)
+static irqreturn_t sunxi_irq_thread(int irq, void *data)
 {
-	struct sun4i_gpadc_iio *info = iio_priv(dev_get_drvdata(dev));
+	struct sun4i_gpadc_iio *info = data;
+
+	regmap_write(info->regmap, SUNXI_THS_STAT, info->data->irq_clear_map);
 
+	thermal_zone_device_update(info->tzd, THERMAL_EVENT_TEMP_SAMPLE);
+
+	return IRQ_HANDLED;
+}
+
+static int sun4i_gpadc_sample_end(struct sun4i_gpadc_iio *info)
+{
 	/* Disable the ADC on IP */
 	regmap_write(info->regmap, SUN4I_GPADC_CTRL1, 0);
 	/* Disable temperature sensor on IP */
@@ -391,19 +613,51 @@
 	return 0;
 }
 
-static int sun4i_gpadc_runtime_resume(struct device *dev)
+static int sunxi_ths_sample_end(struct sun4i_gpadc_iio *info)
+{
+	/* Disable ths interrupt*/
+	regmap_write(info->regmap, SUNXI_THS_INTC, 0x0);
+	/* Disable temperature sensor */
+	regmap_write(info->regmap, SUNXI_THS_CTRL2, 0x0);
+
+	return 0;
+}
+
+static int sun4i_gpadc_runtime_suspend(struct device *dev)
 {
 	struct sun4i_gpadc_iio *info = iio_priv(dev_get_drvdata(dev));
 
+	if (info->data->has_mod_clk)
+		clk_disable(info->mod_clk);
+
+	if (info->data->has_bus_clk)
+		clk_disable(info->bus_clk);
+
+	return info->data->sample_end(info);
+}
+
+static void sunxi_calibrate(struct sun4i_gpadc_iio *info)
+{
+	if (info->has_calibration_data[0])
+		regmap_write(info->regmap, SUNXI_THS_CDATA_0_1,
+			info->calibration_data[0]);
+
+	if (info->has_calibration_data[1])
+		regmap_write(info->regmap, SUNXI_THS_CDATA_2_3,
+			info->calibration_data[1]);
+}
+
+static int sun4i_gpadc_sample_start(struct sun4i_gpadc_iio *info)
+{
 	/* clkin = 6MHz */
 	regmap_write(info->regmap, SUN4I_GPADC_CTRL0,
 		     SUN4I_GPADC_CTRL0_ADC_CLK_DIVIDER(2) |
 		     SUN4I_GPADC_CTRL0_FS_DIV(7) |
-		     SUN4I_GPADC_CTRL0_T_ACQ(63));
+		     SUNXI_THS_ACQ0(63));
 	regmap_write(info->regmap, SUN4I_GPADC_CTRL1, info->data->tp_mode_en);
 	regmap_write(info->regmap, SUN4I_GPADC_CTRL3,
-		     SUN4I_GPADC_CTRL3_FILTER_EN |
-		     SUN4I_GPADC_CTRL3_FILTER_TYPE(1));
+		     SUNXI_THS_FILTER_EN |
+		     SUNXI_THS_FILTER_TYPE(1));
 	/* period = SUN4I_GPADC_TPR_TEMP_PERIOD * 256 * 16 / clkin; ~0.6s */
 	regmap_write(info->regmap, SUN4I_GPADC_TPR,
 		     SUN4I_GPADC_TPR_TEMP_ENABLE |
@@ -412,12 +666,60 @@
 	return 0;
 }
 
+static int sunxi_ths_sample_start(struct sun4i_gpadc_iio *info)
+{
+	u32 value;
+	sunxi_calibrate(info);
+
+	if (info->data->ctrl0_map)
+		regmap_write(info->regmap, SUNXI_THS_CTRL0,
+			info->data->ctrl0_map);
+
+	regmap_write(info->regmap, SUNXI_THS_CTRL2,
+		info->data->ctrl2_map);
+
+	regmap_write(info->regmap, SUNXI_THS_STAT,
+			info->data->irq_clear_map);
+
+	regmap_write(info->regmap, SUNXI_THS_FILTER,
+		info->data->filter_map);
+
+	regmap_write(info->regmap, SUNXI_THS_INTC,
+		info->data->irq_control_map);
+
+	regmap_read(info->regmap, SUNXI_THS_CTRL2, &value);
+
+	regmap_write(info->regmap, SUNXI_THS_CTRL2,
+		info->data->sensor_en_map | value);
+
+	return 0;
+}
+
+static int sun4i_gpadc_runtime_resume(struct device *dev)
+{
+	struct sun4i_gpadc_iio *info = iio_priv(dev_get_drvdata(dev));
+
+	if (info->data->has_mod_clk)
+		clk_enable(info->mod_clk);
+
+	if (info->data->has_bus_clk)
+		clk_enable(info->bus_clk);
+
+	return info->data->sample_start(info);
+}
+
 static int sun4i_gpadc_get_temp(void *data, int *temp)
 {
 	struct sun4i_gpadc_iio *info = data;
 	int val, scale, offset;
 
-	if (sun4i_gpadc_temp_read(info->indio_dev, &val))
+	if (sun4i_gpadc_temp_read(info->indio_dev, &val, info->sensor_id))
+		return -ETIMEDOUT;
+
+	/* Ignore first sample which is always zero. 0 is either too
+	 * cold or too hot, so we can safely ignore it
+	 */
+	if (val == 0)
 		return -ETIMEDOUT;
 
 	sun4i_gpadc_temp_scale(info->indio_dev, &scale);
@@ -489,6 +791,22 @@
 		.compatible = "allwinner,sun8i-a33-ths",
 		.data = &sun8i_a33_gpadc_data,
 	},
+	{
+		.compatible = "allwinner,sun8i-h3-ths",
+		.data = &sun8i_h3_ths_data,
+	},
+	{
+		.compatible = "allwinner,sun8i-a83t-ths",
+		.data = &sun8i_a83t_ths_data,
+	},
+	{
+		.compatible = "allwinner,sun9i-a80-ths",
+		.data = &sun9i_a80_ths_data,
+	},
+	{
+		.compatible = "allwinner,sun50i-a64-ths",
+		.data = &sun50i_a64_ths_data,
+	},
 	{ /* sentinel */ }
 };
 
@@ -498,12 +816,32 @@
 	struct sun4i_gpadc_iio *info = iio_priv(indio_dev);
 	void __iomem *base;
 	int ret;
+	struct nvmem_cell *cell;
+	ssize_t cell_size;
+	u64 *cell_data;
+	int irq;
 
 	info->data = of_device_get_match_data(&pdev->dev);
 	if (!info->data)
 		return -ENODEV;
 
-	info->no_irq = true;
+	if (info->data->support_irq) {
+		/* only the new versions of ths support right now irqs */
+		irq = platform_get_irq(pdev, 0);
+		if (irq < 0) {
+			dev_err(&pdev->dev, "failed to get IRQ: %d\n", irq);
+			return irq;
+		}
+
+		ret = devm_request_threaded_irq(&pdev->dev, irq, NULL,
+				sunxi_irq_thread, IRQF_ONESHOT,
+				dev_name(&pdev->dev), info);
+		if (ret)
+			return ret;
+
+	} else
+		info->no_irq = true;
+
 	indio_dev->num_channels = ARRAY_SIZE(sun8i_a33_gpadc_channels);
 	indio_dev->channels = sun8i_a33_gpadc_channels;
 
@@ -511,6 +849,35 @@
 	if (IS_ERR(base))
 		return PTR_ERR(base);
 
+	info->has_calibration_data[0] = false;
+	info->has_calibration_data[1] = false;
+
+	if (!info->data->supports_nvmem)
+		goto no_nvmem;
+
+	cell = devm_nvmem_cell_get(&pdev->dev, "calibration");
+	if (IS_ERR(cell)) {
+		if (PTR_ERR(cell) == -EPROBE_DEFER)
+			return PTR_ERR(cell);
+	} else {
+		cell_data = (u64 *)nvmem_cell_read(cell, &cell_size);
+		devm_nvmem_cell_put(&pdev->dev, cell);
+		if (cell_size <= 4) {
+			info->has_calibration_data[0] = true;
+			info->calibration_data[0] = be32_to_cpu(cell_data[0] &
+					GENMASK(31, 0));
+		} else if (cell_size <= 8) {
+			info->has_calibration_data[0] = true;
+			info->calibration_data[0] = be32_to_cpu(cell_data[0] &
+					GENMASK(31, 0));
+			info->has_calibration_data[1] = true;
+			info->calibration_data[1] = be32_to_cpu(
+					(cell_data[0] >> 32) & GENMASK(31, 0));
+		}
+	}
+
+no_nvmem:
+
 	info->regmap = devm_regmap_init_mmio(&pdev->dev, base,
 					     &sun4i_gpadc_regmap_config);
 	if (IS_ERR(info->regmap)) {
@@ -519,10 +886,61 @@
 		return ret;
 	}
 
+	if (info->data->has_bus_rst) {
+		info->reset = devm_reset_control_get(&pdev->dev, NULL);
+		if (IS_ERR(info->reset)) {
+			ret = PTR_ERR(info->reset);
+			return ret;
+		}
+
+		ret = reset_control_deassert(info->reset);
+		if (ret)
+			return ret;
+	}
+
+	if (info->data->has_bus_clk) {
+		info->bus_clk = devm_clk_get(&pdev->dev, "bus");
+		if (IS_ERR(info->bus_clk)) {
+			ret = PTR_ERR(info->bus_clk);
+			goto assert_reset;
+		}
+
+		ret = clk_prepare_enable(info->bus_clk);
+		if (ret)
+			goto assert_reset;
+	}
+
+	if (info->data->has_mod_clk) {
+		info->mod_clk = devm_clk_get(&pdev->dev, "mod");
+		if (IS_ERR(info->mod_clk)) {
+			ret = PTR_ERR(info->mod_clk);
+			goto disable_bus_clk;
+		}
+
+		/* Running at 6MHz */
+		ret = clk_set_rate(info->mod_clk, 4000000);
+		if (ret)
+			goto disable_bus_clk;
+
+		ret = clk_prepare_enable(info->mod_clk);
+		if (ret)
+			goto disable_bus_clk;
+	}
+
 	if (IS_ENABLED(CONFIG_THERMAL_OF))
 		info->sensor_device = &pdev->dev;
 
 	return 0;
+
+disable_bus_clk:
+	if (info->data->has_bus_clk)
+		clk_disable_unprepare(info->bus_clk);
+
+assert_reset:
+	if (info->data->has_bus_rst)
+		reset_control_assert(info->reset);
+
+	return ret;
 }
 
 static int sun4i_gpadc_probe_mfd(struct platform_device *pdev,
@@ -606,7 +1024,7 @@
 {
 	struct sun4i_gpadc_iio *info;
 	struct iio_dev *indio_dev;
-	int ret;
+	int ret, i;
 
 	indio_dev = devm_iio_device_alloc(&pdev->dev, sizeof(*info));
 	if (!indio_dev)
@@ -622,7 +1040,8 @@
 	indio_dev->info = &sun4i_gpadc_iio_info;
 	indio_dev->modes = INDIO_DIRECT_MODE;
 
-	if (pdev->dev.of_node)
+	if (pdev->dev.of_node && of_match_node(sun4i_gpadc_of_id,
+					       pdev->dev.of_node))
 		ret = sun4i_gpadc_probe_dt(pdev, indio_dev);
 	else
 		ret = sun4i_gpadc_probe_mfd(pdev, indio_dev);
@@ -630,16 +1049,21 @@
 	if (ret)
 		return ret;
 
-	pm_runtime_set_autosuspend_delay(&pdev->dev,
-					 SUN4I_GPADC_AUTOSUSPEND_DELAY);
-	pm_runtime_use_autosuspend(&pdev->dev);
-	pm_runtime_set_suspended(&pdev->dev);
-	pm_runtime_enable(&pdev->dev);
+	if (!info->data->support_irq) {
+		pm_runtime_set_autosuspend_delay(&pdev->dev,
+						 SUN4I_GPADC_AUTOSUSPEND_DELAY);
+		pm_runtime_use_autosuspend(&pdev->dev);
+		pm_runtime_set_suspended(&pdev->dev);
+		pm_runtime_enable(&pdev->dev);
+	}
 
 	if (IS_ENABLED(CONFIG_THERMAL_OF)) {
-		info->tzd = thermal_zone_of_sensor_register(info->sensor_device,
-							    0, info,
-							    &sun4i_ts_tz_ops);
+		for (i = 0; i < info->data->sensor_count; i++) {
+			info->sensor_id = i;
+			info->tzd = thermal_zone_of_sensor_register(
+					info->sensor_device,
+					i, info, &sun4i_ts_tz_ops);
+		}
 		/*
 		 * Do not fail driver probing when failing to register in
 		 * thermal because no thermal DT node is found.
@@ -652,6 +1076,9 @@
 		}
 	}
 
+	if (info->data->support_irq)
+		info->data->sample_start(info);
+
 	ret = devm_iio_device_register(&pdev->dev, indio_dev);
 	if (ret < 0) {
 		dev_err(&pdev->dev, "could not register the device\n");
@@ -681,11 +1108,23 @@
 	if (!IS_ENABLED(CONFIG_THERMAL_OF))
 		return 0;
 
+	if (info->data->support_irq)
+		info->data->sample_end(info);
+
 	thermal_zone_of_sensor_unregister(info->sensor_device, info->tzd);
 
 	if (!info->no_irq)
 		iio_map_array_unregister(indio_dev);
 
+	if (info->data->has_mod_clk)
+		clk_disable_unprepare(info->mod_clk);
+
+	if (info->data->has_bus_clk)
+		clk_disable_unprepare(info->bus_clk);
+
+	if (info->data->has_bus_rst)
+		reset_control_assert(info->reset);
+
 	return 0;
 }
 
diff -Nuar -r --no-dereference linux-5.15.139/drivers/clocksource/arm_arch_timer.c linux/drivers/clocksource/arm_arch_timer.c
--- linux-5.15.139/drivers/clocksource/arm_arch_timer.c	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/clocksource/arm_arch_timer.c	2024-01-03 16:06:25.935131000 +0800
@@ -357,17 +357,20 @@
  * with all ones or all zeros in the low bits. Bound the loop by the maximum
  * number of CPU cycles in 3 consecutive 24 MHz counter periods.
  */
-#define __sun50i_a64_read_reg(reg) ({					\
-	u64 _val;							\
-	int _retries = 150;						\
-									\
-	do {								\
-		_val = read_sysreg(reg);				\
-		_retries--;						\
-	} while (((_val + 1) & GENMASK(8, 0)) <= 1 && _retries);	\
-									\
-	WARN_ON_ONCE(!_retries);					\
-	_val;								\
+#define __sun50i_a64_read_reg(reg) ({                                                 \
+    register u64 _tries = 5, _old, _new;                                              \
+                                                                                      \
+    do {                                                                              \
+        if (unlikely(_tries < 3))                                                     \
+            isb();                                                                    \
+        _old = read_sysreg(reg);                                                      \
+        _new = read_sysreg(reg);                                                      \
+    } while (unlikely((_new - _old) >> 4) && --_tries);                               \
+                                                                                      \
+    if (unlikely(!_tries))                                                            \
+        pr_err("(cpu %d) returning possibly incorrect counter value %llx (%llx)\n",   \
+                smp_processor_id() + 1, _new, _old);                                  \
+   _new;                                                                              \
 })
 
 static u64 notrace sun50i_a64_read_cntpct_el0(void)
diff -Nuar -r --no-dereference linux-5.15.139/drivers/leds/Makefile linux/drivers/leds/Makefile
--- linux-5.15.139/drivers/leds/Makefile	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/leds/Makefile	2024-01-03 16:06:25.935131000 +0800
@@ -87,6 +87,7 @@
 obj-$(CONFIG_LEDS_WM831X_STATUS)	+= leds-wm831x-status.o
 obj-$(CONFIG_LEDS_WM8350)		+= leds-wm8350.o
 obj-$(CONFIG_LEDS_WRAP)			+= leds-wrap.o
+obj-$(CONFIG_LEDS_AXP20X)		+= leds-axp20x.o
 
 # LED SPI Drivers
 obj-$(CONFIG_LEDS_CR0014114)		+= leds-cr0014114.o
diff -Nuar -r --no-dereference linux-5.15.139/drivers/leds/Kconfig linux/drivers/leds/Kconfig
--- linux-5.15.139/drivers/leds/Kconfig	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/leds/Kconfig	2024-01-03 16:06:25.935131000 +0800
@@ -864,6 +864,14 @@
 	  To compile this driver as a module, choose M here: the module
 	  will be called leds-ip30.
 
+config LEDS_SGM3140
+	tristate "LED support for the SGM3140"
+	depends on LEDS_CLASS_FLASH
+	depends on V4L2_FLASH_LED_CLASS || !V4L2_FLASH_LED_CLASS
+	help
+	  This option enables support for the SGM3140 500mA Buck/Boost Charge
+	  Pump LED Driver.
+
 config LEDS_ACER_A500
 	tristate "Power button LED support for Acer Iconia Tab A500"
 	depends on LEDS_CLASS && MFD_ACER_A500_EC
@@ -871,6 +879,13 @@
 	  This option enables support for the Power Button LED of
 	  Acer Iconia Tab A500.
 
+config LEDS_AXP20X
+	tristate "Charger LED support for AXP20X-like PMICs (AXP813, ...)"
+	depends on LEDS_CLASS && MFD_AXP20X
+	help
+	  This option enables support for on-chip LED driver on
+	  AXP20X-like PMICs.
+
 source "drivers/leds/blink/Kconfig"
 
 comment "Flash and Torch LED drivers"
diff -Nuar -r --no-dereference linux-5.15.139/drivers/leds/leds-axp20x.c linux/drivers/leds/leds-axp20x.c
--- linux-5.15.139/drivers/leds/leds-axp20x.c	1970-01-01 08:00:00.000000000 +0800
+++ linux/drivers/leds/leds-axp20x.c	2024-01-03 16:06:25.935131000 +0800
@@ -0,0 +1,255 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * LED Driver for X-Powers AXP813 PMIC and similar.
+ *
+ * Copyright(c) 2020 Ondrej Jirman <megous@megous.com>
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/leds.h>
+#include <linux/slab.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/mfd/axp20x.h>
+
+#define AXP20X_CHGLED_CTRL_MASK		BIT(3)
+#define AXP20X_CHGLED_CTRL_CHARGER	BIT(3)
+#define AXP20X_CHGLED_CTRL_USER		0
+
+#define AXP20X_CHRG_CTRL2_MODE		BIT(4)
+
+#define AXP20X_CHGLED_USER_STATE_MASK		GENMASK(5, 4)
+#define AXP20X_CHGLED_USER_STATE_OFF		(0 << 4)
+#define AXP20X_CHGLED_USER_STATE_BLINK_SLOW	(1 << 4)
+#define AXP20X_CHGLED_USER_STATE_BLINK_FAST	(2 << 4)
+#define AXP20X_CHGLED_USER_STATE_ON		(3 << 4)
+
+static struct led_hw_trigger_type axp20x_charger_led_trigger_type;
+
+struct axp20x_led {
+	struct led_classdev cdev;
+	struct regmap *regmap;
+};
+
+static int axp20x_led_set(struct led_classdev *led_cdev,
+			   enum led_brightness value)
+{
+	struct axp20x_led *led =
+			container_of(led_cdev, struct axp20x_led, cdev);
+	unsigned int val;
+
+	val = value == LED_OFF ? AXP20X_CHGLED_USER_STATE_OFF :
+		AXP20X_CHGLED_USER_STATE_ON;
+
+	return regmap_update_bits(led->regmap, AXP20X_OFF_CTRL,
+				  AXP20X_CHGLED_USER_STATE_MASK, val);
+
+}
+
+static int axp20x_set_charger_control(struct led_classdev *led_cdev, bool on)
+{
+	struct axp20x_led *led = container_of(led_cdev, struct axp20x_led, cdev);
+
+	return regmap_update_bits(led->regmap, AXP20X_OFF_CTRL,
+				  AXP20X_CHGLED_CTRL_MASK,
+				  on ? AXP20X_CHGLED_CTRL_CHARGER :
+				  AXP20X_CHGLED_CTRL_USER);
+}
+
+static int axp20x_trig_charger_activate(struct led_classdev *led_cdev)
+{
+	return axp20x_set_charger_control(led_cdev, true);
+}
+
+static void axp20x_trig_charger_deactivate(struct led_classdev *led_cdev)
+{
+	axp20x_set_charger_control(led_cdev, false);
+}
+
+static ssize_t charger_mode_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct led_classdev *led_cdev = led_trigger_get_led(dev);
+	struct axp20x_led *led = container_of(led_cdev, struct axp20x_led, cdev);
+	unsigned int val;
+	int ret;
+
+	ret = regmap_read(led->regmap, AXP20X_CHRG_CTRL2, &val);
+	if (ret)
+		return ret;
+
+	return scnprintf(buf, PAGE_SIZE, "%u\n",
+			 val & AXP20X_CHRG_CTRL2_MODE ? 1 : 0);
+}
+
+static ssize_t charger_mode_store(struct device *dev,
+				  struct device_attribute *attr,
+				  const char *buf, size_t len)
+{
+	struct led_classdev *led_cdev = led_trigger_get_led(dev);
+	struct axp20x_led *led = container_of(led_cdev, struct axp20x_led, cdev);
+	unsigned int mode;
+	int ret;
+
+	ret = kstrtouint(buf, 0, &mode);
+	if (ret)
+		return ret;
+
+	if (mode > 1)
+		return -ERANGE;
+
+	ret = regmap_update_bits(led->regmap, AXP20X_CHRG_CTRL2,
+				 AXP20X_CHRG_CTRL2_MODE,
+				 mode ? AXP20X_CHRG_CTRL2_MODE : 0);
+	if (ret)
+		return ret;
+
+	return len;
+}
+static DEVICE_ATTR_RW(charger_mode);
+
+static struct attribute *axp20x_led_attrs[] = {
+	&dev_attr_charger_mode.attr,
+	NULL,
+};
+
+ATTRIBUTE_GROUPS(axp20x_led);
+
+static struct led_trigger axp20x_charger_led_trigger = {
+	.name		= "charger",
+	.trigger_type	= &axp20x_charger_led_trigger_type,
+	.activate	= axp20x_trig_charger_activate,
+	.deactivate	= axp20x_trig_charger_deactivate,
+	.groups		= axp20x_led_groups,
+};
+
+static int axp20x_led_probe(struct platform_device *pdev)
+{
+	struct axp20x_dev *axp20x;
+	struct axp20x_led *led;
+	unsigned int val;
+	int ret;
+
+	if (!of_device_is_available(pdev->dev.of_node))
+		return -ENODEV;
+
+	axp20x = dev_get_drvdata(pdev->dev.parent);
+	if (!axp20x)
+		return -EINVAL;
+
+	led = devm_kzalloc(&pdev->dev,
+			   sizeof(struct axp20x_led),
+			   GFP_KERNEL);
+	if (!led)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, led);
+
+	led->regmap = axp20x->regmap;
+
+	led->cdev.name = "axp20x-chgarger-led";
+	led->cdev.brightness_set_blocking = axp20x_led_set;
+	led->cdev.brightness = LED_OFF;
+	led->cdev.max_brightness = 1;
+	led->cdev.trigger_type = &axp20x_charger_led_trigger_type;
+
+	ret = regmap_read(led->regmap, AXP20X_OFF_CTRL, &val);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to read charger control status\n");
+		return ret;
+	}
+
+	if ((val & AXP20X_CHGLED_CTRL_MASK) == AXP20X_CHGLED_CTRL_CHARGER)
+		led->cdev.default_trigger = axp20x_charger_led_trigger.name;
+
+	ret = devm_led_classdev_register(pdev->dev.parent, &led->cdev);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to register led %s\n",
+			led->cdev.name);
+		return ret;
+	}
+
+	ret = regmap_update_bits(led->regmap, AXP20X_OFF_CTRL,
+				 AXP20X_CHGLED_CTRL_MASK,
+				 AXP20X_CHGLED_CTRL_CHARGER);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to enable charger control\n");
+		return ret;
+	}
+
+	ret = axp20x_led_set(&led->cdev, led->cdev.brightness);
+	if (ret) {
+		dev_err(&pdev->dev, "Failed to init led brightness\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static void axp20x_led_shutdown(struct platform_device *pdev)
+{
+	struct axp20x_led *led = platform_get_drvdata(pdev);
+
+	/* On shutdown, we want to give LED control back to the PMIC,
+	 * so that it doesn't stay on, while the system is off.
+	 */
+
+	axp20x_led_set(&led->cdev, LED_OFF);
+	axp20x_set_charger_control(&led->cdev, true);
+}
+
+static int axp20x_led_remove(struct platform_device *pdev)
+{
+	axp20x_led_shutdown(pdev);
+
+	return 0;
+}
+
+static const struct of_device_id axp20x_leds_of_match[] = {
+	{ .compatible = "x-powers,axp813-charger-led", },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, axp20x_leds_of_match);
+
+static struct platform_driver axp20x_led_driver = {
+	.driver		= {
+		.name	= "leds-axp20x",
+		.of_match_table = axp20x_leds_of_match,
+	},
+	.probe		= axp20x_led_probe,
+	.remove		= axp20x_led_remove,
+	.shutdown	= axp20x_led_shutdown,
+};
+
+static int __init axp20x_led_driver_init(void)
+{
+	int ret;
+
+	ret = led_trigger_register(&axp20x_charger_led_trigger);
+	if (ret)
+		return ret;
+
+	ret = platform_driver_register(&axp20x_led_driver);
+	if (ret) {
+		led_trigger_unregister(&axp20x_charger_led_trigger);
+		return ret;
+	}
+
+	return 0;
+}
+
+static void __exit axp20x_led_driver_exit(void)
+{
+	platform_driver_unregister(&axp20x_led_driver);
+	led_trigger_unregister(&axp20x_charger_led_trigger);
+}
+
+module_init(axp20x_led_driver_init);
+module_exit(axp20x_led_driver_exit);
+
+MODULE_AUTHOR("Ondrej Jirman <megous@megous.com>");
+MODULE_DESCRIPTION("LED driver for AXP813 PMIC");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:leds-axp20x");
diff -Nuar -r --no-dereference linux-5.15.139/drivers/net/ethernet/stmicro/stmmac/dwmac-sun8i.c linux/drivers/net/ethernet/stmicro/stmmac/dwmac-sun8i.c
--- linux-5.15.139/drivers/net/ethernet/stmicro/stmmac/dwmac-sun8i.c	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/net/ethernet/stmicro/stmmac/dwmac-sun8i.c	2024-01-03 16:06:25.935131000 +0800
@@ -57,20 +57,25 @@
 };
 
 /* struct sunxi_priv_data - hold all sunxi private data
- * @tx_clk:	reference to MAC TX clock
- * @ephy_clk:	reference to the optional EPHY clock for the internal PHY
- * @regulator:	reference to the optional regulator
- * @rst_ephy:	reference to the optional EPHY reset for the internal PHY
- * @variant:	reference to the current board variant
- * @regmap:	regmap for using the syscon
- * @internal_phy_powered: Does the internal PHY is enabled
- * @use_internal_phy: Is the internal PHY selected for use
- * @mux_handle:	Internal pointer used by mdio-mux lib
+ * @tx_clk:			reference to MAC TX clock
+ * @ephy_clk:			reference to the optional EPHY clock for
+ *				the internal PHY
+ * @regulator_phy:		reference to the optional regulator
+ * @regulator_phy_io:		reference to the optional regulator for
+ *				PHY I/O pins
+ * @rst_ephy:			reference to the optional EPHY reset for
+ *				the internal PHY
+ * @variant:			reference to the current board variant
+ * @regmap:			regmap for using the syscon
+ * @internal_phy_powered:	Does the internal PHY is enabled
+ * @use_internal_phy:		Is the internal PHY selected for use
+ * @mux_handle:			Internal pointer used by mdio-mux lib
  */
 struct sunxi_priv_data {
 	struct clk *tx_clk;
 	struct clk *ephy_clk;
-	struct regulator *regulator;
+	struct regulator *regulator_phy;
+	struct regulator *regulator_phy_io;
 	struct reset_control *rst_ephy;
 	const struct emac_variant *variant;
 	struct regmap_field *regmap_field;
@@ -571,12 +576,16 @@
 	struct sunxi_priv_data *gmac = priv;
 	int ret;
 
-	if (gmac->regulator) {
-		ret = regulator_enable(gmac->regulator);
-		if (ret) {
-			dev_err(&pdev->dev, "Fail to enable regulator\n");
-			return ret;
-		}
+	ret = regulator_enable(gmac->regulator_phy_io);
+	if (ret) {
+		dev_err(&pdev->dev, "Fail to enable PHY I/O regulator\n");
+		return ret;
+	}
+
+	ret = regulator_enable(gmac->regulator_phy);
+	if (ret) {
+		dev_err(&pdev->dev, "Fail to enable PHY regulator\n");
+		goto err_disable_regulator_phy_io;
 	}
 
 	ret = clk_prepare_enable(gmac->tx_clk);
@@ -596,8 +605,9 @@
 err_disable_clk:
 	clk_disable_unprepare(gmac->tx_clk);
 err_disable_regulator:
-	if (gmac->regulator)
-		regulator_disable(gmac->regulator);
+	regulator_disable(gmac->regulator_phy);
+err_disable_regulator_phy_io:
+	regulator_disable(gmac->regulator_phy_io);
 
 	return ret;
 }
@@ -1046,8 +1056,8 @@
 
 	clk_disable_unprepare(gmac->tx_clk);
 
-	if (gmac->regulator)
-		regulator_disable(gmac->regulator);
+	regulator_disable(gmac->regulator_phy);
+	regulator_disable(gmac->regulator_phy_io);
 }
 
 static void sun8i_dwmac_set_mac_loopback(void __iomem *ioaddr, bool enable)
@@ -1148,11 +1158,13 @@
 	struct stmmac_resources stmmac_res;
 	struct sunxi_priv_data *gmac;
 	struct device *dev = &pdev->dev;
+	struct reg_field syscon_field;
 	phy_interface_t interface;
 	int ret;
 	struct stmmac_priv *priv;
 	struct net_device *ndev;
 	struct regmap *regmap;
+	u32 syscon_idx = 0;
 
 	ret = stmmac_get_platform_resources(pdev, &stmmac_res);
 	if (ret)
@@ -1175,12 +1187,19 @@
 	}
 
 	/* Optional regulator for PHY */
-	gmac->regulator = devm_regulator_get_optional(dev, "phy");
-	if (IS_ERR(gmac->regulator)) {
-		if (PTR_ERR(gmac->regulator) == -EPROBE_DEFER)
-			return -EPROBE_DEFER;
-		dev_info(dev, "No regulator found\n");
-		gmac->regulator = NULL;
+	gmac->regulator_phy = devm_regulator_get(dev, "phy");
+	if (IS_ERR(gmac->regulator_phy)) {
+		ret = PTR_ERR(gmac->regulator_phy);
+		dev_err_probe(dev, ret, "Failed to get PHY regulator\n");
+		return ret;
+	}
+
+	/* Optional regulator for PHY I/O pins */
+	gmac->regulator_phy_io = devm_regulator_get(dev, "phy-io");
+	if (IS_ERR(gmac->regulator_phy_io)) {
+		ret = PTR_ERR(gmac->regulator_phy_io);
+		dev_err_probe(dev, ret, "Failed to get PHY I/O regulator\n");
+		return ret;
 	}
 
 	/* The "GMAC clock control" register might be located in the
@@ -1210,8 +1229,12 @@
 		return ret;
 	}
 
-	gmac->regmap_field = devm_regmap_field_alloc(dev, regmap,
-						     *gmac->variant->syscon_field);
+	syscon_field = *gmac->variant->syscon_field;
+	ret = of_property_read_u32_index(pdev->dev.of_node, "syscon", 1,
+					 &syscon_idx);
+	if (!ret)
+		syscon_field.reg += syscon_idx * sizeof(u32);
+	gmac->regmap_field = devm_regmap_field_alloc(dev, regmap, syscon_field);
 	if (IS_ERR(gmac->regmap_field)) {
 		ret = PTR_ERR(gmac->regmap_field);
 		dev_err(dev, "Unable to map syscon register: %d\n", ret);
@@ -1331,6 +1354,8 @@
 		.data = &emac_variant_a64 },
 	{ .compatible = "allwinner,sun50i-h6-emac",
 		.data = &emac_variant_h6 },
+	{ .compatible = "allwinner,sun50i-h616-emac",
+		.data = &emac_variant_h6 },
 	{ }
 };
 MODULE_DEVICE_TABLE(of, sun8i_dwmac_match);
diff -Nuar -r --no-dereference linux-5.15.139/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c linux/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
--- linux-5.15.139/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c	2024-01-03 16:06:25.935131000 +0800
@@ -141,6 +141,9 @@
 
 #define STMMAC_COAL_TIMER(x) (ns_to_ktime((x) * NSEC_PER_USEC))
 
+#define RTL_8211E_PHY_ID  0x001cc915
+#define RTL_8211F_PHY_ID  0x001cc916
+
 int stmmac_bus_clks_config(struct stmmac_priv *priv, bool enabled)
 {
 	int ret = 0;
@@ -7000,6 +7003,54 @@
 	}
 }
 
+static int phy_rtl8211e_led_fixup(struct phy_device *phydev)
+{
+       //int val;
+
+       printk("%s in\n", __func__);
+
+       /*switch to extension page44*/
+       phy_write(phydev, 31, 0x07);
+       phy_write(phydev, 30, 0x2c);
+
+       /*set led1(yellow) act
+       val = phy_read(phydev, 26);
+       val &= (~(1<<4));// bit4=0
+       val |= (1<<5);// bit5=1
+       val &= (~(1<<6));// bit6=0*/
+       phy_write(phydev, 26, 0x20);
+
+       /*set led0(green) link
+       val = phy_read(phydev, 28);
+       val |= (7<<0);// bit0,1,2=1
+       val &= (~(7<<4));// bit4,5,6=0
+       val &= (~(7<<8));// bit8,9,10=0*/
+       phy_write(phydev, 28, 0x07);
+
+       /*switch back to page0*/
+       phy_write(phydev,31,0x00);
+
+       return 0;
+}
+
+static int phy_rtl8211f_led_fixup(struct phy_device *phydev)
+{
+       printk("%s in\n", __func__);
+
+       /*switch to extension page44*/
+       phy_write(phydev, 31, 0xd04);
+
+       /*set led1(yellow) act */
+       /*set led2(green) link*/
+       phy_write(phydev, 16, 0xae00);
+
+       phy_write(phydev, 17, 0);
+       /*switch back to page0*/
+       phy_write(phydev,31,0x00);
+
+       return 0;
+}
+
 /**
  * stmmac_dvr_probe
  * @device: device pointer
@@ -7259,6 +7310,15 @@
 		goto error_phy_setup;
 	}
 
+	/* register the PHY board fixup */
+	ret = phy_register_fixup_for_uid(RTL_8211E_PHY_ID, 0xffffffff, phy_rtl8211e_led_fixup);
+	if (ret)
+		pr_warn("Cannot register PHY board fixup.\n");
+
+	ret = phy_register_fixup_for_uid(RTL_8211F_PHY_ID, 0xffffffff, phy_rtl8211f_led_fixup);
+	if (ret)
+		pr_warn("Cannot register PHY board fixup.\n");
+
 	ret = register_netdev(ndev);
 	if (ret) {
 		dev_err(priv->device, "%s: ERROR %i registering the device\n",
diff -Nuar -r --no-dereference linux-5.15.139/drivers/net/phy/Makefile linux/drivers/net/phy/Makefile
--- linux-5.15.139/drivers/net/phy/Makefile	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/net/phy/Makefile	2024-01-03 16:06:25.935131000 +0800
@@ -30,6 +30,7 @@
 sfp-obj-$(CONFIG_SFP)		+= sfp-bus.o
 obj-y				+= $(sfp-obj-y) $(sfp-obj-m)
 
+obj-$(CONFIG_AC200_PHY)		+= ac200.o
 obj-$(CONFIG_ADIN_PHY)		+= adin.o
 obj-$(CONFIG_AMD_PHY)		+= amd.o
 aquantia-objs			+= aquantia_main.o
diff -Nuar -r --no-dereference linux-5.15.139/drivers/net/phy/Kconfig linux/drivers/net/phy/Kconfig
--- linux-5.15.139/drivers/net/phy/Kconfig	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/net/phy/Kconfig	2024-01-03 16:06:25.935131000 +0800
@@ -63,6 +63,13 @@
 
 comment "MII PHY device drivers"
 
+config AC200_PHY
+	tristate "AC200 EPHY"
+	depends on NVMEM
+	depends on OF
+	help
+	  Fast ethernet PHY as found in X-Powers AC200 multi-function device.
+
 config AMD_PHY
 	tristate "AMD PHYs"
 	help
diff -Nuar -r --no-dereference linux-5.15.139/drivers/net/phy/yt8614-phy.h linux/drivers/net/phy/yt8614-phy.h
--- linux-5.15.139/drivers/net/phy/yt8614-phy.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/drivers/net/phy/yt8614-phy.h	2024-01-03 16:06:25.935131000 +0800
@@ -0,0 +1,491 @@
+#ifndef _PHY_H_
+#define _PHY_H_
+
+
+/* configuration for driver */
+
+#define YT8614_MAX_LPORT_ID		3
+
+#define YT8614_PHY_MODE_FIBER	1 //fiber mode only
+#define YT8614_PHY_MODE_UTP		2 //utp mode only
+#define YT8614_PHY_MODE_POLL	3 //fiber and utp, poll mode
+
+/* please make choice according to system design
+ * for Fiber only system, please define YT8614_PHY_MODE_CURR 1
+ * for UTP only system, please define YT8614_PHY_MODE_CURR 2
+ * for combo system, please define YT8614_PHY_MODE_CURR 3 
+ */
+#define YT8614_PHY_MODE_CURR	3
+
+
+
+/* pls dont modify below lines */
+
+#define PHY_ID_YT8614  0x4F51E899 //serdes
+#define MOTORCOMM_MPHY_ID_MASK_8614 0xffffffff
+
+#ifndef BOOL
+#define BOOL unsigned int
+#endif
+
+#ifndef FALSE
+#define FALSE 0
+#endif
+
+#ifndef TRUE
+#define TRUE 1
+#endif
+
+#ifndef SPEED_1000M
+#define SPEED_1000M     2
+#endif
+#ifndef SPEED_100M
+#define SPEED_100M     	1
+#endif
+#ifndef SPEED_10M
+#define SPEED_10M     	0
+#endif
+
+#ifndef SPEED_UNKNOWN
+#define SPEED_UNKNOWN   0xffff
+#endif
+
+#ifndef DUPLEX_FULL
+#define DUPLEX_FULL		1	
+#endif
+#ifndef DUPLEX_HALF
+#define DUPLEX_HALF		0	
+#endif
+
+#ifndef BIT
+#define BIT(n) (0x1<<(n))
+#endif
+#ifndef s32
+typedef int  s32;
+typedef unsigned int  u32;
+typedef unsigned short  u16;
+typedef unsigned char  u8;
+#endif
+
+#ifndef REG_PHY_SPEC_STATUS
+#define REG_PHY_SPEC_STATUS		0x11
+#define REG_DEBUG_ADDR_OFFSET		0x1e
+#define REG_DEBUG_DATA			0x1f
+#endif
+
+/**********YT8614************************************************/
+
+#define YT8614_SMI_SEL_PHY        0x0
+#define YT8614_SMI_SEL_SDS_QSGMII 0x02
+#define YT8614_SMI_SEL_SDS_SGMII  0x03
+
+/* yt8614 register type */
+#define YT8614_TYPE_COMMON         0x01
+#define YT8614_TYPE_UTP_MII        0x02
+#define YT8614_TYPE_UTP_EXT        0x03
+#define YT8614_TYPE_LDS_MII        0x04
+#define YT8614_TYPE_UTP_MMD        0x05
+#define YT8614_TYPE_SDS_QSGMII_MII 0x06
+#define YT8614_TYPE_SDS_SGMII_MII  0x07
+#define YT8614_TYPE_SDS_QSGMII_EXT 0x08
+#define YT8614_TYPE_SDS_SGMII_EXT  0x09
+
+/* YT8614 extended common register */
+#define YT8614_REG_COM_SMI_MUX        0xA000
+#define YT8614_REG_COM_SLED_CFG0      0xA001
+#define YT8614_REG_COM_PHY_ID         0xA002
+#define YT8614_REG_COM_CHIP_VER       0xA003
+#define YT8614_REG_COM_SLED_CFG       0xA004
+#define YT8614_REG_COM_MODE_CHG_RESET 0xA005
+#define YT8614_REG_COM_SYNCE0_CFG     0xA006
+#define YT8614_REG_COM_CHIP_MODE      0xA007
+
+#define YT8614_REG_COM_HIDE_SPEED     0xA009
+
+#define YT8614_REG_COM_SYNCE1_CFG     0xA00E
+
+#define YT8614_REG_COM_HIDE_FIBER_MODE 0xA019
+
+
+#define YT8614_REG_COM_HIDE_SEL1      0xA054
+#define YT8614_REG_COM_HIDE_LED_CFG2  0xB8
+#define YT8614_REG_COM_HIDE_LED_CFG3  0xB9
+#define YT8614_REG_COM_HIDE_LED_CFG5  0xBB
+
+#define YT8614_REG_COM_HIDE_LED_CFG4  0xBA //not used currently
+
+#if 0
+#define YT8614_REG_COM_HIDE_LED12_CFG 0xA060 //not used currently
+#define YT8614_REG_COM_HIDE_LED13_CFG 0xA061
+#define YT8614_REG_COM_HIDE_LED14_CFG 0xA062
+#define YT8614_REG_COM_HIDE_LED15_CFG 0xA063
+#define YT8614_REG_COM_HIDE_LED16_CFG 0xA064
+#define YT8614_REG_COM_HIDE_LED17_CFG 0xA065
+#define YT8614_REG_COM_HIDE_LED18_CFG 0xA066
+#define YT8614_REG_COM_HIDE_LED19_CFG 0xA067
+#define YT8614_REG_COM_HIDE_LED20_CFG 0xA068
+#define YT8614_REG_COM_HIDE_LED21_CFG 0xA069
+#define YT8614_REG_COM_HIDE_LED22_CFG 0xA06A
+#define YT8614_REG_COM_HIDE_LED23_CFG 0xA06B
+#define YT8614_REG_COM_HIDE_LED24_CFG 0xA06C
+#define YT8614_REG_COM_HIDE_LED25_CFG 0xA06D
+#define YT8614_REG_COM_HIDE_LED26_CFG 0xA06E
+#define YT8614_REG_COM_HIDE_LED27_CFG 0xA06F
+#endif
+
+#define YT8614_REG_COM_HIDE_LED28_CFG 0xA070
+#define YT8614_REG_COM_HIDE_LED29_CFG 0xA071
+#define YT8614_REG_COM_HIDE_LED30_CFG 0xA072
+#define YT8614_REG_COM_HIDE_LED31_CFG 0xA073
+#define YT8614_REG_COM_HIDE_LED32_CFG 0xA074
+#define YT8614_REG_COM_HIDE_LED33_CFG 0xA075
+#define YT8614_REG_COM_HIDE_LED34_CFG 0xA076
+#define YT8614_REG_COM_HIDE_LED35_CFG 0xA077
+
+#define YT8614_REG_COM_PKG_CFG0       0xA0A0
+#define YT8614_REG_COM_PKG_CFG1       0xA0A1
+#define YT8614_REG_COM_PKG_CFG2       0xA0A2
+#define YT8614_REG_COM_PKG_RX_VALID0  0xA0A3
+#define YT8614_REG_COM_PKG_RX_VALID1  0xA0A4
+#define YT8614_REG_COM_PKG_RX_OS0     0xA0A5
+#define YT8614_REG_COM_PKG_RX_OS1     0xA0A6
+#define YT8614_REG_COM_PKG_RX_US0     0xA0A7
+#define YT8614_REG_COM_PKG_RX_US1     0xA0A8
+#define YT8614_REG_COM_PKG_RX_ERR     0xA0A9
+#define YT8614_REG_COM_PKG_RX_OS_BAD  0xA0AA
+#define YT8614_REG_COM_PKG_RX_FRAG    0xA0AB
+#define YT8614_REG_COM_PKG_RX_NOSFD   0xA0AC
+#define YT8614_REG_COM_PKG_TX_VALID0  0xA0AD
+#define YT8614_REG_COM_PKG_TX_VALID1  0xA0AE
+#define YT8614_REG_COM_PKG_TX_OS0     0xA0AF
+
+#define YT8614_REG_COM_PKG_TX_OS1     0xA0B0
+#define YT8614_REG_COM_PKG_TX_US0     0xA0B1
+#define YT8614_REG_COM_PKG_TX_US1     0xA0B2
+#define YT8614_REG_COM_PKG_TX_ERR     0xA0B3
+#define YT8614_REG_COM_PKG_TX_OS_BAD  0xA0B4
+#define YT8614_REG_COM_PKG_TX_FRAG    0xA0B5
+#define YT8614_REG_COM_PKG_TX_NOSFD   0xA0B6
+#define YT8614_REG_COM_PKG_CFG3       0xA0B7
+#define YT8614_REG_COM_PKG_AZ_CFG     0xA0B8
+#define YT8614_REG_COM_PKG_DA_SA_CFG3 0xA0B9
+
+#define YT8614_REG_COM_MANU_HW_RESET  0xA0C0
+
+/* YT8614 UTP MII register: same as generic phy register definitions */
+#define REG_MII_BMCR          0x00    /* Basic mode control register */
+#define REG_MII_BMSR          0x01    /* Basic mode status register  */
+#define REG_MII_PHYSID1       0x02    /* PHYS ID 1                   */
+#define REG_MII_PHYSID2       0x03    /* PHYS ID 2                   */
+#define REG_MII_ADVERTISE     0x04    /* Advertisement control reg   */
+#define REG_MII_LPA           0x05    /* Link partner ability reg    */
+#define REG_MII_EXPANSION     0x06    /* Expansion register          */
+#define REG_MII_NEXT_PAGE     0x07    /* Next page register          */
+#define REG_MII_LPR_NEXT_PAGE 0x08    /* LPR next page register      */
+#define REG_MII_CTRL1000      0x09    /* 1000BASE-T control          */
+#define REG_MII_STAT1000      0x0A    /* 1000BASE-T status           */
+
+#define REG_MII_MMD_CTRL      0x0D    /* MMD access control register */
+#define REG_MII_MMD_DATA      0x0E    /* MMD access data register    */
+
+#define REG_MII_ESTATUS       0x0F    /* Extended Status             */
+#define REG_MII_SPEC_CTRL     0x10    /* PHY specific func control   */
+#define REG_MII_SPEC_STATUS   0x11    /* PHY specific status         */
+#define REG_MII_INT_MASK      0x12    /* Interrupt mask register     */
+#define REG_MII_INT_STATUS    0x13    /* Interrupt status register   */
+#define REG_MII_DOWNG_CTRL    0x14    /* Speed auto downgrade control*/
+#define REG_MII_RERRCOUNTER   0x15    /* Receive error counter       */
+
+#define REG_MII_EXT_ADDR      0x1E    /* Extended reg's address      */
+#define REG_MII_EXT_DATA      0x1F    /* Extended reg's date         */
+
+#ifndef MII_BMSR
+#define MII_BMSR						REG_MII_BMSR
+#endif
+
+#ifndef YT8614_SPEED_MODE_BIT
+#define YT8614_SPEED_MODE		0xc000
+#define YT8614_DUPLEX			0x2000
+#define YT8614_SPEED_MODE_BIT		14
+#define YT8614_DUPLEX_BIT		13
+#define YT8614_LINK_STATUS_BIT		10
+
+#endif
+
+#define YT8614_REG_COM_HIDE_SPEED_CMB_PRI		0x2000
+
+/* YT8614 UTP MMD register  */
+#define YT8614_REG_UTP_MMD_CTRL1           0x00    /* PCS control 1 register     */
+#define YT8614_REG_UTP_MMD_STATUS1         0x01    /* PCS status 1 register      */
+#define YT8614_REG_UTP_MMD_EEE_CTRL        0x14    /* EEE control and capability */
+#define YT8614_REG_UTP_MMD_EEE_WK_ERR_CNT  0x16    /* EEE wake error counter     */
+#define YT8614_REG_UTP_MMD_EEE_LOCAL_ABI   0x3C    /* local device EEE ability   */
+#define YT8614_REG_UTP_MMD_EEE_LP_ABI      0x3D    /* link partner EEE ability   */
+#define YT8614_REG_UTP_MMD_EEE_AUTONEG_RES 0x8000  /* autoneg result of EEE      */
+
+/* YT8614 UTP EXT register  */
+#define YT8614_REG_UTP_EXT_LPBK        0x0A
+#define YT8614_REG_UTP_EXT_SLEEP_CTRL1 0x27
+#define YT8614_REG_UTP_EXT_DEBUG_MON1  0x5A
+#define YT8614_REG_UTP_EXT_DEBUG_MON2  0x5B
+#define YT8614_REG_UTP_EXT_DEBUG_MON3  0x5C
+#define YT8614_REG_UTP_EXT_DEBUG_MON4  0x5D
+
+/* YT8614 SDS(1.25G/5G) MII register: same as YT8521S */
+#define REG_SDS_BMCR          0x00    /* Basic mode control register */
+#define REG_SDS_BMSR          0x01    /* Basic mode status register  */
+#define REG_SDS_PHYSID1       0x02    /* PHYS ID 1                   */
+#define REG_SDS_PHYSID2       0x03    /* PHYS ID 2                   */
+#define REG_SDS_ADVERTISE     0x04    /* Advertisement control reg   */
+#define REG_SDS_LPA           0x05    /* Link partner ability reg    */
+#define REG_SDS_EXPANSION     0x06    /* Expansion register          */
+#define REG_SDS_NEXT_PAGE     0x07    /* Next page register          */
+#define REG_SDS_LPR_NEXT_PAGE 0x08    /* LPR next page register      */
+
+#define REG_SDS_ESTATUS       0x0F    /* Extended Status             */
+#define REG_SDS_SPEC_STATUS   0x11    /* SDS specific status         */
+
+#define REG_SDS_100FX_CFG     0x14    /* 100fx cfg                   */
+#define REG_SDS_RERRCOUNTER   0x15    /* Receive error counter       */
+#define REG_SDS_LINT_FAIL_CNT 0x16    /* Lint fail counter mon       */
+
+/* YT8614 SDS(5G) EXT register */
+#define YT8614_REG_QSGMII_EXT_ANA_DIG_CFG 0x02    /* sds analog digital interface cfg */
+#define YT8614_REG_QSGMII_EXT_PRBS_CFG1   0x05    /* sds prbs cfg1 */
+#define YT8614_REG_QSGMII_EXT_PRBS_CFG2_1 0x06    /* sds prbs cfg2 */
+#define YT8614_REG_QSGMII_EXT_PRBS_CFG2_2 0x07    /* sds prbs cfg2 */
+#define YT8614_REG_QSGMII_EXT_PRBS_MON1   0x08    /* sds prbs mon1 */
+#define YT8614_REG_QSGMII_EXT_PRBS_MON2   0x09    /* sds prbs mon2 */
+#define YT8614_REG_QSGMII_EXT_PRBS_MON3   0x0A    /* sds prbs mon3 */
+#define YT8614_REG_QSGMII_EXT_PRBS_MON4   0x0B    /* sds prbs mon4 */
+#define YT8614_REG_QSGMII_EXT_PRBS_MON5   0x0C    /* sds prbs mon5 */
+#define YT8614_REG_QSGMII_EXT_ANA_CFG2    0xA1    /* Analog cfg2   */
+
+/* YT8614 SDS(1.25G) EXT register */
+#define YT8614_REG_SGMII_EXT_PRBS_CFG1    0x05    /* sds prbs cfg1 */
+#define YT8614_REG_SGMII_EXT_PRBS_CFG2    0x06    /* sds prbs cfg2 */
+#define YT8614_REG_SGMII_EXT_PRBS_MON1    0x08    /* sds prbs mon1 */
+#define YT8614_REG_SGMII_EXT_PRBS_MON2    0x09    /* sds prbs mon2 */
+#define YT8614_REG_SGMII_EXT_PRBS_MON3    0x0A    /* sds prbs mon3 */
+#define YT8614_REG_SGMII_EXT_PRBS_MON4    0x0B    /* sds prbs mon4 */
+#define YT8614_REG_SGMII_EXT_PRBS_MON5    0x0C    /* sds prbs mon5 */
+#define YT8614_REG_SGMII_EXT_ANA_CFG2     0xA1    /* Analog cfg2   */
+#define YT8614_REG_SGMII_EXT_HIDE_AUTO_SEN 0xA5   /* Fiber auto sensing */
+
+////////////////////////////////////////////////////////////////////
+#define YT8614_MMD_DEV_ADDR1     0x1
+#define YT8614_MMD_DEV_ADDR3     0x3
+#define YT8614_MMD_DEV_ADDR7     0x7
+#define YT8614_MMD_DEV_ADDR_NONE 0xFF
+
+/**********YT8521S************************************************/
+/* Basic mode control register(0x00) */
+#define BMCR_RESV         0x003f  /* Unused...                   */
+#define BMCR_SPEED1000    0x0040  /* MSB of Speed (1000)         */
+#define BMCR_CTST         0x0080  /* Collision test              */
+#define BMCR_FULLDPLX     0x0100  /* Full duplex                 */
+#define BMCR_ANRESTART    0x0200  /* Auto negotiation restart    */
+#define BMCR_ISOLATE      0x0400  /* Disconnect DP83840 from MII */
+#define BMCR_PDOWN        0x0800  /* Powerdown the DP83840       */
+#define BMCR_ANENABLE     0x1000  /* Enable auto negotiation     */
+#define BMCR_SPEED100     0x2000  /* Select 100Mbps              */
+#define BMCR_LOOPBACK     0x4000  /* TXD loopback bits           */
+#define BMCR_RESET        0x8000  /* Reset the DP83840           */
+
+/* Basic mode status register(0x01) */
+#define BMSR_ERCAP        0x0001  /* Ext-reg capability          */
+#define BMSR_JCD          0x0002  /* Jabber detected             */
+#define BMSR_LSTATUS      0x0004  /* Link status                 */
+#define BMSR_ANEGCAPABLE  0x0008  /* Able to do auto-negotiation */
+#define BMSR_RFAULT       0x0010  /* Remote fault detected       */
+#define BMSR_ANEGCOMPLETE 0x0020  /* Auto-negotiation complete   */
+#define BMSR_RESV         0x00c0  /* Unused...                   */
+#define BMSR_ESTATEN      0x0100  /* Extended Status in R15      */
+#define BMSR_100HALF2     0x0200  /* Can do 100BASE-T2 HDX       */
+#define BMSR_100FULL2     0x0400  /* Can do 100BASE-T2 FDX       */
+#define BMSR_10HALF       0x0800  /* Can do 10mbps, half-duplex  */
+#define BMSR_10FULL       0x1000  /* Can do 10mbps, full-duplex  */
+#define BMSR_100HALF      0x2000  /* Can do 100mbps, half-duplex */
+#define BMSR_100FULL      0x4000  /* Can do 100mbps, full-duplex */
+#define BMSR_100BASE4     0x8000  /* Can do 100mbps, 4k packets  */
+
+/* Advertisement control register(0x04) */
+#define ADVERTISE_SLCT          0x001f  /* Selector bits               */
+#define ADVERTISE_CSMA          0x0001  /* Only selector supported     */
+#define ADVERTISE_10HALF        0x0020  /* Try for 10mbps half-duplex  */
+#define ADVERTISE_1000XFULL     0x0020  /* Try for 1000BASE-X full-duplex */
+#define ADVERTISE_10FULL        0x0040  /* Try for 10mbps full-duplex  */
+#define ADVERTISE_1000XHALF     0x0040  /* Try for 1000BASE-X half-duplex */
+#define ADVERTISE_100HALF       0x0080  /* Try for 100mbps half-duplex */
+#define ADVERTISE_1000XPAUSE    0x0080  /* Try for 1000BASE-X pause    */
+#define ADVERTISE_100FULL       0x0100  /* Try for 100mbps full-duplex */
+#define ADVERTISE_1000XPSE_ASYM 0x0100  /* Try for 1000BASE-X asym pause */
+#define ADVERTISE_100BASE4      0x0200  /* Try for 100mbps 4k packets  */
+#define ADVERTISE_PAUSE_CAP     0x0400  /* Try for pause               */
+#define ADVERTISE_PAUSE_ASYM    0x0800  /* Try for asymetric pause     */
+#define ADVERTISE_RESV          0x1000  /* Unused...                   */
+#define ADVERTISE_RFAULT        0x2000  /* Say we can detect faults    */
+#define ADVERTISE_LPACK         0x4000  /* Ack link partners response  */
+#define ADVERTISE_NPAGE         0x8000  /* Next page bit               */
+
+#define ADVERTISE_FULL (ADVERTISE_100FULL | ADVERTISE_10FULL | ADVERTISE_CSMA)
+#define ADVERTISE_ALL  (ADVERTISE_10HALF  | ADVERTISE_10FULL | \
+                        ADVERTISE_100HALF | ADVERTISE_100FULL)
+
+/* Link partner ability register(0x05) */
+#define LPA_SLCT              0x001f  /* Same as advertise selector    */
+#define LPA_10HALF            0x0020  /* Can do 10mbps half-duplex     */
+#define LPA_1000XFULL         0x0020  /* Can do 1000BASE-X full-duplex */
+#define LPA_10FULL            0x0040  /* Can do 10mbps full-duplex     */
+#define LPA_1000XHALF         0x0040  /* Can do 1000BASE-X half-duplex */
+#define LPA_100HALF           0x0080  /* Can do 100mbps half-duplex    */
+#define LPA_1000XPAUSE        0x0080  /* Can do 1000BASE-X pause       */
+#define LPA_100FULL           0x0100  /* Can do 100mbps full-duplex    */
+#define LPA_1000XPAUSE_ASYM   0x0100  /* Can do 1000BASE-X pause asym  */
+#define LPA_100BASE4          0x0200  /* Can do 100mbps 4k packets     */
+#define LPA_PAUSE_CAP         0x0400  /* Can pause                     */
+#define LPA_PAUSE_ASYM        0x0800  /* Can pause asymetrically       */
+#define LPA_RESV              0x1000  /* Unused...                     */
+#define LPA_RFAULT            0x2000  /* Link partner faulted          */
+#define LPA_LPACK             0x4000  /* Link partner acked us         */
+#define LPA_NPAGE             0x8000  /* Next page bit                 */
+
+/* 1000BASE-T Control register(0x09) */
+#define ADVERTISE_1000FULL    0x0200  /* Advertise 1000BASE-T full duplex */
+#define ADVERTISE_1000HALF    0x0100  /* Advertise 1000BASE-T half duplex */
+#define CTL1000_AS_MASTER     0x0800
+#define CTL1000_ENABLE_MASTER 0x1000
+
+/* 1000BASE-T Status register(0x0A) */
+#define LPA_1000LOCALRXOK     0x2000  /* Link partner local receiver status  */
+#define LPA_1000REMRXOK       0x1000  /* Link partner remote receiver status */
+#define LPA_1000FULL          0x0800  /* Link partner 1000BASE-T full duplex */
+#define LPA_1000HALF          0x0400  /* Link partner 1000BASE-T half duplex */
+
+/**********YT8614************************************************/
+/* Basic mode control register(0x00) */
+#define FIBER_BMCR_RESV        0x001f  /* b[4:0] Unused...                      */
+#define FIBER_BMCR_EN_UNIDIR   0x0020  /* b[5]   Valid when bit 0.12 is zero and bit 0.8 is one */
+#define FIBER_BMCR_SPEED1000   0x0040  /* b[6]   MSB of Speed (1000)            */
+#define FIBER_BMCR_CTST        0x0080  /* b[7]   Collision test                 */
+#define FIBER_BMCR_DUPLEX_MODE 0x0100  /* b[8]   Duplex mode                    */
+#define FIBER_BMCR_ANRESTART   0x0200  /* b[9]   Auto negotiation restart       */
+#define FIBER_BMCR_ISOLATE     0x0400  /* b[10]  Isolate phy from RGMII/SGMII/FIBER */
+#define FIBER_BMCR_PDOWN       0x0800  /* b[11]  1: Power down                  */
+#define FIBER_BMCR_ANENABLE    0x1000  /* b[12]  Enable auto negotiation        */
+#define FIBER_BMCR_SPEED100    0x2000  /* b[13]  LSB of Speed (100)             */
+#define FIBER_BMCR_LOOPBACK    0x4000  /* b[14]  Internal loopback control      */
+#define FIBER_BMCR_RESET       0x8000  /* b[15]  PHY Software Reset(self-clear) */
+
+/* Sds specific status register(0x11) */
+#define FIBER_SSR_ERCAP          0x0001  /* b[0]     realtime syncstatus */
+#define FIBER_SSR_XMIT           0x000E  /* b[3:1]   realtime transmit statemachine.
+                                                     001: Xmit Idle;
+                                                     010: Xmit Config; 
+                                                     100: Xmit Data. */
+#define FIBER_SSR_SER_MODE_CFG   0x0030  /* b[5:4]   realtime serdes working mode.
+                                                     00: SG_MAC;
+                                                     01: SG_PHY;
+                                                     10: FIB_1000;
+                                                     11: FIB_100. */
+#define FIBER_SSR_EN_FLOWCTRL_TX 0x0040  /* b[6]     realtime en_flowctrl_tx */
+#define FIBER_SSR_EN_FLOWCTRL_RX 0x0080  /* b[7]     realtime en_flowctrl_rx */
+#define FIBER_SSR_DUPLEX_ERROR   0x0100  /* b[8]     realtime deplex error */
+#define FIBER_SSR_RX_LPI_ACTIVE  0x0200  /* b[9]     rx lpi is active */
+#define FIBER_SSR_LSTATUS        0x0400  /* b[10]    Link status real-time */
+#define FIBER_SSR_PAUSE          0x1800  /* b[12:11] Pause to mac */
+#define FIBER_SSR_DUPLEX         0x2000  /* b[13]    This status bit is valid only when bit10 is 1.
+                                                     1: full duplex 
+                                                     0: half duplex */
+#define FIBER_SSR_SPEED_MODE     0xC000  /* b[15:14] These status bits are valid only when bit10 is 1.
+                                                     10---1000M 
+                                                     01---100M */
+
+/* SLED cfg0 (ext 0xA001) */
+#define FIBER_SLED_CFG0_EN_CTRL  0x00FF  /* b[7:0]   Control to enable the eight ports' SLED */
+#define FIBER_SLED_CFG0_BIT_MASK 0x0700  /* b[10:8]  1: enable the pin output */
+#define FIBER_SLED_CFG0_ACT_LOW  0x0800  /* b[11]    control SLED's polarity. 1: active low; 0: active high */
+#define FIBER_SLED_CFG0_MANU_ST  0x7000  /* b[14:12] SLEDs' manul status, corresponding to each port's 3 SLEDs */
+#define FIBER_SLED_CFG0_MANU_EN  0x8000  /* b[15]    to control serial LEDs status manually */
+
+/**********YT8614************************************************/
+/* Fiber auto sensing(sgmii ext 0xA5) */
+#define FIBER_AUTO_SEN_ENABLE    0x8000  /* b[15]  Enable fiber auto sensing */
+
+/* Fiber force speed(common ext 0xA009) */
+#define FIBER_FORCE_1000M        0x0001  /* b[0]  1:1000BX 0:100FX */
+
+#ifndef NULL
+#define NULL 0
+#endif
+
+/* errno */
+enum ytphy_8614_errno_e
+{
+	SYS_E_NONE,
+	SYS_E_PARAM,
+	SYS_E_MAX
+};
+
+/* errno */
+enum ytphy_8614_combo_speed_e
+{
+	YT8614_COMBO_FIBER_1000M,
+	YT8614_COMBO_FIBER_100M,
+	YT8614_COMBO_UTP_ONLY,
+	YT8614_COMBO_SPEED_MAX
+};
+
+/* definition for porting */
+/* phy registers access */
+typedef struct
+{
+    u16 reg;     /* the offset of the phy internal address */
+    u16 val;     /* the value of the register */
+    u8  regType; /* register type */
+} phy_data_s;
+
+/* for porting use.
+ * pls over-write member function read/write for mdio access
+ */
+typedef struct phy_info_str
+{
+#if 0
+    struct phy_device *phydev;
+	int mdio_base;
+#endif
+	unsigned int lport;
+	unsigned int bus_id;
+	unsigned int phy_addr;
+
+    s32 (*read)(struct phy_info_str *info, phy_data_s *param);
+    s32 (*write)(struct phy_info_str *info, phy_data_s *param);
+}phy_info_s;
+
+/* get phy access method */
+s32 yt8614_read_reg(struct phy_info_str *info, phy_data_s *param);
+s32 yt8614_write_reg(struct phy_info_str *info, phy_data_s *param);
+s32 yt8614_phy_soft_reset(u32 lport);
+s32 yt8614_phy_init(u32 lport);
+s32 yt8614_fiber_enable(u32 lport, BOOL enable);
+s32 yt8614_utp_enable(u32 lport, BOOL enable);
+s32 yt8614_fiber_unidirection_set(u32 lport, int speed, BOOL enable);
+s32 yt8614_fiber_autosensing_set(u32 lport, BOOL enable);
+s32 yt8614_fiber_speed_set(u32 lport, int fiber_speed);
+s32 yt8614_qsgmii_autoneg_set(u32 lport, BOOL enable);
+s32 yt8614_sgmii_autoneg_set(u32 lport, BOOL enable);
+s32 yt8614_qsgmii_sgmii_link_status_get(u32 lport, BOOL *enable, BOOL if_qsgmii);
+int yt8614_combo_media_priority_set (u32 lport, int fiber);
+int yt8614_combo_media_priority_get (u32 lport, int *fiber);
+s32 yt8614_utp_autoneg_set(u32 lport, BOOL enable);
+s32 yt8614_utp_autoneg_get(u32 lport, BOOL *enable);
+s32 yt8614_utp_autoneg_ability_set(u32 lport, unsigned int cap_mask);
+s32 yt8614_utp_autoneg_ability_get(u32 lport, unsigned int *cap_mask);
+s32 yt8614_utp_force_duplex_set(u32 lport, BOOL full);
+s32 yt8614_utp_force_duplex_get(u32 lport, BOOL *full);
+s32 yt8614_utp_force_speed_set(u32 lport, unsigned int speed);
+s32 yt8614_utp_force_speed_get(u32 lport, unsigned int *speed);
+int yt8614_autoneg_done_get (u32 lport, int speed, int *aneg);
+int yt8614_media_status_get(u32 lport, int* speed, int* duplex, int* ret_link, int *media);
+
+#endif
diff -Nuar -r --no-dereference linux-5.15.139/drivers/net/phy/ac200.c linux/drivers/net/phy/ac200.c
--- linux-5.15.139/drivers/net/phy/ac200.c	1970-01-01 08:00:00.000000000 +0800
+++ linux/drivers/net/phy/ac200.c	2024-01-03 16:06:25.935131000 +0800
@@ -0,0 +1,220 @@
+// SPDX-License-Identifier: GPL-2.0+
+/**
+ * Driver for AC200 Ethernet PHY
+ *
+ * Copyright (c) 2020 Jernej Skrabec <jernej.skrabec@siol.net>
+ */
+
+#include <linux/clk.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/mfd/ac200.h>
+#include <linux/nvmem-consumer.h>
+#include <linux/of.h>
+#include <linux/phy.h>
+#include <linux/platform_device.h>
+
+#define AC200_EPHY_ID			0x00441400
+#define AC200_EPHY_ID_MASK		0x0ffffff0
+
+/* macros for system ephy control 0 register */
+#define AC200_EPHY_RESET_INVALID	BIT(0)
+#define AC200_EPHY_SYSCLK_GATING	BIT(1)
+
+/* macros for system ephy control 1 register */
+#define AC200_EPHY_E_EPHY_MII_IO_EN	BIT(0)
+#define AC200_EPHY_E_LNK_LED_IO_EN	BIT(1)
+#define AC200_EPHY_E_SPD_LED_IO_EN	BIT(2)
+#define AC200_EPHY_E_DPX_LED_IO_EN	BIT(3)
+
+/* macros for ephy control register */
+#define AC200_EPHY_SHUTDOWN		BIT(0)
+#define AC200_EPHY_LED_POL		BIT(1)
+#define AC200_EPHY_CLK_SEL		BIT(2)
+#define AC200_EPHY_ADDR(x)		(((x) & 0x1F) << 4)
+#define AC200_EPHY_XMII_SEL		BIT(11)
+#define AC200_EPHY_CALIB(x)		(((x) & 0xF) << 12)
+
+struct ac200_ephy_dev {
+	struct clk		*clk;
+	struct phy_driver	*ephy;
+	struct regmap		*regmap;
+};
+
+static char *ac200_phy_name = "AC200 EPHY";
+
+static int ac200_ephy_config_init(struct phy_device *phydev)
+{
+	const struct ac200_ephy_dev *priv = phydev->drv->driver_data;
+	unsigned int value;
+	int ret;
+
+	phy_write(phydev, 0x1f, 0x0100);	/* Switch to Page 1 */
+	phy_write(phydev, 0x12, 0x4824);	/* Disable APS */
+
+	phy_write(phydev, 0x1f, 0x0200);	/* Switch to Page 2 */
+	phy_write(phydev, 0x18, 0x0000);	/* PHYAFE TRX optimization */
+
+	phy_write(phydev, 0x1f, 0x0600);	/* Switch to Page 6 */
+	phy_write(phydev, 0x14, 0x708f);	/* PHYAFE TX optimization */
+	phy_write(phydev, 0x13, 0xF000);	/* PHYAFE RX optimization */
+	phy_write(phydev, 0x15, 0x1530);
+
+	phy_write(phydev, 0x1f, 0x0800);	/* Switch to Page 6 */
+	phy_write(phydev, 0x18, 0x00bc);	/* PHYAFE TRX optimization */
+
+	phy_write(phydev, 0x1f, 0x0100);	/* switch to page 1 */
+	phy_clear_bits(phydev, 0x17, BIT(3));	/* disable intelligent IEEE */
+
+	/* next two blocks disable 802.3az IEEE */
+	phy_write(phydev, 0x1f, 0x0200);	/* switch to page 2 */
+	phy_write(phydev, 0x18, 0x0000);
+
+	phy_write(phydev, 0x1f, 0x0000);	/* switch to page 0 */
+	phy_clear_bits_mmd(phydev, 0x7, 0x3c, BIT(1));
+
+	if (phydev->interface == PHY_INTERFACE_MODE_RMII)
+		value = AC200_EPHY_XMII_SEL;
+	else
+		value = 0;
+
+	ret = regmap_update_bits(priv->regmap, AC200_EPHY_CTL,
+				 AC200_EPHY_XMII_SEL, value);
+	if (ret)
+		return ret;
+
+	/* FIXME: This is H6 specific */
+	phy_set_bits(phydev, 0x13, BIT(12));
+
+	return 0;
+}
+
+static int ac200_ephy_probe(struct platform_device *pdev)
+{
+	struct ac200_dev *ac200 = dev_get_drvdata(pdev->dev.parent);
+	struct device *dev = &pdev->dev;
+	struct ac200_ephy_dev *priv;
+	struct nvmem_cell *calcell;
+	struct phy_driver *ephy;
+	u16 *caldata, calib;
+	size_t callen;
+	int ret;
+
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	ephy = devm_kzalloc(dev, sizeof(*ephy), GFP_KERNEL);
+	if (!ephy)
+		return -ENOMEM;
+
+	priv->clk = devm_clk_get(dev, NULL);
+	if (IS_ERR(priv->clk)) {
+		dev_err(dev, "Can't obtain the clock!\n");
+		return PTR_ERR(priv->clk);
+	}
+
+	calcell = devm_nvmem_cell_get(dev, "calibration");
+	if (IS_ERR(calcell)) {
+		dev_err(dev, "Unable to find calibration data!\n");
+		return PTR_ERR(calcell);
+	}
+
+	caldata = nvmem_cell_read(calcell, &callen);
+	if (IS_ERR(caldata)) {
+		dev_err(dev, "Unable to read calibration data!\n");
+		return PTR_ERR(caldata);
+	}
+
+	if (callen != 2) {
+		dev_err(dev, "Calibration data has wrong length: 2 != %zu\n",
+			callen);
+		kfree(caldata);
+		return -EINVAL;
+	}
+
+	calib = *caldata + 3;
+	kfree(caldata);
+
+	ret = clk_prepare_enable(priv->clk);
+	if (ret)
+		return ret;
+
+	ephy->phy_id = AC200_EPHY_ID;
+	ephy->phy_id_mask = AC200_EPHY_ID_MASK;
+	ephy->name = ac200_phy_name;
+	ephy->driver_data = priv;
+	ephy->soft_reset = genphy_soft_reset;
+	ephy->config_init = ac200_ephy_config_init;
+	ephy->suspend = genphy_suspend;
+	ephy->resume = genphy_resume;
+
+	priv->ephy = ephy;
+	priv->regmap = ac200->regmap;
+	platform_set_drvdata(pdev, priv);
+
+	ret = regmap_write(ac200->regmap, AC200_SYS_EPHY_CTL0,
+			   AC200_EPHY_RESET_INVALID |
+			   AC200_EPHY_SYSCLK_GATING);
+	if (ret)
+		return ret;
+
+	ret = regmap_write(ac200->regmap, AC200_SYS_EPHY_CTL1,
+			   AC200_EPHY_E_EPHY_MII_IO_EN |
+			   AC200_EPHY_E_LNK_LED_IO_EN |
+			   AC200_EPHY_E_SPD_LED_IO_EN |
+			   AC200_EPHY_E_DPX_LED_IO_EN);
+	if (ret)
+		return ret;
+
+	ret = regmap_write(ac200->regmap, AC200_EPHY_CTL,
+			   AC200_EPHY_LED_POL |
+			   AC200_EPHY_CLK_SEL |
+			   AC200_EPHY_ADDR(1) |
+			   AC200_EPHY_CALIB(calib));
+	if (ret)
+		return ret;
+
+	ret = phy_driver_register(priv->ephy, THIS_MODULE);
+	if (ret) {
+		dev_err(dev, "Unable to register phy\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+static int ac200_ephy_remove(struct platform_device *pdev)
+{
+	struct ac200_ephy_dev *priv = platform_get_drvdata(pdev);
+
+	phy_driver_unregister(priv->ephy);
+
+	regmap_write(priv->regmap, AC200_EPHY_CTL, AC200_EPHY_SHUTDOWN);
+	regmap_write(priv->regmap, AC200_SYS_EPHY_CTL1, 0);
+	regmap_write(priv->regmap, AC200_SYS_EPHY_CTL0, 0);
+
+	clk_disable_unprepare(priv->clk);
+
+	return 0;
+}
+
+static const struct of_device_id ac200_ephy_match[] = {
+	{ .compatible = "x-powers,ac200-ephy" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, ac200_ephy_match);
+
+static struct platform_driver ac200_ephy_driver = {
+	.probe		= ac200_ephy_probe,
+	.remove		= ac200_ephy_remove,
+	.driver		= {
+		.name		= "ac200-ephy",
+		.of_match_table	= ac200_ephy_match,
+	},
+};
+module_platform_driver(ac200_ephy_driver);
+
+MODULE_AUTHOR("Jernej Skrabec <jernej.skrabec@siol.net>");
+MODULE_DESCRIPTION("AC200 Ethernet PHY driver");
+MODULE_LICENSE("GPL");
diff -Nuar -r --no-dereference linux-5.15.139/drivers/regulator/tp65185x.c linux/drivers/regulator/tp65185x.c
--- linux-5.15.139/drivers/regulator/tp65185x.c	1970-01-01 08:00:00.000000000 +0800
+++ linux/drivers/regulator/tp65185x.c	2024-01-03 16:06:25.935131000 +0800
@@ -0,0 +1,549 @@
+// SPDX-License-Identifier: GPL-2.0+
+//
+// Regulator device driver for tp65185x (eInk panel regulator)
+//
+// Copyright (C) 2019 Ondej Jirman <megous@megous.com>
+
+#include <linux/err.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/regmap.h>
+#include <linux/regulator/driver.h>
+#include <linux/regulator/of_regulator.h>
+#include <linux/gpio/consumer.h>
+#include <linux/hwmon.h>
+#include <linux/delay.h>
+
+#define REG_TMST_VALUE    0x00
+#define REG_ENABLE        0x01
+#define REG_VADJ          0x02
+#define REG_VCOM1         0x03
+#define REG_VCOM2         0x04
+#define REG_INT_EN1       0x05
+#define REG_INT_EN2       0x06
+#define REG_INT1          0x07
+#define REG_INT2          0x08
+#define REG_UPSEQ0        0x09
+#define REG_UPSEQ1        0x0A
+#define REG_DWNSEQ0       0x0B
+#define REG_DWNSEQ1       0x0C
+#define REG_TMST1         0x0D
+#define REG_TMST2         0x0E
+#define REG_PG            0x0F
+#define REG_REVID         0x10
+
+#define REG_TMST1_READ_THERM	0x80
+#define REG_TMST1_CONV_END	0x20
+
+struct tp65185x {
+	struct device* dev;
+	struct gpio_desc* wakeup_gpio;
+	struct gpio_desc* vcom_gpio;
+	struct gpio_desc* powerup_gpio;
+	struct gpio_desc* powergood_gpio;
+	struct regmap *regmap;
+	bool is_enabled;
+	struct mutex wakeup_mutex;
+	int wake_refs;
+	int vcom;
+};
+
+static const struct regmap_config tp65185x_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+	.max_register = 0x10,
+	.cache_type = REGCACHE_NONE,
+};
+
+struct voltage_rail {
+	const char* name;
+	int bit;
+	int bit_en;
+};
+
+static const struct voltage_rail rails[] = {
+	{ "VB",    7, -1 },
+	{ "VDDH",  6, 3 },
+	{ "VN",    5, -1 },
+	{ "VPOS",  4, 2 },
+	{ "VEE",   3, 1 },
+	{ "VNEG",  1, 0 },
+	{ "VCOM",  -1, 4 },
+	{ "V3P3",  -1, 5 },
+};
+
+static int apply_voltage(struct tp65185x *tp, int vcom)
+{
+	int ret;
+
+	ret = regmap_write(tp->regmap, REG_VCOM1, vcom & 0xff);
+	if (ret)
+		return ret;
+
+	return regmap_write(tp->regmap, REG_VCOM2, (vcom >> 8) & 1);
+}
+
+static int set_voltage(struct regulator_dev *rdev, int min_uV, int max_uV,
+		       unsigned *selector)
+{
+	struct tp65185x* tp = rdev_get_drvdata(rdev);
+	unsigned int vcom = min_uV / 10000;
+
+	if (vcom > 511 || min_uV < 0)
+		return -EINVAL;
+
+	tp->vcom = vcom;
+
+	// setup VCOM
+
+	if (!tp->is_enabled)
+		return 0;
+
+	return apply_voltage(tp, vcom);
+}
+
+static int get_voltage(struct regulator_dev *rdev)
+{
+	struct tp65185x* tp = rdev_get_drvdata(rdev);
+	unsigned int lsb, msb;
+	int ret;
+
+	if (tp->is_enabled) {
+		ret = regmap_read(rdev->regmap, REG_VCOM1, &lsb);
+		if (ret)
+			return ret;
+
+		ret = regmap_read(rdev->regmap, REG_VCOM2, &msb);
+		if (ret)
+			return ret;
+
+		return (lsb | ((msb & 1) << 8)) * 10000;
+	}
+
+	return tp->vcom * 10000;
+}
+
+#ifdef DEBUG
+static int show_power_status(struct tp65185x* tp, const char* state)
+{
+	unsigned int reg;
+	int i, ret;
+
+	ret = regmap_read(tp->regmap, REG_PG, &reg);
+	if (ret)
+		return ret;
+
+	dev_warn(tp->dev, "%s:\n", state);
+
+	dev_warn(tp->dev, "  voltage rail power good:\n");
+	for (i = 0; i < ARRAY_SIZE(rails); i++)
+		if (rails[i].bit >= 0)
+			dev_warn(tp->dev, "    %s %s\n", rails[i].name,
+				 reg & BIT(rails[i].bit) ? "good" : "fail");
+
+	ret = regmap_read(tp->regmap, REG_ENABLE, &reg);
+	if (ret)
+		return ret;
+
+	dev_warn(tp->dev, "  voltage rail enable status:\n");
+	for (i = 0; i < ARRAY_SIZE(rails); i++)
+		if (rails[i].bit_en >= 0)
+			dev_warn(tp->dev, "    %s %s\n", rails[i].name,
+				 reg & BIT(rails[i].bit_en)
+					? "enabled" : "disabled");
+
+	return 0;
+}
+#else
+static int show_power_status(struct tp65185x* tp, const char* state)
+{
+	return 0;
+}
+#endif
+
+static int show_power_bad(struct tp65185x* tp)
+{
+	unsigned int reg;
+	int i, ret;
+
+	ret = regmap_read(tp->regmap, REG_PG, &reg);
+	if (ret)
+		return ret;
+
+	dev_warn(tp->dev, "Voltage rail failures:\n");
+	for (i = 0; i < ARRAY_SIZE(rails); i++)
+		if (rails[i].bit >= 0 && !(reg & BIT(rails[i].bit)))
+			dev_warn(tp->dev, "  %s failed\n", rails[i].name);
+
+	return 0;
+}
+
+static int wait_for_power_good(struct tp65185x *tp)
+{
+	int ret, loops = 10;
+
+	// wait for power good
+	while (loops-- > 0) {
+		ret = gpiod_get_value(tp->powergood_gpio);
+		if (ret < 0)
+			return ret;
+
+		if (ret)
+			return 0;
+
+		msleep(5);
+	}
+
+	show_power_bad(tp);
+	return -ETIMEDOUT;
+}
+
+static void wakeup_regulator(struct tp65185x *tp, int wake)
+{
+	mutex_lock(&tp->wakeup_mutex);
+
+	if (wake) {
+		tp->wake_refs++;
+		if (tp->wake_refs > 1)
+			goto out_unlock;
+
+		gpiod_set_value(tp->wakeup_gpio, 1);
+		usleep_range(3000, 4000);
+	} else {
+		tp->wake_refs--;
+		if (tp->wake_refs > 0)
+			goto out_unlock;
+
+		gpiod_set_value(tp->wakeup_gpio, 0);
+		usleep_range(100, 200);
+	}
+
+out_unlock:
+	mutex_unlock(&tp->wakeup_mutex);
+}
+
+static int enable_supply(struct regulator_dev *rdev)
+{
+	struct tp65185x* tp = rdev_get_drvdata(rdev);
+	int ret;
+
+	if (tp->is_enabled)
+		return 0;
+
+	wakeup_regulator(tp, 1);
+
+	ret = apply_voltage(tp, tp->vcom);
+	if (ret) {
+		dev_err(tp->dev, "vcom restore failed (%d)\n", ret);
+		goto err;
+	}
+
+	show_power_status(tp, "pre-powerup");
+
+	// enable the VDD on the panel (V3P3) first
+	ret = regmap_write(tp->regmap, REG_ENABLE, 0x20);
+	if (ret) {
+		dev_err(tp->dev, "vdd enable failed (%d)\n", ret);
+		goto err;
+	}
+
+	usleep_range(2000, 2200);
+
+	show_power_status(tp, "V3P3 en");
+
+	// powerup by default takes about 20ms
+	gpiod_set_value(tp->powerup_gpio, 1);
+	usleep_range(22000, 24000);
+
+	ret = wait_for_power_good(tp);
+	if (ret)
+		goto err;
+
+	show_power_status(tp, "powerup done");
+
+	// enable VCOM last
+	gpiod_set_value(tp->vcom_gpio, 1);
+	usleep_range(4000, 5000);
+
+	show_power_status(tp, "powerup vcom");
+
+        tp->is_enabled = true;
+	return 0;
+
+err:
+	gpiod_set_value(tp->vcom_gpio, 0);
+	usleep_range(2000, 3000);
+	gpiod_set_value(tp->powerup_gpio, 0);
+	msleep(100);
+	wakeup_regulator(tp, 0);
+	return ret;
+}
+
+static int disable_supply(struct regulator_dev *rdev)
+{
+	struct tp65185x* tp = rdev_get_drvdata(rdev);
+
+	if (!tp->is_enabled)
+		return 0;
+
+	show_power_status(tp, "pre-poweroff");
+
+	gpiod_set_value(tp->vcom_gpio, 0);
+	usleep_range(5000, 6000);
+
+	show_power_status(tp, "vcom down");
+
+	gpiod_set_value(tp->powerup_gpio, 0);
+
+	// it may take up to 100ms to power off all high voltage rails
+	msleep(100);
+
+	show_power_status(tp, "power down");
+
+	// this will power down the V3P3 switch too
+	wakeup_regulator(tp, 0);
+
+	tp->is_enabled = false;
+
+	return 0;
+}
+
+static int is_supply_enabled(struct regulator_dev *rdev)
+{
+	struct tp65185x* tp = rdev_get_drvdata(rdev);
+	//int ret;
+
+	//ret = gpiod_get_value(tp->powergood_gpio);
+	//if (ret < 0)
+		//return ret;
+
+	return tp->is_enabled;
+}
+
+static const struct regulator_ops tp65185x_ops = {
+	.is_enabled		= is_supply_enabled,
+	.enable			= enable_supply,
+	.disable		= disable_supply,
+	.set_voltage		= set_voltage,
+	.get_voltage		= get_voltage,
+};
+
+static const struct regulator_desc tp65185x_reg = {
+	.name = "tp65185x",
+	.id = 0,
+	.continuous_voltage_range = 1,
+	.ops = &tp65185x_ops,
+	.type = REGULATOR_VOLTAGE,
+	.owner = THIS_MODULE,
+};
+
+static int tp65185x_ntc_read_temperature(struct tp65185x* tp, long *val)
+{
+	int ret;
+	unsigned int reg;
+
+	wakeup_regulator(tp, 1);
+
+	ret = regmap_update_bits(tp->regmap, REG_TMST1,
+				 REG_TMST1_READ_THERM,
+				 REG_TMST1_READ_THERM);
+	if (ret)
+		goto err_sleep;
+
+	ret = regmap_read_poll_timeout(tp->regmap, REG_TMST1, reg,
+				       reg & REG_TMST1_CONV_END,
+				       2000, 100000);
+	if (ret)
+		goto err_sleep;
+
+	ret = regmap_read(tp->regmap, REG_TMST_VALUE, &reg);
+	if (ret)
+		goto err_sleep;
+
+	*val = (s8)(u8)reg;
+
+err_sleep:
+	wakeup_regulator(tp, 0);
+	return ret;
+}
+
+static int tp65185x_ntc_read(struct device *dev, enum hwmon_sensor_types type,
+			     u32 attr, int channel, long *val)
+{
+	struct tp65185x *tp = dev_get_drvdata(dev);
+
+	if (type == hwmon_temp && attr == hwmon_temp_input) {
+		return tp65185x_ntc_read_temperature(tp, val);
+	} else if (type == hwmon_temp && attr == hwmon_temp_type) {
+		*val = 4;
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
+static umode_t tp65185x_ntc_is_visible(const void *data,
+				       enum hwmon_sensor_types type,
+				       u32 attr, int channel)
+{
+	if (type == hwmon_temp) {
+		switch (attr) {
+		case hwmon_temp_input:
+		case hwmon_temp_type:
+			return 0444;
+		default:
+			break;
+		}
+	}
+
+	return 0;
+}
+
+static const struct hwmon_channel_info *tp65185x_ntc_info[] = {
+	HWMON_CHANNEL_INFO(chip, HWMON_C_REGISTER_TZ),
+	HWMON_CHANNEL_INFO(temp, HWMON_T_INPUT | HWMON_T_TYPE),
+	NULL
+};
+
+static const struct hwmon_ops tp65185x_ntc_hwmon_ops = {
+	.is_visible = tp65185x_ntc_is_visible,
+	.read = tp65185x_ntc_read,
+};
+
+static const struct hwmon_chip_info tp65185x_ntc_chip_info = {
+	.ops = &tp65185x_ntc_hwmon_ops,
+	.info = tp65185x_ntc_info,
+};
+
+static int tp65185x_i2c_probe(struct i2c_client *i2c,
+			      const struct i2c_device_id *id)
+{
+	struct device *dev = &i2c->dev;
+	struct regulator_dev *rdev;
+	struct regulator_config config = { };
+	unsigned int reg;
+	struct tp65185x* tp;
+	const char* rev = NULL;
+	struct device *hwmon_dev;
+	int ret;
+
+	tp = devm_kzalloc(dev, sizeof(*tp), GFP_KERNEL);
+	if (!tp)
+		return -ENOMEM;
+
+	tp->dev = dev;
+	mutex_init(&tp->wakeup_mutex);
+
+	tp->powergood_gpio = devm_gpiod_get(dev, "powergood", GPIOD_IN);
+	if (IS_ERR(tp->powergood_gpio)) {
+		ret = PTR_ERR(tp->powergood_gpio);
+		dev_err(dev, "Can't get wakeup gpio (%d)\n", ret);
+		return ret;
+	}
+
+	tp->powerup_gpio = devm_gpiod_get(dev, "powerup", GPIOD_OUT_LOW);
+	if (IS_ERR(tp->powerup_gpio)) {
+		ret = PTR_ERR(tp->powerup_gpio);
+		dev_err(dev, "Can't get wakeup gpio (%d)\n", ret);
+		return ret;
+	}
+
+	tp->vcom_gpio = devm_gpiod_get(dev, "vcom", GPIOD_OUT_LOW);
+	if (IS_ERR(tp->vcom_gpio)) {
+		ret = PTR_ERR(tp->vcom_gpio);
+		dev_err(dev, "Can't get wakeup gpio (%d)\n", ret);
+		return ret;
+	}
+
+	tp->wakeup_gpio = devm_gpiod_get(dev, "wakeup", GPIOD_OUT_HIGH);
+	if (IS_ERR(tp->wakeup_gpio)) {
+		ret = PTR_ERR(tp->wakeup_gpio);
+		dev_err(dev, "Can't get wakeup gpio (%d)\n", ret);
+		return ret;
+	}
+
+	// wait for wakeup
+	usleep_range(10000, 12000);
+
+	i2c_set_clientdata(i2c, tp);
+
+	tp->regmap = devm_regmap_init_i2c(i2c, &tp65185x_regmap_config);
+	if (IS_ERR(tp->regmap)) {
+		ret = PTR_ERR(tp->regmap);
+		dev_err(dev, "Failed to allocate register map: %d\n", ret);
+		return ret;
+	}
+
+	ret = regmap_read(tp->regmap, REG_REVID, &reg);
+	if (ret) {
+		dev_err(dev, "chip id read failed (%d)\n", ret);
+		return ret;
+	}
+
+	switch (reg) {
+		case 0x45: rev = "TPS65185 1p0"; break;
+		case 0x55: rev = "TPS65185 1p1"; break;
+		case 0x65: rev = "TPS65185 1p2"; break;
+		case 0x66: rev = "TPS651851 1p0"; break;
+		default:
+			dev_err(dev, "reading chip id\n");
+			break;
+
+	}
+
+	dev_info(dev, "detected chip id 0x%02x (%s)\n", (int)reg, rev);
+
+	// disable regulators, move to sleep
+	gpiod_set_value(tp->wakeup_gpio, 0);
+
+	config.driver_data = tp;
+	config.dev = &i2c->dev;
+	config.regmap = tp->regmap;
+	config.of_node = dev->of_node;
+	config.init_data = of_get_regulator_init_data(dev, dev->of_node,
+						      &tp65185x_reg);
+	if (!config.init_data)
+		return -ENOMEM;
+
+	rdev = devm_regulator_register(&i2c->dev, &tp65185x_reg, &config);
+	if (IS_ERR(rdev)) {
+		ret = PTR_ERR(rdev);
+		dev_err(&i2c->dev, "Failed to register egulator (%d)\n", ret);
+		return ret;
+	}
+
+	hwmon_dev = devm_hwmon_device_register_with_info(&i2c->dev,
+							 "tps65185",
+							 tp,
+							 &tp65185x_ntc_chip_info,
+							 NULL);
+        if (IS_ERR(hwmon_dev)) {
+		ret = PTR_ERR(hwmon_dev);
+                dev_err(dev, "unable to register tmst as hwmon device (%d)\n",
+			ret);
+                return ret;
+        }
+
+	return 0;
+}
+
+static const struct i2c_device_id tp65185x_i2c_id[] = {
+	{ "tp65185x", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, tp65185x_i2c_id);
+
+static struct i2c_driver tp65185x_regulator_driver = {
+	.driver = {
+		.name = "tp65185x",
+	},
+	.probe = tp65185x_i2c_probe,
+	.id_table = tp65185x_i2c_id,
+};
+
+module_i2c_driver(tp65185x_regulator_driver);
+
+MODULE_AUTHOR("Ondej Jirman <megous@megous.com>");
+MODULE_DESCRIPTION("Regulator device driver for tp65185x");
+MODULE_LICENSE("GPL");
diff -Nuar -r --no-dereference linux-5.15.139/drivers/regulator/Makefile linux/drivers/regulator/Makefile
--- linux-5.15.139/drivers/regulator/Makefile	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/regulator/Makefile	2024-01-03 16:06:25.935131000 +0800
@@ -9,6 +9,7 @@
 obj-$(CONFIG_REGULATOR_FIXED_VOLTAGE) += fixed.o
 obj-$(CONFIG_REGULATOR_VIRTUAL_CONSUMER) += virtual.o
 obj-$(CONFIG_REGULATOR_USERSPACE_CONSUMER) += userspace-consumer.o
+obj-$(CONFIG_REGULATOR_USERSPACE_CONSUMER_OF) += userspace-consumer-of.o
 
 obj-$(CONFIG_REGULATOR_88PG86X) += 88pg86x.o
 obj-$(CONFIG_REGULATOR_88PM800) += 88pm800-regulator.o
@@ -171,5 +172,6 @@
 obj-$(CONFIG_REGULATOR_WM8350) += wm8350-regulator.o
 obj-$(CONFIG_REGULATOR_WM8400) += wm8400-regulator.o
 obj-$(CONFIG_REGULATOR_WM8994) += wm8994-regulator.o
+obj-$(CONFIG_REGULATOR_TP65185X) += tp65185x.o
 
 ccflags-$(CONFIG_REGULATOR_DEBUG) += -DDEBUG
diff -Nuar -r --no-dereference linux-5.15.139/drivers/regulator/Kconfig linux/drivers/regulator/Kconfig
--- linux-5.15.139/drivers/regulator/Kconfig	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/regulator/Kconfig	2024-01-03 16:06:25.935131000 +0800
@@ -56,6 +56,15 @@
 
 	  If unsure, say no.
 
+config REGULATOR_USERSPACE_CONSUMER_OF
+	tristate "Userspace regulator consumer support (OF)"
+	help
+	  There are some classes of devices that are controlled entirely
+	  from user space. Userspace consumer driver provides ability to
+	  control power supplies for such devices.
+
+	  If unsure, say no.
+
 config REGULATOR_88PG86X
 	tristate "Marvell 88PG86X voltage regulators"
 	depends on I2C
@@ -1423,5 +1432,13 @@
 	  boost regulator and IBB can be used as a negative boost regulator
 	  for LCD display panel.
 
+config REGULATOR_TP65185X
+	tristate "eInk display regulator tp65185x"
+	depends on I2C
+	select REGMAP_I2C
+	help
+	  This driver provides support for the voltage regulators for
+	  eInk displays on various e-book readers.
+
 endif
 
diff -Nuar -r --no-dereference linux-5.15.139/drivers/regulator/userspace-consumer-of.c linux/drivers/regulator/userspace-consumer-of.c
--- linux-5.15.139/drivers/regulator/userspace-consumer-of.c	1970-01-01 08:00:00.000000000 +0800
+++ linux/drivers/regulator/userspace-consumer-of.c	2024-01-03 16:06:25.935131000 +0800
@@ -0,0 +1,137 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+
+#include <linux/err.h>
+#include <linux/mutex.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/regulator/consumer.h>
+#include <linux/slab.h>
+#include <linux/of.h>
+
+struct userspace_consumer_data {
+	struct mutex lock;
+	bool enabled;
+	struct regulator *supply;
+};
+
+static ssize_t reg_show_state(struct device *dev,
+			  struct device_attribute *attr, char *buf)
+{
+	struct userspace_consumer_data *data = dev_get_drvdata(dev);
+
+	if (data->enabled)
+		return sprintf(buf, "enabled\n");
+
+	return sprintf(buf, "disabled\n");
+}
+
+static ssize_t reg_set_state(struct device *dev, struct device_attribute *attr,
+			 const char *buf, size_t count)
+{
+	struct userspace_consumer_data *data = dev_get_drvdata(dev);
+	bool enabled;
+	int ret;
+
+	/*
+	 * sysfs_streq() doesn't need the \n's, but we add them so the strings
+	 * will be shared with show_state(), above.
+	 */
+	if (sysfs_streq(buf, "enabled\n") || sysfs_streq(buf, "1"))
+		enabled = true;
+	else if (sysfs_streq(buf, "disabled\n") || sysfs_streq(buf, "0"))
+		enabled = false;
+	else {
+		dev_err(dev, "Configuring invalid mode\n");
+		return count;
+	}
+
+	mutex_lock(&data->lock);
+	if (enabled != data->enabled) {
+		if (enabled)
+			ret = regulator_enable(data->supply);
+		else
+			ret = regulator_disable(data->supply);
+
+		if (ret == 0)
+			data->enabled = enabled;
+		else
+			dev_err(dev, "Failed to configure state: %d\n", ret);
+	}
+	mutex_unlock(&data->lock);
+
+	return count;
+}
+
+static DEVICE_ATTR(state, 0644, reg_show_state, reg_set_state);
+
+static struct attribute *attributes[] = {
+	&dev_attr_state.attr,
+	NULL,
+};
+
+static const struct attribute_group attr_group = {
+	.attrs	= attributes,
+};
+
+static int regulator_userspace_consumer_probe(struct platform_device *pdev)
+{
+	struct userspace_consumer_data *drvdata;
+	int ret;
+
+	drvdata = devm_kzalloc(&pdev->dev,
+			       sizeof(struct userspace_consumer_data),
+			       GFP_KERNEL);
+	if (drvdata == NULL)
+		return -ENOMEM;
+
+	mutex_init(&drvdata->lock);
+
+	drvdata->supply = devm_regulator_get(&pdev->dev, "controlled");
+	if (IS_ERR(drvdata->supply)) {
+		ret = PTR_ERR(drvdata->supply);
+		if (ret != -EPROBE_DEFER)
+			dev_err(&pdev->dev, "Failed to get supply: %d\n", ret);
+		return ret;
+	}
+
+	ret = sysfs_create_group(&pdev->dev.kobj, &attr_group);
+	if (ret != 0)
+		return ret;
+
+	platform_set_drvdata(pdev, drvdata);
+
+	return 0;
+}
+
+static int regulator_userspace_consumer_remove(struct platform_device *pdev)
+{
+	struct userspace_consumer_data *data = platform_get_drvdata(pdev);
+
+	sysfs_remove_group(&pdev->dev.kobj, &attr_group);
+
+	if (data->enabled)
+		regulator_disable(data->supply);
+
+	return 0;
+}
+
+static const struct of_device_id ids_of_match[] = {
+	{ .compatible = "custom,reg-userspace-consumer", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, ids_of_match);
+
+static struct platform_driver regulator_userspace_consumer_driver = {
+	.probe		= regulator_userspace_consumer_probe,
+	.remove		= regulator_userspace_consumer_remove,
+	.driver		= {
+		.name		= "reg-userspace-consumer-of",
+		.of_match_table = of_match_ptr(ids_of_match),
+	},
+};
+
+module_platform_driver(regulator_userspace_consumer_driver);
+
+MODULE_AUTHOR("Mike Rapoport <mike@compulab.co.il>");
+MODULE_DESCRIPTION("Userspace consumer for voltage and current regulators");
+MODULE_LICENSE("GPL");
diff -Nuar -r --no-dereference linux-5.15.139/drivers/regulator/axp20x-regulator.c linux/drivers/regulator/axp20x-regulator.c
--- linux-5.15.139/drivers/regulator/axp20x-regulator.c	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/regulator/axp20x-regulator.c	2024-01-03 16:06:25.935131000 +0800
@@ -93,6 +93,8 @@
 #define AXP22X_WORKMODE_DCDCX_MASK(x)	BIT_MASK(x)
 
 #define AXP22X_MISC_N_VBUSEN_FUNC	BIT(4)
+#define AXP22X_MISC_16S_RESET_FUNC	BIT(3)
+#define AXP22X_MISC_OTP			BIT(2)
 
 #define AXP22X_DCDC1_V_OUT_MASK		GENMASK(4, 0)
 #define AXP22X_DCDC2_V_OUT_MASK		GENMASK(5, 0)
@@ -1344,19 +1346,56 @@
 						&dcdc5_name);
 	}
 
+	if (!drivevbus &&
+	    of_property_read_bool(pdev->dev.parent->of_node, "x-powers,sense-vbus-en")) {
+		/* make N_VBUSEN an input */
+		regmap_update_bits(axp20x->regmap, AXP20X_OVER_TMP,
+				   AXP22X_MISC_N_VBUSEN_FUNC,
+				   AXP22X_MISC_N_VBUSEN_FUNC);
+	}
+
 	if (drivevbus) {
+		struct regulator_desc *new_desc;
+		bool drivevbus_vin = false;
+		struct device_node *nr, *nd;
+
+		nr = of_get_child_by_name(pdev->dev.parent->of_node, "regulators");
+		if (nr) {
+			nd = of_get_child_by_name(nr, "drivevbus");
+			if (nd) {
+				drivevbus_vin = !!of_find_property(nd, "vin-supply", NULL);
+				of_node_put(nd);
+			}
+
+			of_node_put(nr);
+		}
+
+		new_desc = devm_kzalloc(&pdev->dev, sizeof(*new_desc), GFP_KERNEL);
+		if (!new_desc)
+			return -ENOMEM;
+
+		*new_desc = axp22x_drivevbus_regulator;
+
+		if (drivevbus_vin) {
+			new_desc->supply_name = "vin";
+			dev_info(&pdev->dev, "drivevbus has vin\n");
+		}
+
 		/* Change N_VBUSEN sense pin to DRIVEVBUS output pin */
 		regmap_update_bits(axp20x->regmap, AXP20X_OVER_TMP,
 				   AXP22X_MISC_N_VBUSEN_FUNC, 0);
-		rdev = devm_regulator_register(&pdev->dev,
-					       &axp22x_drivevbus_regulator,
-					       &config);
+		rdev = devm_regulator_register(&pdev->dev, new_desc, &config);
 		if (IS_ERR(rdev)) {
 			dev_err(&pdev->dev, "Failed to register drivevbus\n");
 			return PTR_ERR(rdev);
 		}
 	}
 
+	// enable 16s power-on reset and over-temperature protection
+	regmap_update_bits(axp20x->regmap, AXP20X_OVER_TMP,
+			   AXP22X_MISC_16S_RESET_FUNC | AXP22X_MISC_OTP,
+			   AXP22X_MISC_16S_RESET_FUNC | AXP22X_MISC_OTP);
+
 	return 0;
 }
 
diff -Nuar -r --no-dereference linux-5.15.139/drivers/i2c/busses/i2c-mv64xxx.c linux/drivers/i2c/busses/i2c-mv64xxx.c
--- linux-5.15.139/drivers/i2c/busses/i2c-mv64xxx.c	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/i2c/busses/i2c-mv64xxx.c	2024-01-03 16:06:25.935131000 +0800
@@ -951,6 +951,14 @@
 		return -ENODEV;
 	}
 
+	if (IS_ERR(pinctrl_lookup_state(rinfo->pinctrl, "gpio")) &&
+		IS_ERR(pinctrl_lookup_state(rinfo->pinctrl, "recovery"))) {
+		/* No recovery state is vailable in pinctrl. */
+		devm_pinctrl_put(rinfo->pinctrl);
+		rinfo->pinctrl = NULL;
+		return 0;
+	}
+
 	drv_data->adapter.bus_recovery_info = rinfo;
 	return 0;
 }
diff -Nuar -r --no-dereference linux-5.15.139/drivers/i2c/busses/i2c-gpio.c linux/drivers/i2c/busses/i2c-gpio.c
--- linux-5.15.139/drivers/i2c/busses/i2c-gpio.c	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/i2c/busses/i2c-gpio.c	2024-01-03 16:06:25.935131000 +0800
@@ -332,6 +332,13 @@
 		return retdesc;
 	}
 
+	/* return early so that EPROBE_DEFER is not ignored on named gpios */
+	if (PTR_ERR(retdesc) == -EPROBE_DEFER) {
+		dev_err_probe(dev, PTR_ERR(retdesc),
+			      "error trying to get descriptor\n");
+		return retdesc;
+	}
+
 	retdesc = devm_gpiod_get_index(dev, NULL, index, gflags);
 	if (!IS_ERR(retdesc)) {
 		dev_dbg(dev, "got GPIO from index %u\n", index);
@@ -348,8 +355,8 @@
 	if (ret == -ENOENT)
 		retdesc = ERR_PTR(-EPROBE_DEFER);
 
-	if (PTR_ERR(retdesc) != -EPROBE_DEFER)
-		dev_err(dev, "error trying to get descriptor: %d\n", ret);
+	dev_err_probe(dev, PTR_ERR(retdesc),
+		      "error trying to get descriptor\n");
 
 	return retdesc;
 }
diff -Nuar -r --no-dereference linux-5.15.139/drivers/pinctrl/sunxi/pinctrl-sun50i-h6.c linux/drivers/pinctrl/sunxi/pinctrl-sun50i-h6.c
--- linux-5.15.139/drivers/pinctrl/sunxi/pinctrl-sun50i-h6.c	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/pinctrl/sunxi/pinctrl-sun50i-h6.c	2024-01-03 16:06:25.935131000 +0800
@@ -588,6 +588,7 @@
 static const struct sunxi_pinctrl_desc h6_pinctrl_data = {
 	.pins = h6_pins,
 	.npins = ARRAY_SIZE(h6_pins),
+	.disable_strict_mode = true,
 	.irq_banks = 4,
 	.irq_bank_map = h6_irq_bank_map,
 	.irq_read_needs_mux = true,
diff -Nuar -r --no-dereference linux-5.15.139/drivers/pinctrl/sunxi/pinctrl-sun50i-a64.c linux/drivers/pinctrl/sunxi/pinctrl-sun50i-a64.c
--- linux-5.15.139/drivers/pinctrl/sunxi/pinctrl-sun50i-a64.c	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/pinctrl/sunxi/pinctrl-sun50i-a64.c	2024-01-03 16:06:25.935131000 +0800
@@ -578,6 +578,7 @@
 	.pins = a64_pins,
 	.npins = ARRAY_SIZE(a64_pins),
 	.irq_banks = 3,
+	.disable_strict_mode = true,
 };
 
 static int a64_pinctrl_probe(struct platform_device *pdev)
diff -Nuar -r --no-dereference linux-5.15.139/drivers/devfreq/Makefile linux/drivers/devfreq/Makefile
--- linux-5.15.139/drivers/devfreq/Makefile	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/devfreq/Makefile	2024-01-03 16:06:25.935131000 +0800
@@ -12,6 +12,7 @@
 obj-$(CONFIG_ARM_IMX_BUS_DEVFREQ)	+= imx-bus.o
 obj-$(CONFIG_ARM_IMX8M_DDRC_DEVFREQ)	+= imx8m-ddrc.o
 obj-$(CONFIG_ARM_RK3399_DMC_DEVFREQ)	+= rk3399_dmc.o
+obj-$(CONFIG_ARM_SUN8I_MBUS_DEVFREQ)	+= sun8i-mbus.o
 obj-$(CONFIG_ARM_TEGRA_DEVFREQ)		+= tegra30-devfreq.o
 
 # DEVFREQ Event Drivers
diff -Nuar -r --no-dereference linux-5.15.139/drivers/devfreq/sun8i-mbus.c linux/drivers/devfreq/sun8i-mbus.c
--- linux-5.15.139/drivers/devfreq/sun8i-mbus.c	1970-01-01 08:00:00.000000000 +0800
+++ linux/drivers/devfreq/sun8i-mbus.c	2024-01-03 16:06:25.935131000 +0800
@@ -0,0 +1,551 @@
+// SPDX-License-Identifier: GPL-2.0-only
+
+#include <linux/clk.h>
+#include <linux/debugfs.h>
+#include <linux/devfreq.h>
+#include <linux/err.h>
+#include <linux/io.h>
+#include <linux/iopoll.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/property.h>
+#include <linux/pm_qos.h>
+
+#define MBUS_CR				0x0000
+#define MBUS_CR_GET_DRAM_TYPE(x)	(((x) >> 16) & 0x7)
+#define MBUS_CR_DRAM_TYPE_DDR2		2
+#define MBUS_CR_DRAM_TYPE_DDR3		3
+#define MBUS_CR_DRAM_TYPE_DDR4		4
+#define MBUS_CR_DRAM_TYPE_LPDDR2	6
+#define MBUS_CR_DRAM_TYPE_LPDDR3	7
+
+#define MBUS_TMR			0x000c
+#define MBUS_TMR_PERIOD(x)		((x) - 1)
+
+#define MBUS_PMU_CFG			0x009c
+#define MBUS_PMU_CFG_PERIOD(x)		(((x) - 1) << 16)
+#define MBUS_PMU_CFG_UNIT		(0x3 << 1)
+#define MBUS_PMU_CFG_UNIT_B		(0x0 << 1)
+#define MBUS_PMU_CFG_UNIT_KB		(0x1 << 1)
+#define MBUS_PMU_CFG_UNIT_MB		(0x2 << 1)
+#define MBUS_PMU_CFG_ENABLE		(0x1 << 0)
+
+#define MBUS_PMU_BWCR(n)		(0x00a0 + (0x04 * (n)))
+
+#define MBUS_TOTAL_BWCR			MBUS_PMU_BWCR(5)
+#define MBUS_TOTAL_BWCR_H616		MBUS_PMU_BWCR(13)
+
+#define MBUS_MDFSCR			0x0100
+#define MBUS_MDFSCR_BUFFER_TIMING	(0x1 << 15)
+#define MBUS_MDFSCR_PAD_HOLD		(0x1 << 13)
+#define MBUS_MDFSCR_BYPASS		(0x1 << 4)
+#define MBUS_MDFSCR_MODE		(0x1 << 1)
+#define MBUS_MDFSCR_MODE_DFS		(0x0 << 1)
+#define MBUS_MDFSCR_MODE_CFS		(0x1 << 1)
+#define MBUS_MDFSCR_START		(0x1 << 0)
+
+#define MBUS_MDFSMRMR			0x0108
+
+#define DRAM_PWRCTL			0x0004
+#define DRAM_PWRCTL_SELFREF_EN		(0x1 << 0)
+
+#define DRAM_RFSHTMG			0x0090
+#define DRAM_RFSHTMG_TREFI(x)		((x) << 16)
+#define DRAM_RFSHTMG_TRFC(x)		((x) << 0)
+
+#define DRAM_VTFCR			0x00b8
+#define DRAM_VTFCR_VTF_ENABLE		(0x3 << 8)
+
+#define DRAM_ODTMAP			0x0120
+
+#define DRAM_DX_MAX			4
+
+#define DRAM_DXnGCR0(n)			(0x0344 + 0x80 * (n))
+#define DRAM_DXnGCR0_DXODT		(0x3 << 4)
+#define DRAM_DXnGCR0_DXODT_DYNAMIC	(0x0 << 4)
+#define DRAM_DXnGCR0_DXODT_ENABLED	(0x1 << 4)
+#define DRAM_DXnGCR0_DXODT_DISABLED	(0x2 << 4)
+#define DRAM_DXnGCR0_DXEN		(0x1 << 0)
+
+struct sun8i_mbus_pmu_master {
+	u32		id;
+	const char	*name;
+};
+
+struct sun8i_mbus_variant {
+	const struct sun8i_mbus_pmu_master	*pmu_masters;
+	u32					num_pmu_masters;
+	u32					min_dram_divider;
+	u32					max_dram_divider;
+	u32					odt_freq_mhz;
+};
+
+struct sun8i_mbus {
+	const struct sun8i_mbus_variant		*variant;
+	void __iomem				*reg_dram;
+	void __iomem				*reg_mbus;
+	struct clk				*clk_apb;
+	struct clk				*clk_dram;
+	struct clk				*clk_mbus;
+	struct devfreq				*devfreq_dram;
+	struct devfreq_simple_ondemand_data	gov_data;
+	struct devfreq_dev_profile		profile;
+	u32					data_width;
+	u32					nominal_bw;
+	u32					odtmap;
+	u32					tREFI_ns;
+	u32					tRFC_ns;
+	unsigned long				freq_table[];
+};
+
+/*
+ * The unit for this value is (MBUS clock cycles / MBUS_TMR_PERIOD). When
+ * MBUS_TMR_PERIOD is programmed to match the MBUS clock frequency in MHz, as
+ * it is during DRAM init and during probe, the resulting unit is microseconds.
+ */
+static int pmu_period = 50000;
+module_param(pmu_period, int, 0644);
+MODULE_PARM_DESC(pmu_period, "Bandwidth measurement period (microseconds)");
+
+static u32 sun8i_mbus_get_peak_bw(struct sun8i_mbus *priv)
+{
+	/* Returns the peak transfer (in KiB) during any single PMU period. */
+	return readl_relaxed(priv->reg_mbus + MBUS_TOTAL_BWCR);
+}
+
+static void sun8i_mbus_restart_pmu_counters(struct sun8i_mbus *priv)
+{
+	u32 pmu_cfg = MBUS_PMU_CFG_PERIOD(pmu_period) | MBUS_PMU_CFG_UNIT_KB;
+
+	/* All PMU counters are cleared on a disable->enable transition. */
+	writel_relaxed(pmu_cfg,
+		       priv->reg_mbus + MBUS_PMU_CFG);
+	writel_relaxed(pmu_cfg | MBUS_PMU_CFG_ENABLE,
+		       priv->reg_mbus + MBUS_PMU_CFG);
+
+}
+
+static void sun8i_mbus_update_nominal_bw(struct sun8i_mbus *priv,
+					 u32 ddr_freq_mhz)
+{
+	/*
+	 * Nominal bandwidth (KiB per PMU period):
+	 *
+	 *   DDR transfers   microseconds     KiB
+	 *   ------------- * ------------ * --------
+	 *    microsecond     PMU period    transfer
+	 */
+	priv->nominal_bw = ddr_freq_mhz * pmu_period * priv->data_width / 1024;
+}
+
+static int sun8i_mbus_set_dram_freq(struct sun8i_mbus *priv, unsigned long freq)
+{
+	u32  ddr_freq_mhz = freq / USEC_PER_SEC; /* DDR */
+	u32 dram_freq_mhz =    ddr_freq_mhz / 2; /* SDR */
+	u32 mctl_freq_mhz =   dram_freq_mhz / 2; /* HDR */
+	u32 dxodt, mdfscr, pwrctl, vtfcr;
+	u32 i, tREFI_32ck, tRFC_ck;
+	int ret;
+
+	/* The rate change is not effective until the MDFS process runs. */
+	ret = clk_set_rate(priv->clk_dram, freq);
+	if (ret)
+		return ret;
+
+	/* Disable automatic self-refesh and VTF before starting MDFS. */
+	pwrctl = readl_relaxed(priv->reg_dram + DRAM_PWRCTL) &
+		 ~DRAM_PWRCTL_SELFREF_EN;
+	writel_relaxed(pwrctl, priv->reg_dram + DRAM_PWRCTL);
+	vtfcr = readl_relaxed(priv->reg_dram + DRAM_VTFCR);
+	writel_relaxed(vtfcr & ~DRAM_VTFCR_VTF_ENABLE,
+		       priv->reg_dram + DRAM_VTFCR);
+
+	/* Set up MDFS and enable double buffering for timing registers. */
+	mdfscr = MBUS_MDFSCR_MODE_DFS |
+		 MBUS_MDFSCR_BYPASS |
+		 MBUS_MDFSCR_PAD_HOLD |
+		 MBUS_MDFSCR_BUFFER_TIMING;
+	writel(mdfscr, priv->reg_mbus + MBUS_MDFSCR);
+
+	/* Update the buffered copy of RFSHTMG. */
+	tREFI_32ck = priv->tREFI_ns * mctl_freq_mhz / 1000 / 32;
+	tRFC_ck = DIV_ROUND_UP(priv->tRFC_ns * mctl_freq_mhz, 1000);
+	writel(DRAM_RFSHTMG_TREFI(tREFI_32ck) | DRAM_RFSHTMG_TRFC(tRFC_ck),
+	       priv->reg_dram + DRAM_RFSHTMG);
+
+	/* Enable ODT if needed, or disable it to save power. */
+	if (priv->odtmap && dram_freq_mhz > priv->variant->odt_freq_mhz) {
+		dxodt = DRAM_DXnGCR0_DXODT_DYNAMIC;
+		writel(priv->odtmap, priv->reg_dram + DRAM_ODTMAP);
+	} else {
+		dxodt = DRAM_DXnGCR0_DXODT_DISABLED;
+		writel(0, priv->reg_dram + DRAM_ODTMAP);
+	}
+	for (i = 0; i < DRAM_DX_MAX; ++i) {
+		void __iomem *reg = priv->reg_dram + DRAM_DXnGCR0(i);
+		writel((readl(reg) & ~DRAM_DXnGCR0_DXODT) | dxodt, reg);
+	}
+
+	dev_dbg(priv->devfreq_dram->dev.parent,
+		"Setting DRAM to %u MHz, tREFI=%u, tRFC=%u, ODT=%s\n",
+		dram_freq_mhz, tREFI_32ck, tRFC_ck,
+		dxodt == DRAM_DXnGCR0_DXODT_DYNAMIC ? "dynamic" : "disabled");
+
+	/* Trigger hardware MDFS. */
+	writel(mdfscr | MBUS_MDFSCR_START, priv->reg_mbus + MBUS_MDFSCR);
+	ret = readl_poll_timeout_atomic(priv->reg_mbus + MBUS_MDFSCR, mdfscr,
+					!(mdfscr & MBUS_MDFSCR_START), 10, 1000);
+	if (ret)
+		return ret;
+
+	/* Disable double buffering. */
+	writel(0, priv->reg_mbus + MBUS_MDFSCR);
+
+	/* Restore VTF configuration. */
+	writel_relaxed(vtfcr, priv->reg_dram + DRAM_VTFCR);
+
+	/* Enable automatic self-refresh at the lowest frequency only. */
+	if (freq == priv->freq_table[0])
+		pwrctl |= DRAM_PWRCTL_SELFREF_EN;
+	writel_relaxed(pwrctl, priv->reg_dram + DRAM_PWRCTL);
+
+	sun8i_mbus_restart_pmu_counters(priv);
+	sun8i_mbus_update_nominal_bw(priv, ddr_freq_mhz);
+
+	return 0;
+}
+
+static int sun8i_mbus_set_dram_target(struct device *dev, unsigned long *freq,
+				  u32 flags)
+{
+	struct sun8i_mbus *priv = dev_get_drvdata(dev);
+	struct devfreq *devfreq = priv->devfreq_dram;
+	int ret;
+
+	devfreq_recommended_freq(devfreq, freq, flags);
+
+	if (*freq == devfreq->previous_freq)
+		return 0;
+
+	ret = sun8i_mbus_set_dram_freq(priv, *freq);
+	if (ret) {
+		dev_warn(dev, "failed to set DRAM frequency: %d\n", ret);
+		*freq = devfreq->previous_freq;
+	}
+
+	return ret;
+}
+
+static int sun8i_mbus_get_dram_status(struct device *dev,
+				      struct devfreq_dev_status *stat)
+{
+	struct sun8i_mbus *priv = dev_get_drvdata(dev);
+
+	stat->busy_time		= sun8i_mbus_get_peak_bw(priv);
+	stat->total_time	= priv->nominal_bw;
+	stat->current_frequency	= priv->devfreq_dram->previous_freq;
+
+	sun8i_mbus_restart_pmu_counters(priv);
+
+	dev_dbg(dev, "Using %lu/%lu (%lu%%) at %lu MHz\n",
+		stat->busy_time, stat->total_time,
+		DIV_ROUND_CLOSEST(stat->busy_time * 100, stat->total_time),
+		stat->current_frequency / USEC_PER_SEC);
+
+	return 0;
+}
+
+static int sun8i_mbus_hw_init(struct device *dev, struct sun8i_mbus *priv,
+			      unsigned long ddr_freq)
+{
+	u32 i, mbus_cr, mbus_freq_mhz;
+
+	/* Choose tREFI and tRFC to match the configured DRAM type. */
+	mbus_cr = readl_relaxed(priv->reg_mbus + MBUS_CR);
+	switch (MBUS_CR_GET_DRAM_TYPE(mbus_cr)) {
+	case MBUS_CR_DRAM_TYPE_DDR2:
+	case MBUS_CR_DRAM_TYPE_DDR3:
+	case MBUS_CR_DRAM_TYPE_DDR4:
+		priv->tREFI_ns = 7800;
+		priv->tRFC_ns = 350;
+		break;
+	case MBUS_CR_DRAM_TYPE_LPDDR2:
+	case MBUS_CR_DRAM_TYPE_LPDDR3:
+		priv->tREFI_ns = 3900;
+		priv->tRFC_ns = 210;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	/* Save ODTMAP so it can be restored when raising the frequency. */
+	priv->odtmap = readl_relaxed(priv->reg_dram + DRAM_ODTMAP);
+
+	/* Compute the DRAM data bus width by counting enabled DATx8 blocks. */
+	for (i = 0; i < DRAM_DX_MAX; ++i) {
+		void __iomem *reg = priv->reg_dram + DRAM_DXnGCR0(i);
+		if (!(readl_relaxed(reg) & DRAM_DXnGCR0_DXEN))
+			break;
+	}
+	priv->data_width = i;
+
+	dev_dbg(dev, "Detected %u-bit %sDDRx with%s ODT\n",
+		priv->data_width * 8,
+		MBUS_CR_GET_DRAM_TYPE(mbus_cr) > 4 ? "LP" : "",
+		priv->odtmap ? "" : "out");
+
+	/* Program MBUS_TMR such that the PMU period unit is microseconds. */
+	mbus_freq_mhz = clk_get_rate(priv->clk_mbus) / USEC_PER_SEC;
+	writel_relaxed(MBUS_TMR_PERIOD(mbus_freq_mhz),
+		       priv->reg_mbus + MBUS_TMR);
+
+	/* "Master Ready Mask Register" bits must be set or MDFS will block. */
+	writel_relaxed(0xffffffff, priv->reg_mbus + MBUS_MDFSMRMR);
+
+	sun8i_mbus_restart_pmu_counters(priv);
+	sun8i_mbus_update_nominal_bw(priv, ddr_freq / USEC_PER_SEC);
+
+	return 0;
+}
+
+static int sun8i_mbus_show_usage(struct seq_file *s, void *data)
+{
+	struct sun8i_mbus *priv = dev_get_drvdata(s->private);
+	const struct sun8i_mbus_variant *variant = priv->variant;
+	u32 i;
+
+	seq_puts(s, " master             usage\n");
+	seq_puts(s, "--------------------------\n");
+	for (i = 0; i < variant->num_pmu_masters; ++i) {
+		u32 id = variant->pmu_masters[i].id;
+		seq_printf(s, " %-7s %10u KiB\n",
+			   variant->pmu_masters[i].name,
+			   readl_relaxed(priv->reg_mbus + MBUS_PMU_BWCR(id)));
+	}
+	seq_puts(s, "---------------------------\n");
+	seq_printf(s, " PEAK BW %10u KiB/s\n", sun8i_mbus_get_peak_bw(priv));
+	seq_printf(s, " NOMINAL %10u KiB/s\n", priv->nominal_bw);
+
+	return 0;
+}
+
+static int __maybe_unused sun8i_mbus_suspend(struct device *dev)
+{
+	struct sun8i_mbus *priv = dev_get_drvdata(dev);
+
+	clk_disable_unprepare(priv->clk_apb);
+
+	return 0;
+}
+
+static int __maybe_unused sun8i_mbus_resume(struct device *dev)
+{
+	struct sun8i_mbus *priv = dev_get_drvdata(dev);
+
+	return clk_prepare_enable(priv->clk_apb);
+}
+
+static int sun8i_mbus_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	const struct sun8i_mbus_variant *variant = device_get_match_data(dev);
+	struct sun8i_mbus *priv;
+	unsigned long base_freq;
+	unsigned int max_state;
+	unsigned int div;
+	const char *err;
+	int i, ret;
+
+	max_state = variant->max_dram_divider - variant->min_dram_divider + 1;
+
+	priv = devm_kzalloc(dev, struct_size(priv, freq_table, max_state), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, priv);
+
+	priv->variant = variant;
+
+	priv->reg_mbus = devm_platform_ioremap_resource_byname(pdev, "mbus");
+	if (IS_ERR(priv->reg_mbus))
+		return PTR_ERR(priv->reg_mbus);
+
+	priv->reg_dram = devm_platform_ioremap_resource_byname(pdev, "dram");
+	if (IS_ERR(priv->reg_dram))
+		return PTR_ERR(priv->reg_dram);
+
+	priv->clk_apb = devm_clk_get(dev, "apb");
+	if (IS_ERR(priv->clk_apb))
+		return dev_err_probe(dev, PTR_ERR(priv->clk_apb),
+				     "failed to get apb clock\n");
+
+	priv->clk_mbus = devm_clk_get(dev, "mbus");
+	if (IS_ERR(priv->clk_mbus))
+		return dev_err_probe(dev, PTR_ERR(priv->clk_mbus),
+				     "failed to get mbus clock\n");
+
+	priv->clk_dram = devm_clk_get(dev, "dram");
+	if (IS_ERR(priv->clk_dram))
+		return dev_err_probe(dev, PTR_ERR(priv->clk_dram),
+				     "failed to get dram clock\n");
+
+	ret = clk_prepare_enable(priv->clk_apb);
+	if (ret)
+		return dev_err_probe(dev, ret,
+				     "failed to enable apb clock\n");
+
+	/* Lock the MBUS clock rate to keep MBUS_TMR_PERIOD in sync. */
+	ret = clk_rate_exclusive_get(priv->clk_mbus);
+	if (ret) {
+		err = "failed to lock mbus clock rate\n";
+		goto err_disable_apb;
+	}
+
+	/* Lock the DRAM clock rate to keep priv->nominal_bw in sync. */
+	ret = clk_rate_exclusive_get(priv->clk_dram);
+	if (ret) {
+		err = "failed to lock dram clock rate\n";
+		goto err_unlock_mbus;
+	}
+
+	priv->gov_data.upthreshold	= 40;
+	priv->gov_data.downdifferential	= 10;
+
+	priv->profile.initial_freq	= clk_get_rate(priv->clk_dram);
+	priv->profile.polling_ms	= 1000;
+	priv->profile.target		= sun8i_mbus_set_dram_target;
+	priv->profile.get_dev_status	= sun8i_mbus_get_dram_status;
+	priv->profile.freq_table	= priv->freq_table;
+	priv->profile.max_state		= max_state;
+
+	base_freq = clk_get_rate(clk_get_parent(priv->clk_dram));
+	for (i = 0, div = variant->max_dram_divider; i < max_state; ++i, --div)
+		priv->freq_table[i] = base_freq / div;
+
+	ret = sun8i_mbus_hw_init(dev, priv, priv->profile.initial_freq);
+	if (ret) {
+		err = "failed to init hardware\n";
+		goto err_unlock_dram;
+	}
+
+	priv->devfreq_dram = devm_devfreq_add_device(dev, &priv->profile,
+						     DEVFREQ_GOV_SIMPLE_ONDEMAND,
+						     &priv->gov_data);
+	if (IS_ERR(priv->devfreq_dram)) {
+		ret = PTR_ERR(priv->devfreq_dram);
+		err = "failed to add devfreq device\n";
+		goto err_unlock_dram;
+	}
+
+	if (max_state > 0)
+		dev_pm_qos_update_request(&priv->devfreq_dram->user_min_freq_req,
+					  priv->freq_table[1] / 1000);
+
+	priv->devfreq_dram->suspend_freq = priv->freq_table[0];
+
+	debugfs_create_devm_seqfile(dev, "sun8i-mbus", NULL,
+				    sun8i_mbus_show_usage);
+
+	return 0;
+
+err_unlock_dram:
+	clk_rate_exclusive_put(priv->clk_dram);
+err_unlock_mbus:
+	clk_rate_exclusive_put(priv->clk_mbus);
+err_disable_apb:
+	clk_disable_unprepare(priv->clk_apb);
+
+	return dev_err_probe(dev, ret, err);
+}
+
+static int sun8i_mbus_remove(struct platform_device *pdev)
+{
+	struct sun8i_mbus *priv = platform_get_drvdata(pdev);
+	struct device *dev = &pdev->dev;
+	int ret;
+
+	ret = sun8i_mbus_set_dram_freq(priv, priv->profile.initial_freq);
+	if (ret)
+		dev_warn(dev, "failed to restore DRAM frequency: %d\n", ret);
+
+	clk_rate_exclusive_put(priv->clk_dram);
+	clk_rate_exclusive_put(priv->clk_mbus);
+	clk_disable_unprepare(priv->clk_apb);
+
+	return 0;
+}
+
+#if 0 // untested
+static const struct sun8i_mbus_pmu_master sun8i_a33_mbus_pmu_masters[] = {
+	{ 0, "CPU" },
+	{ 1, "GPU" },
+	{ 2, "VE" },
+	{ 3, "DISPLAY" },
+	{ 4, "OTHER" },
+};
+
+static const struct sun8i_mbus_variant sun8i_a33_mbus = {
+	.pmu_masters		= sun8i_a33_mbus_pmu_masters,
+	.num_pmu_masters	= ARRAY_SIZE(sun8i_a33_mbus_pmu_masters),
+	.min_dram_divider	= 2,
+	.max_dram_divider	= 16,
+	.odt_freq_mhz		= 400,
+};
+#endif
+
+static const struct sun8i_mbus_pmu_master sun8i_h3_mbus_pmu_masters[] = {
+	{ 0, "CPU" },
+	{ 1, "GPU" },
+	{ 2, "VE" },
+	{ 3, "DISPLAY" },
+	{ 6, "CSI" },
+	{ 4, "OTHER" },
+};
+
+#if 0 // untested
+static const struct sun8i_mbus_variant sun8i_h3_mbus = {
+	.pmu_masters		= sun8i_h3_mbus_pmu_masters,
+	.num_pmu_masters	= ARRAY_SIZE(sun8i_h3_mbus_pmu_masters),
+	.min_dram_divider	= 1,
+	.max_dram_divider	= 16,
+	.odt_freq_mhz		= 400,
+};
+#endif
+
+static const struct sun8i_mbus_variant sun50i_a64_mbus = {
+	.pmu_masters		= sun8i_h3_mbus_pmu_masters,
+	.num_pmu_masters	= ARRAY_SIZE(sun8i_h3_mbus_pmu_masters),
+	.min_dram_divider	= 1,
+	.max_dram_divider	= 4,
+	.odt_freq_mhz		= 400,
+};
+
+static const struct of_device_id sun8i_mbus_of_match[] = {
+#if 0 // untested
+	{ .compatible = "allwinner,sun8i-a33-mbus", .data = &sun8i_a33_mbus },
+	{ .compatible = "allwinner,sun8i-a83t-mbus", .data = &sun8i_a33_mbus },
+	{ .compatible = "allwinner,sun8i-h3-mbus", .data = &sun8i_h3_mbus },
+#endif
+	{ .compatible = "allwinner,sun50i-a64-mbus", .data = &sun50i_a64_mbus },
+	{ .compatible = "allwinner,sun50i-h5-mbus", .data = &sun50i_a64_mbus },
+	{ },
+};
+MODULE_DEVICE_TABLE(of, sun8i_mbus_of_match);
+
+static SIMPLE_DEV_PM_OPS(sun8i_mbus_pm_ops, sun8i_mbus_suspend, sun8i_mbus_resume);
+
+static struct platform_driver sun8i_mbus_driver = {
+	.probe	= sun8i_mbus_probe,
+	.remove	= sun8i_mbus_remove,
+	.driver	= {
+		.name		= "sun8i-mbus",
+		.of_match_table	= sun8i_mbus_of_match,
+		.pm		= pm_ptr(&sun8i_mbus_pm_ops),
+	},
+};
+module_platform_driver(sun8i_mbus_driver);
+
+MODULE_AUTHOR("Samuel Holland <samuel@sholland.org>");
+MODULE_DESCRIPTION("Allwinner sun8i/sun50i MBUS DEVFREQ Driver");
+MODULE_LICENSE("GPL v2");
diff -Nuar -r --no-dereference linux-5.15.139/drivers/devfreq/Kconfig linux/drivers/devfreq/Kconfig
--- linux-5.15.139/drivers/devfreq/Kconfig	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/devfreq/Kconfig	2024-01-03 16:06:25.935131000 +0800
@@ -132,6 +132,14 @@
 	  It sets the frequency for the memory controller and reads the usage counts
 	  from hardware.
 
+config ARM_SUN8I_MBUS_DEVFREQ
+	tristate "sun8i/sun50i MBUS DEVFREQ Driver"
+	depends on ARCH_SUNXI || COMPILE_TEST
+	select DEVFREQ_GOV_SIMPLE_ONDEMAND
+	help
+	  This adds the DEVFREQ driver for the MBUS/DRAM controller in
+	  Allwinner sun8i and sun50i SoCs.
+
 source "drivers/devfreq/event/Kconfig"
 
 endif # PM_DEVFREQ
diff -Nuar -r --no-dereference linux-5.15.139/drivers/devfreq/devfreq.c linux/drivers/devfreq/devfreq.c
--- linux-5.15.139/drivers/devfreq/devfreq.c	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/devfreq/devfreq.c	2024-01-03 16:06:25.935131000 +0800
@@ -130,16 +130,10 @@
 
 	/*
 	 * Initialize minimum/maximum frequency from freq table.
-	 * The devfreq drivers can initialize this in either ascending or
-	 * descending order and devfreq core supports both.
+	 * The devfreq drivers should initialize this in ascending order.
 	 */
-	if (freq_table[0] < freq_table[devfreq->profile->max_state - 1]) {
-		*min_freq = freq_table[0];
-		*max_freq = freq_table[devfreq->profile->max_state - 1];
-	} else {
-		*min_freq = freq_table[devfreq->profile->max_state - 1];
-		*max_freq = freq_table[0];
-	}
+	*min_freq = freq_table[0];
+	*max_freq = freq_table[devfreq->profile->max_state - 1];
 
 	/* Apply constraints from PM QoS */
 	qos_min_freq = dev_pm_qos_read_value(devfreq->dev.parent,
@@ -827,7 +821,7 @@
 		goto err_dev;
 	}
 
-	if (!devfreq->profile->max_state && !devfreq->profile->freq_table) {
+	if (!devfreq->profile->max_state || !devfreq->profile->freq_table) {
 		mutex_unlock(&devfreq->lock);
 		err = set_freq_table(devfreq);
 		if (err < 0)
@@ -835,24 +829,28 @@
 		mutex_lock(&devfreq->lock);
 	}
 
-	devfreq->scaling_min_freq = find_available_min_freq(devfreq);
-	if (!devfreq->scaling_min_freq) {
-		mutex_unlock(&devfreq->lock);
-		err = -EINVAL;
-		goto err_dev;
-	}
-
-	devfreq->scaling_max_freq = find_available_max_freq(devfreq);
-	if (!devfreq->scaling_max_freq) {
-		mutex_unlock(&devfreq->lock);
-		err = -EINVAL;
-		goto err_dev;
-	}
-
-	devfreq->suspend_freq = dev_pm_opp_get_suspend_opp_freq(dev);
 	devfreq->opp_table = dev_pm_opp_get_opp_table(dev);
-	if (IS_ERR(devfreq->opp_table))
+	if (IS_ERR(devfreq->opp_table)) {
 		devfreq->opp_table = NULL;
+		devfreq->scaling_min_freq = 0;
+		devfreq->scaling_max_freq = ULONG_MAX;
+	} else {
+		devfreq->scaling_min_freq = find_available_min_freq(devfreq);
+		if (!devfreq->scaling_min_freq) {
+			mutex_unlock(&devfreq->lock);
+			err = -EINVAL;
+			goto err_dev;
+		}
+
+		devfreq->scaling_max_freq = find_available_max_freq(devfreq);
+		if (!devfreq->scaling_max_freq) {
+			mutex_unlock(&devfreq->lock);
+			err = -EINVAL;
+			goto err_dev;
+		}
+
+		devfreq->suspend_freq = dev_pm_opp_get_suspend_opp_freq(dev);
+	}
 
 	atomic_set(&devfreq->suspend_count, 0);
 
@@ -1986,6 +1984,31 @@
  */
 
 /**
+ * devfreq_recommended_freq() - Helper function to get the proper frequency from
+ *			        freq_table for the value given to target callback.
+ * @devfreq:	The devfreq device.
+ * @freq:	The frequency given to target function.
+ * @flags:	Flags handed from devfreq framework.
+ */
+void devfreq_recommended_freq(struct devfreq *devfreq,
+			      unsigned long *freq, u32 flags)
+{
+	const unsigned long *min = devfreq->profile->freq_table;
+	const unsigned long *max = min + devfreq->profile->max_state - 1;
+	const unsigned long *f;
+
+	if (flags & DEVFREQ_FLAG_LEAST_UPPER_BOUND) {
+		/* Find the first item lower than freq, or else min. */
+		for (f = max; f > min && *f > *freq; --f);
+	} else {
+		/* Find the first item higher than freq, or else max. */
+		for (f = min; f < max && *f < *freq; ++f);
+	}
+	*freq = *f;
+}
+EXPORT_SYMBOL(devfreq_recommended_freq);
+
+/**
  * devfreq_recommended_opp() - Helper function to get proper OPP for the
  *			     freq value given to target callback.
  * @dev:	The devfreq user device. (parent of devfreq)
diff -Nuar -r --no-dereference linux-5.15.139/drivers/firmware/arm_scpi.c linux/drivers/firmware/arm_scpi.c
--- linux-5.15.139/drivers/firmware/arm_scpi.c	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/firmware/arm_scpi.c	2024-01-03 16:06:25.935131000 +0800
@@ -184,6 +184,7 @@
 	CMD_SENSOR_VALUE,
 	CMD_SET_DEVICE_PWR_STATE,
 	CMD_GET_DEVICE_PWR_STATE,
+	CMD_SET_SYS_PWR_STATE,
 	CMD_MAX_COUNT,
 };
 
@@ -200,6 +201,7 @@
 	SCPI_CMD_SENSOR_VALUE,
 	SCPI_CMD_SET_DEVICE_PWR_STATE,
 	SCPI_CMD_GET_DEVICE_PWR_STATE,
+	SCPI_CMD_SET_SYS_PWR_STATE,
 };
 
 static int scpi_legacy_commands[CMD_MAX_COUNT] = {
@@ -215,6 +217,7 @@
 	LEGACY_SCPI_CMD_SENSOR_VALUE,
 	-1, /* SET_DEVICE_PWR_STATE */
 	-1, /* GET_DEVICE_PWR_STATE */
+	LEGACY_SCPI_CMD_SYS_PWR_STATE,
 };
 
 struct scpi_xfer {
@@ -231,7 +234,8 @@
 
 struct scpi_chan {
 	struct mbox_client cl;
-	struct mbox_chan *chan;
+	struct mbox_chan *rx_chan;
+	struct mbox_chan *tx_chan;
 	void __iomem *tx_payload;
 	void __iomem *rx_payload;
 	struct list_head rx_pending;
@@ -505,7 +509,7 @@
 	msg->rx_len = rx_len;
 	reinit_completion(&msg->done);
 
-	ret = mbox_send_message(scpi_chan->chan, msg);
+	ret = mbox_send_message(scpi_chan->tx_chan, msg);
 	if (ret < 0 || !rx_buf)
 		goto out;
 
@@ -779,6 +783,12 @@
 				 sizeof(dev_set), &stat, sizeof(stat));
 }
 
+static int scpi_sys_set_power_state(u8 pstate)
+{
+	return scpi_send_message(CMD_SET_SYS_PWR_STATE, &pstate,
+				 sizeof(pstate), NULL, 0);
+}
+
 static struct scpi_ops scpi_ops = {
 	.get_version = scpi_get_version,
 	.clk_get_range = scpi_clk_get_range,
@@ -795,6 +805,7 @@
 	.sensor_get_value = scpi_sensor_get_value,
 	.device_get_power_state = scpi_device_get_power_state,
 	.device_set_power_state = scpi_device_set_power_state,
+	.sys_set_power_state = scpi_sys_set_power_state,
 };
 
 struct scpi_ops *get_scpi_ops(void)
@@ -856,8 +867,13 @@
 	struct scpi_drvinfo *info = data;
 	int i;
 
-	for (i = 0; i < info->num_chans; i++)
-		mbox_free_channel(info->channels[i].chan);
+	for (i = 0; i < info->num_chans; i++) {
+		struct scpi_chan *pchan = &info->channels[i];
+
+		if (pchan->tx_chan != pchan->rx_chan)
+			mbox_free_channel(pchan->tx_chan);
+		mbox_free_channel(pchan->rx_chan);
+	}
 }
 
 static int scpi_remove(struct platform_device *pdev)
@@ -914,6 +930,7 @@
 	struct device *dev = &pdev->dev;
 	struct device_node *np = dev->of_node;
 	struct scpi_drvinfo *scpi_drvinfo;
+	bool use_mbox_names = false;
 
 	scpi_drvinfo = devm_kzalloc(dev, sizeof(*scpi_drvinfo), GFP_KERNEL);
 	if (!scpi_drvinfo)
@@ -927,6 +944,14 @@
 		dev_err(dev, "no mboxes property in '%pOF'\n", np);
 		return -ENODEV;
 	}
+	if (of_get_property(dev->of_node, "mbox-names", NULL)) {
+		use_mbox_names = true;
+		if (count != 2) {
+			dev_err(dev, "need exactly 2 mboxes with mbox-names\n");
+			return -ENODEV;
+		}
+		count /= 2;
+	}
 
 	scpi_drvinfo->channels =
 		devm_kcalloc(dev, count, sizeof(struct scpi_chan), GFP_KERNEL);
@@ -975,15 +1000,34 @@
 		mutex_init(&pchan->xfers_lock);
 
 		ret = scpi_alloc_xfer_list(dev, pchan);
-		if (!ret) {
-			pchan->chan = mbox_request_channel(cl, idx);
-			if (!IS_ERR(pchan->chan))
-				continue;
-			ret = PTR_ERR(pchan->chan);
-			if (ret != -EPROBE_DEFER)
-				dev_err(dev, "failed to get channel%d err %d\n",
-					idx, ret);
+		if (ret)
+			return ret;
+
+		if (use_mbox_names) {
+			pchan->rx_chan = mbox_request_channel_byname(cl, "rx");
+			if (IS_ERR(pchan->rx_chan)) {
+				ret = PTR_ERR(pchan->rx_chan);
+				goto fail;
+			}
+			pchan->tx_chan = mbox_request_channel_byname(cl, "tx");
+			if (IS_ERR(pchan->rx_chan)) {
+				ret = PTR_ERR(pchan->tx_chan);
+				goto fail;
+			}
+		} else {
+			pchan->rx_chan = mbox_request_channel(cl, idx);
+			if (IS_ERR(pchan->rx_chan)) {
+				ret = PTR_ERR(pchan->rx_chan);
+				goto fail;
+			}
+			pchan->tx_chan = pchan->rx_chan;
 		}
+		continue;
+
+fail:
+		if (ret != -EPROBE_DEFER)
+			dev_err(dev, "failed to get channel%d err %d\n",
+				idx, ret);
 		return ret;
 	}
 
diff -Nuar -r --no-dereference linux-5.15.139/drivers/mailbox/mailbox.c linux/drivers/mailbox/mailbox.c
--- linux-5.15.139/drivers/mailbox/mailbox.c	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/mailbox/mailbox.c	2024-01-03 16:06:25.935131000 +0800
@@ -268,6 +268,24 @@
 
 	msg_submit(chan);
 
+	if (chan->cl->tx_block && timekeeping_suspended) {
+		int i = chan->cl->tx_tout * 10;
+		bool txdone;
+
+		while (i--) {
+			txdone = chan->mbox->ops->last_tx_done(chan);
+			if (txdone) {
+				tx_tick(chan, 0);
+				return 0;
+			}
+
+			udelay(100);
+		}
+
+		tx_tick(chan, -ETIME);
+		return -ETIME;
+	}
+
 	if (chan->cl->tx_block) {
 		unsigned long wait;
 		int ret;
diff -Nuar -r --no-dereference linux-5.15.139/drivers/bus/sun50i-de2.c linux/drivers/bus/sun50i-de2.c
--- linux-5.15.139/drivers/bus/sun50i-de2.c	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/bus/sun50i-de2.c	2024-01-03 16:06:25.935131000 +0800
@@ -16,7 +16,8 @@
 
 	ret = sunxi_sram_claim(&pdev->dev);
 	if (ret) {
-		dev_err(&pdev->dev, "Error couldn't map SRAM to device\n");
+		dev_err_probe(&pdev->dev, ret,
+			      "Couldn't map SRAM to device\n");
 		return ret;
 	}
 
diff -Nuar -r --no-dereference linux-5.15.139/drivers/bus/sunxi-rsb.c linux/drivers/bus/sunxi-rsb.c
--- linux-5.15.139/drivers/bus/sunxi-rsb.c	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/bus/sunxi-rsb.c	2024-01-03 16:06:25.935131000 +0800
@@ -329,29 +329,26 @@
 	return 0;
 }
 
-static int sunxi_rsb_read(struct sunxi_rsb *rsb, u8 rtaddr, u8 addr,
-			  u32 *buf, size_t len)
+/* RSB regmap functions */
+struct sunxi_rsb_ctx {
+	struct sunxi_rsb_device *rdev;
+	u32 mask;
+	u8 rd_cmd;
+	u8 wr_cmd;
+};
+
+static int regmap_sunxi_rsb_reg_read(void *context, unsigned int reg,
+				     unsigned int *val)
 {
-	u32 cmd;
+	struct sunxi_rsb_ctx *ctx = context;
+	struct sunxi_rsb_device *rdev = ctx->rdev;
+	struct sunxi_rsb *rsb = rdev->rsb;
 	int ret;
 
-	if (!buf)
+	if (!val)
 		return -EINVAL;
-
-	switch (len) {
-	case 1:
-		cmd = RSB_CMD_RD8;
-		break;
-	case 2:
-		cmd = RSB_CMD_RD16;
-		break;
-	case 4:
-		cmd = RSB_CMD_RD32;
-		break;
-	default:
-		dev_err(rsb->dev, "Invalid access width: %zd\n", len);
+	if (reg > 0xff)
 		return -EINVAL;
-	}
 
 	ret = pm_runtime_resume_and_get(rsb->dev);
 	if (ret)
@@ -359,15 +356,15 @@
 
 	mutex_lock(&rsb->lock);
 
-	writel(addr, rsb->regs + RSB_ADDR);
-	writel(RSB_DAR_RTA(rtaddr), rsb->regs + RSB_DAR);
-	writel(cmd, rsb->regs + RSB_CMD);
+	writel(reg, rsb->regs + RSB_ADDR);
+	writel(RSB_DAR_RTA(rdev->rtaddr), rsb->regs + RSB_DAR);
+	writel(ctx->rd_cmd, rsb->regs + RSB_CMD);
 
 	ret = _sunxi_rsb_run_xfer(rsb);
 	if (ret)
 		goto unlock;
 
-	*buf = readl(rsb->regs + RSB_DATA) & GENMASK(len * 8 - 1, 0);
+	*val = readl(rsb->regs + RSB_DATA) & ctx->mask;
 
 unlock:
 	mutex_unlock(&rsb->lock);
@@ -378,29 +375,16 @@
 	return ret;
 }
 
-static int sunxi_rsb_write(struct sunxi_rsb *rsb, u8 rtaddr, u8 addr,
-			   const u32 *buf, size_t len)
+static int regmap_sunxi_rsb_reg_write(void *context, unsigned int reg,
+				      unsigned int val)
 {
-	u32 cmd;
+	struct sunxi_rsb_ctx *ctx = context;
+	struct sunxi_rsb_device *rdev = ctx->rdev;
+	struct sunxi_rsb *rsb = rdev->rsb;
 	int ret;
 
-	if (!buf)
-		return -EINVAL;
-
-	switch (len) {
-	case 1:
-		cmd = RSB_CMD_WR8;
-		break;
-	case 2:
-		cmd = RSB_CMD_WR16;
-		break;
-	case 4:
-		cmd = RSB_CMD_WR32;
-		break;
-	default:
-		dev_err(rsb->dev, "Invalid access width: %zd\n", len);
+	if (reg > 0xff)
 		return -EINVAL;
-	}
 
 	ret = pm_runtime_resume_and_get(rsb->dev);
 	if (ret)
@@ -408,10 +392,11 @@
 
 	mutex_lock(&rsb->lock);
 
-	writel(addr, rsb->regs + RSB_ADDR);
-	writel(RSB_DAR_RTA(rtaddr), rsb->regs + RSB_DAR);
-	writel(*buf, rsb->regs + RSB_DATA);
-	writel(cmd, rsb->regs + RSB_CMD);
+	writel(reg, rsb->regs + RSB_ADDR);
+	writel(RSB_DAR_RTA(rdev->rtaddr), rsb->regs + RSB_DAR);
+	writel(val, rsb->regs + RSB_DATA);
+	writel(ctx->wr_cmd, rsb->regs + RSB_CMD);
+
 	ret = _sunxi_rsb_run_xfer(rsb);
 
 	mutex_unlock(&rsb->lock);
@@ -422,33 +407,6 @@
 	return ret;
 }
 
-/* RSB regmap functions */
-struct sunxi_rsb_ctx {
-	struct sunxi_rsb_device *rdev;
-	int size;
-};
-
-static int regmap_sunxi_rsb_reg_read(void *context, unsigned int reg,
-				     unsigned int *val)
-{
-	struct sunxi_rsb_ctx *ctx = context;
-	struct sunxi_rsb_device *rdev = ctx->rdev;
-
-	if (reg > 0xff)
-		return -EINVAL;
-
-	return sunxi_rsb_read(rdev->rsb, rdev->rtaddr, reg, val, ctx->size);
-}
-
-static int regmap_sunxi_rsb_reg_write(void *context, unsigned int reg,
-				      unsigned int val)
-{
-	struct sunxi_rsb_ctx *ctx = context;
-	struct sunxi_rsb_device *rdev = ctx->rdev;
-
-	return sunxi_rsb_write(rdev->rsb, rdev->rtaddr, reg, &val, ctx->size);
-}
-
 static void regmap_sunxi_rsb_free_ctx(void *context)
 {
 	struct sunxi_rsb_ctx *ctx = context;
@@ -468,13 +426,24 @@
 		const struct regmap_config *config)
 {
 	struct sunxi_rsb_ctx *ctx;
+	u8 rd_cmd, wr_cmd;
 
 	switch (config->val_bits) {
 	case 8:
+		rd_cmd = RSB_CMD_RD8;
+		wr_cmd = RSB_CMD_WR8;
+		break;
 	case 16:
+		rd_cmd = RSB_CMD_RD16;
+		wr_cmd = RSB_CMD_WR16;
+		break;
 	case 32:
+		rd_cmd = RSB_CMD_RD32;
+		wr_cmd = RSB_CMD_WR32;
 		break;
 	default:
+		dev_err(&rdev->dev, "Invalid RSB access width: %d\n",
+			config->val_bits);
 		return ERR_PTR(-EINVAL);
 	}
 
@@ -483,7 +452,9 @@
 		return ERR_PTR(-ENOMEM);
 
 	ctx->rdev = rdev;
-	ctx->size = config->val_bits / 8;
+	ctx->mask = GENMASK(config->val_bits - 1, 0);
+	ctx->rd_cmd = rd_cmd;
+	ctx->wr_cmd = wr_cmd;
 
 	return ctx;
 }
@@ -745,7 +716,6 @@
 {
 	struct device *dev = &pdev->dev;
 	struct device_node *np = dev->of_node;
-	struct resource *r;
 	struct sunxi_rsb *rsb;
 	u32 clk_freq = 3000000;
 	int irq, ret;
@@ -765,8 +735,8 @@
 	rsb->dev = dev;
 	rsb->clk_freq = clk_freq;
 	platform_set_drvdata(pdev, rsb);
-	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	rsb->regs = devm_ioremap_resource(dev, r);
+
+	rsb->regs = devm_platform_ioremap_resource(pdev, 0);
 	if (IS_ERR(rsb->regs))
 		return PTR_ERR(rsb->regs);
 
diff -Nuar -r --no-dereference linux-5.15.139/drivers/misc/Makefile linux/drivers/misc/Makefile
--- linux-5.15.139/drivers/misc/Makefile	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/misc/Makefile	2024-01-03 16:06:25.935131000 +0800
@@ -59,3 +59,5 @@
 obj-$(CONFIG_XILINX_SDFEC)	+= xilinx_sdfec.o
 obj-$(CONFIG_HISI_HIKEY_USB)	+= hisi_hikey_usb.o
 obj-$(CONFIG_HI6421V600_IRQ)	+= hi6421v600-irq.o
+obj-$(CONFIG_MODEM_POWER)	+= modem-power.o
+obj-$(CONFIG_SUNXI_ADDR_MGT)    += sunxi-addr/
\ 
diff -Nuar -r --no-dereference linux-5.15.139/drivers/misc/Kconfig linux/drivers/misc/Kconfig
--- linux-5.15.139/drivers/misc/Kconfig	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/misc/Kconfig	2024-01-03 16:06:25.935131000 +0800
@@ -470,6 +470,13 @@
 	  switching between the dual-role USB-C port and the USB-A host ports
 	  using only one USB controller.
 
+config MODEM_POWER
+	tristate "Modem power/wakeup support for EG25, MG3732, etc."
+	depends on OF && SERIAL_DEV_BUS && RFKILL
+	help
+	  This driver provides support for powering up and handling
+	  wakeup signals for various modems.
+
 source "drivers/misc/c2port/Kconfig"
 source "drivers/misc/eeprom/Kconfig"
 source "drivers/misc/cb710/Kconfig"
@@ -487,4 +494,5 @@
 source "drivers/misc/habanalabs/Kconfig"
 source "drivers/misc/uacce/Kconfig"
 source "drivers/misc/pvpanic/Kconfig"
+source "drivers/misc/sunxi-addr/Kconfig"
 endmenu
diff -Nuar -r --no-dereference linux-5.15.139/drivers/misc/modem-power.c linux/drivers/misc/modem-power.c
--- linux-5.15.139/drivers/misc/modem-power.c	1970-01-01 08:00:00.000000000 +0800
+++ linux/drivers/misc/modem-power.c	2024-01-03 16:06:25.935131000 +0800
@@ -0,0 +1,1976 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Modem power control driver.
+ *
+ * Ondrej Jirman <megous@megous.com>
+ *
+ * How this works
+ * --------------
+ *
+ * The driver:
+ * - can be registered as a platform or serial device
+ * - will use gpios, regulator and (optionally) serial port to control the modem
+ * - exposes a character device to control the modem power and receive various
+ *   events
+ * - exposes sysfs interface to control modem power and wakeup
+ * - supports multiple modem types and instances
+ *
+ * Power up/power down:
+ * - may take a lot of time (eg. ~13-22s powerup, >22s powerdown)
+ * - happens on a private workqueue under a lock
+ * - may happen from shutdown hook
+ * - prevents suspend when powerup/powerdown is in progress
+ * - is serialized and there's no abort of in-progress operations
+ * - for specific power sequence see comments in the section for each
+ *   supported modem variant
+ * - the driver monitors the power status of the modem (optionally)
+ *   and tries to complete the powerdown initiated via AT command
+ * - the driver tries to detect when the modem is killswitched off
+ *   and updates the driver status to reflect that
+ *
+ * Suspend/resume:
+ * - suspend is blocked if powerup/down is in progress
+ * - modem can wakeup the host over gpio based IRQ (RI signal)
+ * - the driver will assert ap_ready after resume finishes
+ *
+ * Rfkill:
+ * - the driver implements a rfkill interface if rfkill gpio is available
+ */
+
+//#define DEBUG
+
+#include <linux/wait.h>
+#include <linux/interrupt.h>
+#include <linux/device.h>
+#include <linux/cdev.h>
+#include <linux/kfifo.h>
+#include <linux/module.h>
+#include <linux/poll.h>
+#include <linux/spinlock.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/gpio/consumer.h>
+#include <linux/regulator/consumer.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/serdev.h>
+#include <linux/rfkill.h>
+
+#define DRIVER_NAME "modem-power"
+
+enum {
+	MPWR_REQ_NONE = 0,
+	MPWR_REQ_RESET,
+	MPWR_REQ_PWDN,
+	MPWR_REQ_PWUP,
+};
+
+enum {
+	MPWR_MODE_NORMAL = 1,
+	MPWR_MODE_DUMB,
+	MPWR_MODE_FASTBOOT,
+	MPWR_MODE_ALT1,
+	MPWR_MODE_ALT2,
+};
+
+struct mpwr_dev;
+
+struct mpwr_gpio {
+	const char* name;
+	unsigned desc_off;
+	int flags;
+	bool required;
+	int irq_flags;
+	unsigned irq_off;
+};
+
+#define MPWR_GPIO_DEF(_name, _flags, _req) \
+	{ .name = #_name, \
+	  .desc_off = offsetof(struct mpwr_dev, _name##_gpio), \
+	  .flags = _flags, \
+	  .required = _req, \
+	}
+
+#define MPWR_GPIO_DEF_IRQ(_name, _flags, _req, _irq_flags) \
+	{ .name = #_name, \
+	  .desc_off = offsetof(struct mpwr_dev, _name##_gpio), \
+	  .flags = _flags, \
+	  .required = _req, \
+	  .irq_flags = _irq_flags, \
+	  .irq_off = offsetof(struct mpwr_dev, _name##_irq), \
+	}
+
+struct mpwr_variant {
+	int (*power_init)(struct mpwr_dev* mpwr);
+	int (*power_up)(struct mpwr_dev* mpwr);
+	int (*power_down)(struct mpwr_dev* mpwr);
+	int (*reset)(struct mpwr_dev* mpwr);
+	void (*recv_msg)(struct mpwr_dev *mpwr, const char *msg);
+	int (*suspend)(struct mpwr_dev *mpwr);
+	int (*resume)(struct mpwr_dev *mpwr);
+	const struct mpwr_gpio* gpios;
+	bool regulator_required;
+	bool monitor_wakeup;
+};
+
+struct mpwr_dev {
+	struct device *dev;
+	const struct mpwr_variant* variant;
+
+	wait_queue_head_t wait;
+
+	/* serdev */
+	struct serdev_device *serdev;
+	char rcvbuf[4096];
+	size_t rcvbuf_fill;
+	char msg[4096];
+        int msg_len;
+        int msg_ok;
+	//struct kfifo kfifo;
+	DECLARE_KFIFO(kfifo, unsigned char, 4096);
+
+	/* power */
+	struct regulator *regulator;
+
+	/* outputs */
+	struct gpio_desc *enable_gpio;
+	struct gpio_desc *reset_gpio;
+	struct gpio_desc *pwrkey_gpio;
+	struct gpio_desc *sleep_gpio;
+	struct gpio_desc *dtr_gpio;
+	struct gpio_desc *host_ready_gpio;
+	struct gpio_desc *cts_gpio;
+	struct gpio_desc *rts_gpio;
+
+	/* inputs */
+	struct gpio_desc *status_gpio;
+	struct gpio_desc *wakeup_gpio;
+	int wakeup_irq;
+	bool status_pwrkey_multiplexed;
+
+	/* config */
+	struct cdev cdev;
+	dev_t major;
+
+	/* rfkill */
+	struct rfkill *rfkill;
+
+	/* powerup/dn work queue */
+	struct workqueue_struct *wq;
+	struct work_struct power_work;
+	struct work_struct finish_pdn_work;
+        struct mutex modem_lock;
+
+	// change
+	spinlock_t lock; /* protects last_request */
+	int last_request;
+	int powerup_mode;
+	ktime_t last_wakeup;
+
+	struct timer_list wd_timer;
+        struct delayed_work host_ready_work;
+
+	unsigned long flags[1];
+};
+
+enum {
+	/* modem is powered */
+	MPWR_F_POWERED,
+	MPWR_F_POWER_CHANGE_INPROGRESS,
+	MPWR_F_KILLSWITCHED,
+	/* we got a wakeup from the modem */
+	MPWR_F_GOT_WAKEUP,
+        /* serdev */
+        MPWR_F_RECEIVING_MSG,
+        /* eg25 */
+        MPWR_F_GOT_PDN,
+	/* config options */
+        MPWR_F_BLOCKED,
+	/* file */
+	MPWR_F_OPEN,
+	MPWR_F_OVERFLOW,
+};
+
+static struct class* mpwr_class;
+
+static int mpwr_serdev_at_cmd(struct mpwr_dev *mpwr, const char *msg, int timeout_ms);
+static int mpwr_serdev_at_cmd_with_retry(struct mpwr_dev *mpwr, const char *msg,
+					 int timeout_ms, int tries);
+static int mpwr_serdev_at_cmd_with_retry_ignore_timeout(struct mpwr_dev *mpwr, const char *msg,
+							int timeout_ms, int tries);
+
+// {{{ mg2723 variant
+
+static int mpwr_mg2723_power_init(struct mpwr_dev* mpwr)
+{
+	// if the device has power applied or doesn't have regulator
+	// configured (we assume it's always powered) initialize GPIO
+	// to shut it down initially
+	if (!mpwr->regulator || regulator_is_enabled(mpwr->regulator)) {
+		gpiod_set_value(mpwr->enable_gpio, 0);
+		gpiod_set_value(mpwr->reset_gpio, 1);
+	} else {
+		// device is not powered, don't drive the gpios
+		gpiod_direction_input(mpwr->enable_gpio);
+		gpiod_direction_input(mpwr->reset_gpio);
+	}
+
+	return 0;
+}
+
+static int mpwr_mg2723_power_up(struct mpwr_dev* mpwr)
+{
+	int ret;
+
+	// power up
+	if (mpwr->regulator) {
+		ret = regulator_enable(mpwr->regulator);
+		if (ret < 0) {
+			dev_err(mpwr->dev,
+				"can't enable power supply err=%d", ret);
+			return ret;
+		}
+	}
+
+	gpiod_direction_output(mpwr->enable_gpio, 1);
+	gpiod_direction_output(mpwr->reset_gpio, 1);
+	msleep(300);
+	gpiod_set_value(mpwr->reset_gpio, 0);
+
+	return 0;
+}
+
+static int mpwr_mg2723_power_down(struct mpwr_dev* mpwr)
+{
+	gpiod_set_value(mpwr->enable_gpio, 0);
+	msleep(50);
+
+	if (mpwr->regulator) {
+		regulator_disable(mpwr->regulator);
+
+		gpiod_direction_input(mpwr->enable_gpio);
+		gpiod_direction_input(mpwr->reset_gpio);
+	} else {
+		gpiod_set_value(mpwr->reset_gpio, 1);
+	}
+
+	return 0;
+}
+
+static int mpwr_mg2723_reset(struct mpwr_dev* mpwr)
+{
+	gpiod_set_value(mpwr->reset_gpio, 1);
+	msleep(300);
+	gpiod_set_value(mpwr->reset_gpio, 0);
+
+	return 0;
+}
+
+static const struct mpwr_gpio mpwr_mg2723_gpios[] = {
+	MPWR_GPIO_DEF(enable, GPIOD_IN, true),
+	MPWR_GPIO_DEF(reset, GPIOD_IN, true),
+	MPWR_GPIO_DEF_IRQ(wakeup, GPIOD_IN, true, IRQF_TRIGGER_FALLING),
+	{ },
+};
+
+static const struct mpwr_variant mpwr_mg2723_variant = {
+	.power_init = mpwr_mg2723_power_init,
+	.power_up = mpwr_mg2723_power_up,
+	.power_down = mpwr_mg2723_power_down,
+	.reset = mpwr_mg2723_reset,
+	.gpios = mpwr_mg2723_gpios,
+};
+
+// }}}
+// {{{ eg25 variant
+
+static bool mpwr_eg25_qcfg_airplanecontrol_is_ok(const char* v)
+{
+	return strstarts(v, "1,");
+}
+
+struct mpwr_eg25_qcfg {
+	const char* name;
+	const char* val;
+	bool (*is_ok)(const char* val);
+};
+
+#define EG25G_LATEST_KNOWN_FIRMWARE "EG25GGBR07A08M2G_01.002.07"
+
+static const struct mpwr_eg25_qcfg mpwr_eg25_qcfgs[] = {
+	//{ "risignaltype",       "\"respective\"", },
+	{ "risignaltype",       "\"physical\"", },
+	{ "urc/ri/ring",        "\"pulse\",1,1000,5000,\"off\",1", },
+	{ "urc/ri/smsincoming", "\"pulse\",1,1", },
+	{ "urc/ri/other",       "\"off\",1,1", },
+	{ "urc/ri/pin",         "uart_ri", },
+	{ "urc/delay",          "0", },
+
+	//{ "sleep/datactrl",     "0,300,1", },
+
+	{ "sleepind/level",     "0", },
+	{ "wakeupin/level",     "0", },
+
+	{ "ApRstLevel",		"0", },
+	{ "ModemRstLevel",	"0", },
+
+	// in EG25-G this tries to modify file in /etc (read-only)
+	// and fails
+	//{ "dbgctl",		"0", },
+
+	// we don't need AP_READY
+	{ "apready",            "0,0,500", },
+
+	{ "airplanecontrol",    "1",   mpwr_eg25_qcfg_airplanecontrol_is_ok },
+
+	// available since firmware R07A08_01.002.01.002
+	{ "fast/poweroff",	"1" },
+};
+
+static char* mpwr_serdev_get_response_value(struct mpwr_dev *mpwr,
+					    const char* prefix)
+{
+	int off;
+
+	for (off = 0; off < mpwr->msg_len; off += strlen(mpwr->msg + off) + 1)
+		if (strstarts(mpwr->msg + off, prefix))
+			return mpwr->msg + off + strlen(prefix);
+
+	return NULL;
+}
+
+static struct gpio_desc *mpwr_eg25_get_pwrkey_gpio(struct mpwr_dev *mpwr)
+{
+	if (mpwr->status_pwrkey_multiplexed)
+		return mpwr->status_gpio;
+
+	return mpwr->pwrkey_gpio;
+}
+
+/*
+ * Gpio meanings
+ * -------------
+ *
+ * enable_gpio - 1 = enables RF, 0 = disables RF
+ * sleep_gpio  - 1 = puts modem to sleep, 0 = wakes up the modem (must be 0
+ *               during poweron)
+ * reset_gpio  - accepts 150-460ms reset pulse (high __|^|__)
+ * pwrkey_gpio - accepts 100ms-650ms pulse for powerup (high __|^|__)
+ *                       650ms+ pulse for powerdown
+ *                       (initiated after pulse ends, pulse may have indefinite
+ *                        duration)
+ * status_gpio - modem power status 0 = powered  1 = unpowered
+ * wakeup_gpio - "ring indicator" output from the modem
+ * host_ready_gpio - AP_READY pin - host is ready to receive URCs
+ *
+ * (pwrkey may be multiplexed with status_gpio)
+ *
+ * Modem behavior
+ * --------------
+ *
+ * wakeup_gpio (RI):
+ * - goes high shortly after power is applied (~15ms)
+ * - goes low when RDY is sent
+ *
+ * dtr_gpio
+ * - when high, modem can sleep if requested
+ * - H->L will wake up a sleeping modem
+ * - internal pull-up
+ *
+ * ri
+ * - pulled low when there's URC
+ * - modem wakes up on URC automatically
+ *
+ * - AT+QURCCFG
+ * - AT+QINDCFG="csq",1
+ * - AT+QINDCFG="ring",1
+ * - AT+QINDCFG="smsincoming",1
+ * - AT+CGREG=0
+ * - AT+CREG=0
+ *
+ * - AT+QURCCFG="urcport","uart1"
+ */
+static int mpwr_eg25_power_up(struct mpwr_dev* mpwr)
+{
+	struct gpio_desc *pwrkey_gpio = mpwr_eg25_get_pwrkey_gpio(mpwr);
+	bool wakeup_ok, status_ok;
+	bool needs_restart = false;
+	u32 speed = 115200;
+	int ret, i, off;
+	ktime_t start;
+	int mode = mpwr->powerup_mode;
+
+	if (regulator_is_enabled(mpwr->regulator))
+		dev_warn(mpwr->dev,
+			 "regulator was already enabled during powerup");
+
+	/* Enable the modem power. */
+	ret = regulator_enable(mpwr->regulator);
+	if (ret < 0) {
+		dev_err(mpwr->dev,
+			"can't enable power supply err=%d", ret);
+		return ret;
+	}
+
+	/* Drive default gpio signals during powerup */
+	/* host_ready_gpio should be 1 during normal powerup */
+	gpiod_direction_output(mpwr->host_ready_gpio, mode != MPWR_MODE_ALT2);
+	/* #W_DISABLE must be left pulled up during modem power up
+	 * early on, because opensource bootloader uses this signal to enter
+	 * fastboot mode when it's pulled down.
+	 *
+	 * This should be 1 for normal powerup and 0 for fastboot mode with
+	 * special Biktor's firmware.
+	 */
+	gpiod_direction_output(mpwr->enable_gpio, mode != MPWR_MODE_FASTBOOT);
+	gpiod_direction_output(mpwr->sleep_gpio, 0);
+	gpiod_direction_output(mpwr->reset_gpio, 0);
+	gpiod_direction_output(pwrkey_gpio, 0);
+	/* dtr_gpio should be 0 during normal powerup */
+	gpiod_direction_output(mpwr->dtr_gpio, mode == MPWR_MODE_ALT1);
+
+	/* Wait for powerup. (30ms min. according to datasheet) */
+	msleep(50);
+
+	/* Send 200ms pwrkey pulse to initiate poweron */
+	gpiod_set_value(pwrkey_gpio, 1);
+	msleep(200);
+	gpiod_set_value(pwrkey_gpio, 0);
+
+	/* skip modem killswitch status checks in fastboot bootloader entry mode */
+	if (mode != MPWR_MODE_NORMAL)
+		goto open_serdev;
+
+	/* Switch status key to input, in case it's multiplexed with pwrkey. */
+	gpiod_direction_input(mpwr->status_gpio);
+
+	/*
+	 * Wait for status/wakeup change, assume good values, if CTS/status
+	 * signals, are not configured.
+	 */
+	status_ok = mpwr->status_gpio ? false : true;
+	wakeup_ok = mpwr->wakeup_gpio ? false : true;
+
+	/* wait up to 10s for status */
+	start = ktime_get();
+	while (ktime_ms_delta(ktime_get(), start) < 10000) {
+		if (!wakeup_ok && mpwr->wakeup_gpio && gpiod_get_value(mpwr->wakeup_gpio)) {
+			dev_info(mpwr->dev, "wakeup ok\n");
+			wakeup_ok = true;
+		}
+
+		if (!status_ok && mpwr->status_gpio && !gpiod_get_value(mpwr->status_gpio)) {
+			dev_info(mpwr->dev, "status ok\n");
+			status_ok = true;
+		}
+
+		/* modem is ready */
+		if (wakeup_ok && status_ok)
+			break;
+
+		msleep(50);
+	}
+
+	if (!wakeup_ok) {
+		dev_err(mpwr->dev, "The modem looks kill-switched\n");
+		if (!test_and_set_bit(MPWR_F_KILLSWITCHED, mpwr->flags))
+			sysfs_notify(&mpwr->dev->kobj, NULL, "killswitched");
+		goto err_shutdown_noclose;
+	}
+
+	if (!status_ok) {
+		dev_err(mpwr->dev, "The modem didn't report powerup success in time\n");
+		goto err_shutdown_noclose;
+	}
+
+	if (test_and_clear_bit(MPWR_F_KILLSWITCHED, mpwr->flags))
+		sysfs_notify(&mpwr->dev->kobj, NULL, "killswitched");
+
+open_serdev:
+	/* open serial console */
+	ret = serdev_device_open(mpwr->serdev);
+	if (ret) {
+		dev_err(mpwr->dev, "error opening serdev (%d)\n", ret);
+		goto err_shutdown_noclose;
+	}
+
+	of_property_read_u32(mpwr->dev->of_node, "current-speed", &speed);
+	serdev_device_set_baudrate(mpwr->serdev, speed);
+	serdev_device_set_flow_control(mpwr->serdev, false);
+	ret = serdev_device_set_parity(mpwr->serdev, SERDEV_PARITY_NONE);
+	if (ret) {
+		dev_err(mpwr->dev, "error setting serdev parity (%d)\n", ret);
+		goto err_shutdown;
+	}
+
+	if (mode != MPWR_MODE_NORMAL)
+		goto powered_up;
+
+	ret = mpwr_serdev_at_cmd_with_retry_ignore_timeout(mpwr, "AT&FE0", 1000, 30);
+	if (ret)
+		goto err_shutdown;
+
+	/* print firmware version */
+        ret = mpwr_serdev_at_cmd_with_retry(mpwr, "AT+QVERSION;+QSUBSYSVER", 1000, 15);
+        if (ret == 0 && mpwr->msg_len > 0) {
+		bool outdated = false;
+
+		dev_info(mpwr->dev, "===================================================\n");
+		for (off = 0; off < mpwr->msg_len; off += strlen(mpwr->msg + off) + 1) {
+			if (strstr(mpwr->msg + off, "Project Rev") && !strstr(mpwr->msg + off, EG25G_LATEST_KNOWN_FIRMWARE))
+				outdated = true;
+
+			dev_info(mpwr->dev, "%s\n", mpwr->msg + off);
+		}
+		dev_info(mpwr->dev, "===================================================\n");
+
+		if (outdated)
+			dev_warn(mpwr->dev, "Your modem has an outdated firmware. Latest know version is %s. Consider updating.\n", EG25G_LATEST_KNOWN_FIRMWARE);
+	}
+
+	/* print ADB key to dmesg */
+        ret = mpwr_serdev_at_cmd_with_retry(mpwr, "AT+QADBKEY?", 1000, 15);
+        if (ret == 0) {
+		const char *val = mpwr_serdev_get_response_value(mpwr, "+QADBKEY: ");
+		if (val)
+			dev_info(mpwr->dev, "ADB KEY is '%s' (you can use it to unlock ADB access to the modem, see https://xnux.eu/devices/feature/modem-pp.html)\n", val);
+	}
+
+        // check DAI config
+        ret = mpwr_serdev_at_cmd_with_retry(mpwr, "AT+QDAI?", 1000, 15);
+        if (ret == 0) {
+		const char *val = mpwr_serdev_get_response_value(mpwr, "+QDAI: ");
+		const char *needed_val = NULL;
+		char buf[128];
+
+		if (val) {
+			of_property_read_string(mpwr->dev->of_node, "quectel,qdai", &needed_val);
+
+			if (needed_val && strcmp(needed_val, val)) {
+				dev_warn(mpwr->dev, "QDAI is '%s' (changing to '%s')\n", val, needed_val);
+
+				/* update qdai */
+				snprintf(buf, sizeof buf, "AT+QDAI=%s", needed_val);
+				ret = mpwr_serdev_at_cmd(mpwr, buf, 5000);
+				if (ret == 0)
+					needs_restart = true;
+			} else {
+				dev_info(mpwr->dev, "QDAI is '%s'\n", val);
+			}
+		}
+	}
+
+	/* reset the modem, to apply QDAI config if necessary */
+	if (needs_restart) {
+		dev_info(mpwr->dev, "Restarting modem\n");
+
+		/* reboot is broken with fastboot enabled */
+		mpwr_serdev_at_cmd(mpwr, "AT+QCFG=\"fast/poweroff\",0", 5000);
+
+		ret = mpwr_serdev_at_cmd(mpwr, "AT+CFUN=1,1", 5000);
+		if (ret)
+			goto err_shutdown;
+
+		/* wait a bit before starting to probe the modem again */
+		msleep(6000);
+
+		ret = mpwr_serdev_at_cmd_with_retry_ignore_timeout(mpwr, "AT&FE0", 1000, 30);
+		if (ret)
+			goto err_shutdown;
+
+		// wait until QDAI starts succeeding (then the modem is ready
+		// to accept the following QCFGs)
+		ret = mpwr_serdev_at_cmd_with_retry(mpwr, "AT+QDAI?", 1000, 15);
+		if (ret)
+			goto err_shutdown;
+	}
+
+        /* check and update important QCFGs */
+        for (i = 0; i < ARRAY_SIZE(mpwr_eg25_qcfgs); i++) {
+                const char* name = mpwr_eg25_qcfgs[i].name;
+                const char* needed_val = mpwr_eg25_qcfgs[i].val;
+		bool (*is_ok)(const char* val) = mpwr_eg25_qcfgs[i].is_ok;
+		const char *val;
+                char buf[128];
+
+                snprintf(buf, sizeof buf, "AT+QCFG=\"%s\"", name);
+                ret = mpwr_serdev_at_cmd(mpwr, buf, 1000);
+                if (ret)
+			continue;
+
+                snprintf(buf, sizeof buf, "+QCFG: \"%s\",", name);
+		val = mpwr_serdev_get_response_value(mpwr, buf);
+		if (val) {
+			if (needed_val && (is_ok ? !is_ok(val) : strcmp(needed_val, val))) {
+				dev_info(mpwr->dev, "QCFG '%s' is '%s' (changing to '%s')\n", name, val, needed_val);
+
+				/* update qcfg */
+				snprintf(buf, sizeof buf, "AT+QCFG=\"%s\",%s", name, needed_val);
+				ret = mpwr_serdev_at_cmd(mpwr, buf, 1000);
+				if (ret)
+					break; /* go to next QCFG */
+			} else {
+				dev_info(mpwr->dev, "QCFG '%s' is '%s'\n", name, val);
+			}
+		}
+        }
+
+	/* setup URC port */
+	ret = mpwr_serdev_at_cmd(mpwr, "AT+QURCCFG=\"urcport\",\"all\"", 2000);
+        if (ret) {
+		dev_info(mpwr->dev, "Your modem doesn't support AT+QURCCFG=\"urcport\",\"all\", consider upgrading the firmware.\n");
+
+		ret = mpwr_serdev_at_cmd(mpwr, "AT+QURCCFG=\"urcport\",\"usbat\"", 2000);
+		if (ret)
+			dev_err(mpwr->dev, "Modem may not report URCs to the right port!\n");
+	}
+
+	/* enable the modem to go to sleep when DTR is low */
+	ret = mpwr_serdev_at_cmd(mpwr, "AT+QSCLK=1", 2000);
+        if (ret)
+		dev_err(mpwr->dev, "Modem will probably not sleep!\n");
+
+powered_up:
+	// if we're signaling some alternate boot mode via GPIO, we need to
+	// sleep here so that modem's boot script notices the gpio
+	if (mode == MPWR_MODE_ALT1 || mode == MPWR_MODE_FASTBOOT || mode == MPWR_MODE_ALT2)
+		msleep(12000);
+
+	gpiod_direction_output(mpwr->dtr_gpio, 1);
+
+	return 0;
+
+err_shutdown:
+	serdev_device_close(mpwr->serdev);
+err_shutdown_noclose:
+	dev_warn(mpwr->dev,
+		 "Forcibly cutting off power, data loss may occur.\n");
+	gpiod_direction_input(mpwr->enable_gpio);
+	gpiod_direction_input(mpwr->reset_gpio);
+	gpiod_direction_input(mpwr->sleep_gpio);
+	gpiod_direction_input(pwrkey_gpio);
+	gpiod_direction_input(mpwr->host_ready_gpio);
+	gpiod_direction_input(mpwr->dtr_gpio);
+
+	regulator_disable(mpwr->regulator);
+	return -ENODEV;
+}
+
+static int mpwr_eg25_power_down_finish(struct mpwr_dev* mpwr)
+{
+	struct gpio_desc *pwrkey_gpio = mpwr_eg25_get_pwrkey_gpio(mpwr);
+	ktime_t start = ktime_get();
+	int ret;
+
+	serdev_device_close(mpwr->serdev);
+
+	/*
+	 * This function is called right after POWERED DOWN message is received.
+	 *
+	 * In case of fast/poweroff == 1, no POWERED DOWN message is sent.
+	 * Fast power off times are around 1s since the end of 800ms
+	 * POK pulse.
+	 *
+	 * When the modem powers down RI (wakeup) goes low and STATUS goes
+	 * high at the same time. Status is not connected on some boards.
+	 * RI should be inactive during poweroff, but we don't know for sure.
+	 *
+	 * Therfore:
+	 * - wait for STATUS going low
+	 * - in case that's not available wait for RI going low
+	 * - in case timings seem off, warn the user
+	 *
+	 * In addition, some boards have PWRKEY multiplexed with STATUS signal.
+	 * In that case we need to switch STATUS to output high level, as soon
+	 * as it goes low in order to prevent a power-up signal being registered
+	 * by the modem.
+	 */
+
+	if (mpwr->status_gpio) {
+		/* wait up to 30s for status going high */
+		while (ktime_ms_delta(ktime_get(), start) < 30000) {
+			if (gpiod_get_value(mpwr->status_gpio)) {
+				if (ktime_ms_delta(ktime_get(), start) < 500)
+					dev_warn(mpwr->dev,
+						 "STATUS signal is high too soon during powerdown. Modem is already off?\n");
+				goto powerdown;
+			}
+
+			msleep(20);
+		}
+
+		dev_warn(mpwr->dev,
+			 "STATUS signal didn't go high during shutdown. Modem is still on?\n");
+		goto force_powerdown;
+	} else {
+		clear_bit(MPWR_F_GOT_WAKEUP, mpwr->flags);
+
+		if (!gpiod_get_value(mpwr->wakeup_gpio)) {
+			dev_warn(mpwr->dev,
+				 "RI signal is low too soon during powerdown. Modem is already off, or spurious wakeup?\n");
+			msleep(2000);
+			goto powerdown;
+		}
+
+		ret = wait_event_timeout(mpwr->wait,
+					 test_bit(MPWR_F_GOT_WAKEUP, mpwr->flags),
+					 msecs_to_jiffies(30000));
+		if (ret <= 0) {
+			dev_warn(mpwr->dev,
+				 "RI signal didn't go low during shutdown, is modem really powering down?\n");
+			goto force_powerdown;
+		}
+
+		if (ktime_ms_delta(ktime_get(), start) < 500) {
+			dev_warn(mpwr->dev,
+				 "RI signal is low too soon during powerdown. Modem is already off, or spurious wakeup?\n");
+			msleep(2000);
+			goto powerdown;
+		}
+	}
+
+powerdown:
+	gpiod_direction_input(mpwr->enable_gpio);
+	gpiod_direction_input(mpwr->reset_gpio);
+	gpiod_direction_input(mpwr->sleep_gpio);
+	gpiod_direction_input(pwrkey_gpio);
+	gpiod_direction_input(mpwr->host_ready_gpio);
+	gpiod_direction_input(mpwr->dtr_gpio);
+
+	regulator_disable(mpwr->regulator);
+
+	return 0;
+
+force_powerdown:
+	dev_warn(mpwr->dev,
+		 "Forcibly cutting off power, data loss may occur.\n");
+	goto powerdown;
+}
+
+static int mpwr_eg25_power_down(struct mpwr_dev* mpwr)
+{
+	struct gpio_desc *pwrkey_gpio = mpwr_eg25_get_pwrkey_gpio(mpwr);
+	//int ret;
+
+	/* Send 800ms pwrkey pulse to initiate powerdown. */
+	gpiod_direction_output(pwrkey_gpio, 1);
+	msleep(800);
+	gpiod_set_value(pwrkey_gpio, 0);
+
+	/* Switch status key to input, in case it's multiplexed with pwrkey. */
+	gpiod_direction_input(mpwr->status_gpio);
+
+	msleep(20);
+
+#if 0
+	// wait for POWERED DOWN message
+	clear_bit(MPWR_F_GOT_PDN, mpwr->flags);
+	ret = wait_event_timeout(mpwr->wait,
+				 test_bit(MPWR_F_GOT_PDN, mpwr->flags),
+				 msecs_to_jiffies(7000));
+	if (ret <= 0)
+		dev_warn(mpwr->dev,
+			 "POWERED DOWN message not received, is modem really powering down?\n");
+#endif
+
+	return mpwr_eg25_power_down_finish(mpwr);
+}
+
+static void mpwr_finish_pdn_work(struct work_struct *work)
+{
+	/*
+	struct mpwr_dev *mpwr = container_of(work, struct mpwr_dev, power_work);
+	unsigned long flags;
+
+	spin_lock_irqsave(&mpwr->lock, flags);
+	spin_unlock_irqrestore(&mpwr->lock, flags);
+
+	pm_stay_awake(mpwr->dev);
+
+	mutex_lock(&mpwr->modem_lock);
+
+	mutex_unlock(&mpwr->modem_lock);
+
+	pm_relax(mpwr->dev);
+	*/
+}
+
+static void mpwr_eg25_receive_msg(struct mpwr_dev *mpwr, const char *msg)
+{
+	unsigned int msg_len;
+
+	if (!strcmp(msg, "POWERED DOWN")) {
+		// system is powering down
+                set_bit(MPWR_F_GOT_PDN, mpwr->flags);
+		wake_up(&mpwr->wait);
+
+		/*
+		if (mutex_trylock(&mpwr->modem_lock)) {
+			// if no power op is in progress, this means userspace
+			// tried to shut the modem down via AT command, finish up
+			// the job
+
+			pm_stay_awake(mpwr->dev);
+
+			queue_work(mpwr->wq, &mpwr->power_work);
+			dev_warn(mpwr->dev, "userspace shut down the modem via AT command, finishing the job\n");
+			mpwr_eg25_power_down_finish(mpwr);
+			mutex_unlock(&mpwr->modem_lock);
+
+			pm_relax(mpwr->dev);
+		}
+                  */
+                return;
+	}
+
+	if (!strcmp(msg, "RDY")) {
+		// system is ready after powerup
+                return;
+	}
+
+	if (!test_bit(MPWR_F_OPEN, mpwr->flags))
+		return;
+
+	msg_len = strlen(msg);
+
+	if (msg_len + 1 > kfifo_avail(&mpwr->kfifo)) {
+		if (!test_and_set_bit(MPWR_F_OVERFLOW, mpwr->flags))
+			wake_up(&mpwr->wait);
+		return;
+	}
+
+	kfifo_in(&mpwr->kfifo, msg, msg_len);
+	kfifo_in(&mpwr->kfifo, "\n", 1);
+	wake_up(&mpwr->wait);
+}
+
+static void mpwr_host_ready_work(struct work_struct *work)
+{
+        struct mpwr_dev *mpwr = container_of(work, struct mpwr_dev, host_ready_work.work);
+	int ret;
+
+	mutex_lock(&mpwr->modem_lock);
+	gpiod_direction_output(mpwr->dtr_gpio, 0);
+
+	/*
+	 * We need to give the modem some time to wake up.
+	 */
+	msleep(5);
+
+	ret = mpwr_serdev_at_cmd(mpwr, "AT+QCFG=\"urc/cache\",0", 500);
+	if (ret)
+		dev_warn(mpwr->dev,
+			 "Failed to disable urc/cache, you may not be able to see URCs\n");
+
+	gpiod_direction_output(mpwr->dtr_gpio, 1);
+	mutex_unlock(&mpwr->modem_lock);
+
+	gpiod_direction_output(mpwr->host_ready_gpio, 1);
+}
+
+static int mpwr_eg25_suspend(struct mpwr_dev *mpwr)
+{
+	int ret;
+
+	cancel_delayed_work_sync(&mpwr->host_ready_work);
+
+	gpiod_direction_output(mpwr->host_ready_gpio, 0);
+
+	mutex_lock(&mpwr->modem_lock);
+	gpiod_direction_output(mpwr->dtr_gpio, 0);
+
+	msleep(5);
+
+	ret = mpwr_serdev_at_cmd(mpwr, "AT+QCFG=\"urc/cache\",1", 500);
+	if (ret)
+		dev_warn(mpwr->dev,
+			 "Failed to enable urc/cache, you may lose URCs during suspend\n");
+
+	gpiod_direction_output(mpwr->dtr_gpio, 1);
+	mutex_unlock(&mpwr->modem_lock);
+
+	return 0;
+}
+
+static int mpwr_eg25_resume(struct mpwr_dev *mpwr)
+{
+	//gpiod_direction_output(mpwr->dtr_gpio, 0);
+
+	// delay disabling URC cache until the whole system is hopefully resumed...
+	schedule_delayed_work(&mpwr->host_ready_work, msecs_to_jiffies(1000));
+
+	return 0;
+}
+
+static const struct mpwr_gpio mpwr_eg25_gpios[] = {
+	MPWR_GPIO_DEF(enable, GPIOD_OUT_HIGH, true),
+	MPWR_GPIO_DEF(reset, GPIOD_OUT_LOW, true),
+	MPWR_GPIO_DEF(pwrkey, GPIOD_OUT_LOW, false),
+	MPWR_GPIO_DEF(dtr, GPIOD_OUT_LOW, true),
+	MPWR_GPIO_DEF(status, GPIOD_IN, false),
+	MPWR_GPIO_DEF_IRQ(wakeup, GPIOD_IN, true,
+			  IRQF_TRIGGER_FALLING),
+
+	// XXX: not really needed...
+	MPWR_GPIO_DEF(sleep, GPIOD_OUT_LOW, false),
+	MPWR_GPIO_DEF(host_ready, GPIOD_OUT_HIGH, false),
+	MPWR_GPIO_DEF(cts, GPIOD_IN, false),
+	MPWR_GPIO_DEF(rts, GPIOD_OUT_LOW, false),
+	{ },
+};
+
+static const struct mpwr_variant mpwr_eg25_variant = {
+	.power_up = mpwr_eg25_power_up,
+	.power_down = mpwr_eg25_power_down,
+	.recv_msg = mpwr_eg25_receive_msg,
+	.suspend = mpwr_eg25_suspend,
+	.resume = mpwr_eg25_resume,
+	.gpios = mpwr_eg25_gpios,
+	.regulator_required = true,
+	.monitor_wakeup = true,
+};
+
+// }}}
+// {{{ generic helpers
+
+static void mpwr_reset(struct mpwr_dev* mpwr)
+{
+	struct device *dev = mpwr->dev;
+	int ret;
+
+	if (!test_bit(MPWR_F_POWERED, mpwr->flags)) {
+		dev_err(dev, "reset requested but device is not enabled");
+		return;
+	}
+
+	if (!mpwr->reset_gpio) {
+		dev_err(dev, "reset is not configured for this device");
+		return;
+	}
+
+	if (!mpwr->variant->reset) {
+		dev_err(dev, "reset requested but not implemented");
+		return;
+	}
+
+	dev_info(dev, "resetting");
+	ret = mpwr->variant->reset(mpwr);
+	if (ret) {
+		dev_err(dev, "reset failed");
+	}
+}
+
+static void mpwr_power_down(struct mpwr_dev* mpwr)
+{
+	struct device *dev = mpwr->dev;
+	ktime_t start = ktime_get();
+	int ret;
+
+	if (!test_bit(MPWR_F_POWERED, mpwr->flags))
+		return;
+
+	if (!mpwr->variant->power_down) {
+		dev_err(dev, "power down requested but not implemented");
+		return;
+	}
+
+	dev_info(dev, "powering down");
+
+	ret = mpwr->variant->power_down(mpwr);
+	if (ret) {
+		dev_err(dev, "power down failed");
+	} else {
+		clear_bit(MPWR_F_POWERED, mpwr->flags);
+		sysfs_notify(&mpwr->dev->kobj, NULL, "powered");
+		dev_info(mpwr->dev, "powered down in %lld ms\n",
+			 ktime_ms_delta(ktime_get(), start));
+	}
+}
+
+static void mpwr_power_up(struct mpwr_dev* mpwr)
+{
+	struct device *dev = mpwr->dev;
+	ktime_t start = ktime_get();
+	int ret;
+
+	if (test_bit(MPWR_F_POWERED, mpwr->flags))
+		return;
+
+	if (!mpwr->variant->power_up) {
+		dev_err(dev, "power up requested but not implemented");
+		return;
+	}
+
+	dev_info(dev, "powering up");
+
+	ret = mpwr->variant->power_up(mpwr);
+	if (ret) {
+		dev_err(dev, "power up failed");
+	} else {
+		set_bit(MPWR_F_POWERED, mpwr->flags);
+		sysfs_notify(&mpwr->dev->kobj, NULL, "powered");
+		dev_info(mpwr->dev, "powered up in %lld ms\n",
+			 ktime_ms_delta(ktime_get(), start));
+	}
+}
+
+// }}}
+// {{{ chardev
+
+static int mpwr_release(struct inode *ip, struct file *fp)
+{
+	struct mpwr_dev* mpwr = fp->private_data;
+
+	clear_bit(MPWR_F_OPEN, mpwr->flags);
+
+	return 0;
+}
+
+static int mpwr_open(struct inode *ip, struct file *fp)
+{
+	struct mpwr_dev* mpwr = container_of(ip->i_cdev, struct mpwr_dev, cdev);
+
+	fp->private_data = mpwr;
+
+	if (test_and_set_bit(MPWR_F_OPEN, mpwr->flags))
+		return -EBUSY;
+
+	nonseekable_open(ip, fp);
+	return 0;
+}
+
+static ssize_t mpwr_read(struct file *fp, char __user *buf, size_t len,
+			 loff_t *off)
+{
+	struct mpwr_dev* mpwr = fp->private_data;
+	int non_blocking = fp->f_flags & O_NONBLOCK;
+	unsigned int copied;
+	int ret;
+
+	if (non_blocking && kfifo_is_empty(&mpwr->kfifo))
+		return -EWOULDBLOCK;
+
+	ret = wait_event_interruptible(mpwr->wait,
+				       !kfifo_is_empty(&mpwr->kfifo)
+				       || test_bit(MPWR_F_OVERFLOW, mpwr->flags));
+	if (ret)
+		return ret;
+
+	if (test_and_clear_bit(MPWR_F_OVERFLOW, mpwr->flags)) {
+		if (len < 9)
+			return -E2BIG;
+		if (copy_to_user(buf, "OVERFLOW\n", 9))
+			return -EFAULT;
+		return 9;
+	}
+
+	ret = kfifo_to_user(&mpwr->kfifo, buf, len, &copied);
+
+	return ret ? ret : copied;
+}
+
+static unsigned int mpwr_poll(struct file *fp, poll_table *wait)
+{
+	struct mpwr_dev* mpwr = fp->private_data;
+
+	poll_wait(fp, &mpwr->wait, wait);
+
+	if (!kfifo_is_empty(&mpwr->kfifo))
+		return EPOLLIN | EPOLLRDNORM;
+
+	return 0;
+}
+
+static const struct file_operations mpwr_fops = {
+	.owner		= THIS_MODULE,
+	.open		= mpwr_open,
+	.release	= mpwr_release,
+	.llseek		= noop_llseek,
+	.read		= mpwr_read,
+	.poll		= mpwr_poll,
+};
+
+// }}}
+
+static void mpwr_work_handler(struct work_struct *work)
+{
+	struct mpwr_dev *mpwr = container_of(work, struct mpwr_dev, power_work);
+	unsigned long flags;
+	int last_request;
+
+	spin_lock_irqsave(&mpwr->lock, flags);
+	last_request = mpwr->last_request;
+	mpwr->last_request = 0;
+	spin_unlock_irqrestore(&mpwr->lock, flags);
+
+	pm_stay_awake(mpwr->dev);
+
+	mutex_lock(&mpwr->modem_lock);
+
+	if (last_request == MPWR_REQ_RESET) {
+		mpwr_reset(mpwr);
+	} else if (last_request == MPWR_REQ_PWDN) {
+		mpwr_power_down(mpwr);
+	} else if (last_request == MPWR_REQ_PWUP) {
+		mpwr_power_up(mpwr);
+	}
+
+	mutex_unlock(&mpwr->modem_lock);
+
+	clear_bit(MPWR_F_POWER_CHANGE_INPROGRESS, mpwr->flags);
+	sysfs_notify(&mpwr->dev->kobj, NULL, "is_busy");
+	wake_up(&mpwr->wait);
+
+	pm_relax(mpwr->dev);
+}
+
+static void mpwr_request_power_change(struct mpwr_dev* mpwr, int request, int mode)
+{
+	unsigned long flags;
+
+	set_bit(MPWR_F_POWER_CHANGE_INPROGRESS, mpwr->flags);
+	sysfs_notify(&mpwr->dev->kobj, NULL, "is_busy");
+
+	spin_lock_irqsave(&mpwr->lock, flags);
+	mpwr->last_request = request;
+	if (mode >= 0)
+		mpwr->powerup_mode = mode;
+	spin_unlock_irqrestore(&mpwr->lock, flags);
+
+	queue_work(mpwr->wq, &mpwr->power_work);
+}
+
+static irqreturn_t mpwr_gpio_isr(int irq, void *dev_id)
+{
+	struct mpwr_dev *mpwr = dev_id;
+
+	if (irq == mpwr->wakeup_irq) {
+		dev_dbg(mpwr->dev, "wakeup irq\n");
+
+		if (device_can_wakeup(mpwr->dev))
+			pm_wakeup_event(mpwr->dev, 2000);
+
+		set_bit(MPWR_F_GOT_WAKEUP, mpwr->flags);
+		spin_lock(&mpwr->lock);
+		mpwr->last_wakeup = ktime_get();
+		spin_unlock(&mpwr->lock);
+		wake_up(&mpwr->wait);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static void mpwr_wd_timer_fn(struct timer_list *t)
+{
+	struct mpwr_dev *mpwr = from_timer(mpwr, t, wd_timer);
+
+	if (!mpwr->variant->monitor_wakeup || !test_bit(MPWR_F_POWERED, mpwr->flags))
+		return;
+
+	/*
+	 * Monitor wakeup status:
+	 *
+	 * If RI signal is low for too long we assume the user killswitched
+	 * the modem at runtime.
+	 */
+	spin_lock(&mpwr->lock);
+	if (!gpiod_get_value(mpwr->wakeup_gpio)) {
+		if (ktime_ms_delta(ktime_get(), mpwr->last_wakeup) > 5000) {
+			if (!test_and_set_bit(MPWR_F_KILLSWITCHED, mpwr->flags))
+				sysfs_notify(&mpwr->dev->kobj, NULL, "killswitched");
+			wake_up(&mpwr->wait);
+			dev_warn(mpwr->dev, "modem looks killswitched at runtime!\n");
+		}
+	}
+	spin_unlock(&mpwr->lock);
+
+	mod_timer(t, jiffies + msecs_to_jiffies(1000));
+}
+
+// {{{ sysfs
+
+static ssize_t powered_show(struct device *dev,
+			    struct device_attribute *attr, char *buf)
+{
+	struct mpwr_dev *mpwr = platform_get_drvdata(to_platform_device(dev));
+
+	return scnprintf(buf, PAGE_SIZE, "%u\n",
+			 !!test_bit(MPWR_F_POWERED, mpwr->flags));
+}
+
+static ssize_t powered_store(struct device *dev,
+			     struct device_attribute *attr,
+			     const char *buf, size_t len)
+{
+	struct mpwr_dev *mpwr = platform_get_drvdata(to_platform_device(dev));
+	unsigned status;
+	int ret;
+
+	if (test_bit(MPWR_F_BLOCKED, mpwr->flags))
+		return -EPERM;
+
+	ret = kstrtouint(buf, 10, &status);
+	if (ret)
+		return ret;
+
+	mpwr_request_power_change(mpwr, status ? MPWR_REQ_PWUP : MPWR_REQ_PWDN, status);
+
+	return len;
+}
+
+static ssize_t powered_blocking_store(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf, size_t len)
+{
+	struct mpwr_dev *mpwr = platform_get_drvdata(to_platform_device(dev));
+	unsigned status;
+	int ret;
+
+	if (test_bit(MPWR_F_BLOCKED, mpwr->flags))
+		return -EPERM;
+
+	ret = kstrtouint(buf, 10, &status);
+	if (ret)
+		return ret;
+
+	mpwr_request_power_change(mpwr, status ? MPWR_REQ_PWUP : MPWR_REQ_PWDN, status);
+
+	ret = wait_event_interruptible_timeout(mpwr->wait,
+					       !test_bit(MPWR_F_POWER_CHANGE_INPROGRESS, mpwr->flags),
+					       msecs_to_jiffies(60000));
+	if (ret <= 0) {
+		dev_err(mpwr->dev, "Power state change timeout\n");
+		return -EIO;
+	}
+
+	if (!!status != !!test_bit(MPWR_F_POWERED, mpwr->flags))
+		return -EIO;
+
+	return len;
+}
+
+static ssize_t help_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return scnprintf(buf, PAGE_SIZE,
+			"echo N > powered, where N can be:\n"
+			"0: power off\n"
+			"1: normal powerup\n"
+			"2: dumb powerup (no AT commands and little error checking during powerup)\n"
+			"3: fastboot powerup (with biktor's patched aboot - #W_DISABLE held low during powerup)\n"
+			"4: alternate powerup (megi's userspace - DTR held high during powerup)\n\n"
+			"echo N > powered_blocking can be used for the write to block until power status transition completes\n");
+}
+
+static ssize_t killswitched_show(struct device *dev,
+				 struct device_attribute *attr, char *buf)
+{
+	struct mpwr_dev *mpwr = platform_get_drvdata(to_platform_device(dev));
+
+	return scnprintf(buf, PAGE_SIZE, "%u\n",
+			 !!test_bit(MPWR_F_KILLSWITCHED, mpwr->flags));
+}
+
+static ssize_t is_busy_show(struct device *dev,
+			    struct device_attribute *attr, char *buf)
+{
+	struct mpwr_dev *mpwr = platform_get_drvdata(to_platform_device(dev));
+
+	return scnprintf(buf, PAGE_SIZE, "%u\n",
+			 !!test_bit(MPWR_F_POWER_CHANGE_INPROGRESS, mpwr->flags));
+}
+
+static ssize_t hard_reset_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t len)
+{
+	struct mpwr_dev *mpwr = platform_get_drvdata(to_platform_device(dev));
+	bool val;
+	int ret;
+
+	if (test_bit(MPWR_F_BLOCKED, mpwr->flags))
+		return -EPERM;
+
+	ret = kstrtobool(buf, &val);
+	if (ret)
+		return ret;
+	if (val)
+		mpwr_request_power_change(mpwr, MPWR_REQ_RESET, -1);
+
+	return len;
+}
+
+static ssize_t debug_pins_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t len)
+{
+	struct mpwr_dev *mpwr = platform_get_drvdata(to_platform_device(dev));
+	unsigned val;
+	int ret;
+
+	if (test_bit(MPWR_F_BLOCKED, mpwr->flags))
+		return -EPERM;
+
+	ret = kstrtouint(buf, 16, &val);
+	if (ret)
+		return ret;
+
+	gpiod_direction_output(mpwr->host_ready_gpio, val & BIT(0));
+	gpiod_direction_output(mpwr->enable_gpio, val & BIT(1));
+	gpiod_direction_output(mpwr->dtr_gpio, val & BIT(2));
+	gpiod_direction_output(mpwr->rts_gpio, val & BIT(3));
+
+	return len;
+}
+
+static ssize_t debug_pins_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct mpwr_dev *mpwr = platform_get_drvdata(to_platform_device(dev));
+
+	return scnprintf(buf, PAGE_SIZE, "CTS=%u RI=%u\n",
+			 gpiod_get_value(mpwr->cts_gpio), gpiod_get_value(mpwr->wakeup_gpio));
+}
+
+static DEVICE_ATTR_RW(powered);
+static DEVICE_ATTR_WO(powered_blocking);
+static DEVICE_ATTR_RO(killswitched);
+static DEVICE_ATTR_RO(is_busy);
+static DEVICE_ATTR_RO(help);
+static DEVICE_ATTR_WO(hard_reset);
+static DEVICE_ATTR_RW(debug_pins);
+
+static struct attribute *mpwr_attrs[] = {
+	&dev_attr_powered.attr,
+	&dev_attr_powered_blocking.attr,
+	&dev_attr_killswitched.attr,
+	&dev_attr_is_busy.attr,
+	&dev_attr_help.attr,
+	&dev_attr_hard_reset.attr,
+	&dev_attr_debug_pins.attr,
+	NULL,
+};
+
+static const struct attribute_group mpwr_group = {
+	.attrs = mpwr_attrs,
+};
+
+// }}}
+// {{{ rfkill
+
+static int mpwr_rfkill_set(void *data, bool blocked)
+{
+	struct mpwr_dev *mpwr = data;
+
+	gpiod_set_value(mpwr->enable_gpio, !blocked);
+	return 0;
+}
+
+static void mpwr_rfkill_query(struct rfkill *rfkill, void *data)
+{
+	struct mpwr_dev *mpwr = data;
+
+	rfkill_set_sw_state(rfkill, !gpiod_get_value(mpwr->enable_gpio));
+}
+
+static const struct rfkill_ops mpwr_rfkill_ops = {
+	.set_block = mpwr_rfkill_set,
+	.query = mpwr_rfkill_query,
+};
+
+// }}}
+// {{{ probe
+
+static int mpwr_probe_generic(struct device *dev, struct mpwr_dev **mpwr_out)
+{
+	struct mpwr_dev *mpwr;
+	struct device_node *np = dev->of_node;
+	struct device *sdev;
+	const char* cdev_name = NULL;
+	int ret, i;
+
+	mpwr = devm_kzalloc(dev, sizeof(*mpwr), GFP_KERNEL);
+	if (!mpwr)
+		return -ENOMEM;
+
+	mpwr->variant = of_device_get_match_data(dev);
+	if (!mpwr->variant)
+		return -EINVAL;
+
+	mpwr->dev = dev;
+	init_waitqueue_head(&mpwr->wait);
+        mutex_init(&mpwr->modem_lock);
+        spin_lock_init(&mpwr->lock);
+	INIT_WORK(&mpwr->power_work, &mpwr_work_handler);
+	INIT_WORK(&mpwr->finish_pdn_work, &mpwr_finish_pdn_work);
+        INIT_DELAYED_WORK(&mpwr->host_ready_work, mpwr_host_ready_work);
+	INIT_KFIFO(mpwr->kfifo);
+
+	ret = of_property_read_string(np, "char-device-name", &cdev_name);
+	if (ret) {
+		dev_err(dev, "char-device-name is not configured");
+		return -EINVAL;
+	}
+
+	if (of_property_read_bool(np, "blocked"))
+		set_bit(MPWR_F_BLOCKED, mpwr->flags);
+
+	mpwr->status_pwrkey_multiplexed =
+		of_property_read_bool(np, "status-pwrkey-multiplexed");
+
+	mpwr->regulator = devm_regulator_get_optional(dev, "power");
+	if (IS_ERR(mpwr->regulator)) {
+		ret = PTR_ERR(mpwr->regulator);
+                if (ret != -ENODEV) {
+			dev_err(dev, "can't get power supply err=%d", ret);
+			return ret;
+		}
+
+		mpwr->regulator = NULL;
+	}
+
+	if (!mpwr->regulator && mpwr->variant->regulator_required) {
+		dev_err(dev, "can't get power supply err=%d", -ENODEV);
+		return -ENODEV;
+	}
+
+	for (i = 0; mpwr->variant->gpios[i].name; i++) {
+		const struct mpwr_gpio *io = &mpwr->variant->gpios[i];
+		struct gpio_desc **desc = (struct gpio_desc **)((u8*)mpwr +
+								io->desc_off);
+		int *irq = (int*)((u8*)mpwr + io->irq_off);
+		char buf[64];
+
+		if (io->required)
+			*desc = devm_gpiod_get(dev, io->name, io->flags);
+		else
+			*desc = devm_gpiod_get_optional(dev, io->name, io->flags);
+
+		if (IS_ERR(*desc)) {
+			dev_err(dev, "can't get %s gpio err=%ld", io->name,
+				PTR_ERR(*desc));
+			return PTR_ERR(*desc);
+		}
+
+		if (!*desc)
+			continue;
+
+		if (io->irq_flags == 0 || io->irq_off == 0)
+			continue;
+
+		*irq = gpiod_to_irq(*desc);
+		if (*irq <= 0) {
+			dev_err(dev, "error converting %s gpio to irq: %d",
+				io->name, ret);
+			return *irq;
+		}
+
+		snprintf(buf, sizeof buf, "modem-%s-gpio", io->name);
+		ret = devm_request_irq(dev, *irq, mpwr_gpio_isr, io->irq_flags,
+				       devm_kstrdup(dev, buf, GFP_KERNEL), mpwr);
+		if (ret) {
+			dev_err(dev, "error requesting %s irq: %d",
+				io->name, ret);
+			return ret;
+		}
+	}
+
+	if (mpwr->status_pwrkey_multiplexed && mpwr->pwrkey_gpio) {
+		dev_err(dev, "status and pwrkey are multiplexed, but pwrkey defined\n");
+		return -EINVAL;
+	}
+
+	if (mpwr->status_pwrkey_multiplexed && !mpwr->status_gpio) {
+		dev_err(dev, "status and pwrkey are multiplexed, but status is not defined\n");
+		return -EINVAL;
+	}
+
+	ret = devm_device_add_group(dev, &mpwr_group);
+	if (ret)
+		return ret;
+
+	// create char device
+	ret = alloc_chrdev_region(&mpwr->major, 0, 1, "modem-power");
+	if (ret) {
+		dev_err(dev, "can't allocate chrdev region");
+		goto err_disable_regulator;
+	}
+
+	cdev_init(&mpwr->cdev, &mpwr_fops);
+	mpwr->cdev.owner = THIS_MODULE;
+	ret = cdev_add(&mpwr->cdev, mpwr->major, 1);
+	if (ret) {
+		dev_err(dev, "can't add cdev");
+		goto err_unreg_chrev_region;
+	}
+
+	sdev = device_create(mpwr_class, dev, mpwr->major, mpwr, cdev_name);
+	if (IS_ERR(sdev)) {
+		ret = PTR_ERR(sdev);
+		goto err_del_cdev;
+	}
+
+	if (mpwr->wakeup_irq > 0) {
+		ret = device_init_wakeup(dev, true);
+		if (ret) {
+			dev_err(dev, "failed to init wakeup (%d)\n", ret);
+			goto err_free_dev;
+		}
+	}
+
+	if (mpwr->enable_gpio) {
+		mpwr->rfkill = rfkill_alloc("modem", dev, RFKILL_TYPE_WWAN,
+					    &mpwr_rfkill_ops, mpwr);
+		if (!mpwr->rfkill) {
+			dev_err(dev, "failed to alloc rfkill\n");
+			ret = -ENOMEM;
+			goto err_deinit_wakeup;
+		}
+
+                rfkill_init_sw_state(mpwr->rfkill, false);
+
+		ret = rfkill_register(mpwr->rfkill);
+		if (ret) {
+			dev_err(dev, "failed to register rfkill (%d)\n", ret);
+			goto err_free_rfkill;
+		}
+	}
+
+	mpwr->wq = alloc_ordered_workqueue("modem-power", 0);
+	if (!mpwr->wq) {
+		ret = -ENOMEM;
+		dev_err(dev, "failed to allocate workqueue\n");
+		goto err_unreg_rfkill;
+	}
+
+	if (mpwr->variant->power_init)
+		mpwr->variant->power_init(mpwr);
+
+	timer_setup(&mpwr->wd_timer, mpwr_wd_timer_fn, 0);
+	mod_timer(&mpwr->wd_timer, jiffies + msecs_to_jiffies(50));
+
+	dev_info(dev, "modem power manager ready");
+	*mpwr_out = mpwr;
+
+	return 0;
+
+err_unreg_rfkill:
+	if (mpwr->rfkill)
+		rfkill_unregister(mpwr->rfkill);
+err_free_rfkill:
+	if (mpwr->rfkill)
+		rfkill_destroy(mpwr->rfkill);
+err_deinit_wakeup:
+	if (mpwr->wakeup_irq > 0)
+		device_init_wakeup(dev, false);
+err_free_dev:
+	device_destroy(mpwr_class, mpwr->major);
+err_del_cdev:
+	cdev_del(&mpwr->cdev);
+err_unreg_chrev_region:
+	unregister_chrdev(mpwr->major, "modem-power");
+err_disable_regulator:
+	cancel_work_sync(&mpwr->power_work);
+	return ret;
+}
+
+static int mpwr_remove_generic(struct mpwr_dev *mpwr)
+{
+	if (mpwr->rfkill) {
+		rfkill_unregister(mpwr->rfkill);
+		rfkill_destroy(mpwr->rfkill);
+	}
+
+	if (mpwr->wakeup_irq > 0)
+		device_init_wakeup(mpwr->dev, false);
+
+	del_timer_sync(&mpwr->wd_timer);
+        cancel_delayed_work_sync(&mpwr->host_ready_work);
+
+	cancel_work_sync(&mpwr->power_work);
+	destroy_workqueue(mpwr->wq);
+
+	mutex_lock(&mpwr->modem_lock);
+	mpwr_power_down(mpwr);
+	mutex_unlock(&mpwr->modem_lock);
+
+	device_destroy(mpwr_class, mpwr->major);
+	cdev_del(&mpwr->cdev);
+	unregister_chrdev(mpwr->major, "modem-power");
+
+	return 0;
+}
+
+static void mpwr_shutdown_generic(struct mpwr_dev *mpwr)
+{
+	cancel_work_sync(&mpwr->power_work);
+        cancel_delayed_work_sync(&mpwr->host_ready_work);
+
+	mutex_lock(&mpwr->modem_lock);
+	mpwr_power_down(mpwr);
+	mutex_unlock(&mpwr->modem_lock);
+}
+
+// }}}
+// {{{ suspend/resume
+
+static int __maybe_unused mpwr_suspend(struct device *dev)
+{
+	struct mpwr_dev *mpwr = dev_get_drvdata(dev);
+	int ret = 0;
+
+	if (!test_bit(MPWR_F_POWERED, mpwr->flags))
+		return 0;
+
+	//if (mpwr->sleep_gpio)
+		//gpiod_direction_output(mpwr->sleep_gpio, 1);
+
+	if (mpwr->variant->suspend)
+		mpwr->variant->suspend(mpwr);
+
+	if (mpwr->wakeup_irq && device_may_wakeup(mpwr->dev))
+		enable_irq_wake(mpwr->wakeup_irq);
+
+	return ret;
+}
+
+static int __maybe_unused mpwr_resume(struct device *dev)
+{
+	struct mpwr_dev *mpwr = dev_get_drvdata(dev);
+	int ret = 0;
+
+	if (!test_bit(MPWR_F_POWERED, mpwr->flags))
+		return 0;
+
+	//if (mpwr->sleep_gpio)
+		//gpiod_direction_output(mpwr->sleep_gpio, 0);
+
+	if (mpwr->variant->resume)
+		mpwr->variant->resume(mpwr);
+
+	if (mpwr->wakeup_irq && device_may_wakeup(mpwr->dev))
+		disable_irq_wake(mpwr->wakeup_irq);
+
+	return ret;
+}
+
+static const struct dev_pm_ops mpwr_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(mpwr_suspend, mpwr_resume)
+};
+
+// }}}
+// {{{ serdev
+
+static int mpwr_serdev_send_msg(struct mpwr_dev *mpwr, const char *msg)
+{
+	int ret, len;
+	char buf[128];
+
+	if (!mpwr->serdev)
+		return -ENODEV;
+
+	len = snprintf(buf, sizeof buf, "%s\r\n", msg);
+	if (len >= sizeof buf)
+		return -E2BIG;
+
+	ret = serdev_device_write(mpwr->serdev, buf, len, msecs_to_jiffies(3000));
+	if (ret < len)
+		return -EIO;
+
+	serdev_device_wait_until_sent(mpwr->serdev, msecs_to_jiffies(3000));
+
+	return 0;
+}
+
+static int __mpwr_serdev_at_cmd(struct mpwr_dev *mpwr, const char *msg,
+				int timeout_ms, bool report_error, bool report_timeout)
+{
+        int ret;
+
+        if (test_and_set_bit(MPWR_F_RECEIVING_MSG, mpwr->flags))
+		return -EBUSY;
+
+	mpwr->msg_len = 0;
+
+	dev_dbg(mpwr->dev, "SEND: %s\n", msg);
+
+	ret = mpwr_serdev_send_msg(mpwr, msg);
+        if (ret) {
+		clear_bit(MPWR_F_RECEIVING_MSG, mpwr->flags);
+		dev_err(mpwr->dev, "AT command '%s' can't be sent (%d)\n", msg, ret);
+                return ret;
+        }
+
+	ret = wait_event_interruptible_timeout(mpwr->wait,
+					       !test_bit(MPWR_F_RECEIVING_MSG, mpwr->flags),
+					       msecs_to_jiffies(timeout_ms));
+	if (ret <= 0) {
+		clear_bit(MPWR_F_RECEIVING_MSG, mpwr->flags);
+		if (report_timeout)
+			dev_err(mpwr->dev, "AT command '%s' timed out\n", msg);
+                return ret ? ret : -ETIMEDOUT;
+	}
+
+        if (!mpwr->msg_ok) {
+		if (report_error)
+			dev_err(mpwr->dev, "AT command '%s' returned ERROR\n", msg);
+                return -EINVAL;
+	}
+
+        return 0;
+}
+
+static int mpwr_serdev_at_cmd(struct mpwr_dev *mpwr, const char *msg, int timeout_ms)
+{
+	return __mpwr_serdev_at_cmd(mpwr, msg, timeout_ms, true, true);
+}
+
+static int __mpwr_serdev_at_cmd_with_retry(struct mpwr_dev *mpwr, const char *msg,
+					   int timeout_ms, int tries, bool ignore_timeout)
+{
+	int ret = 0;
+
+	if (tries < 1)
+		tries = 1;
+
+	while (tries-- > 0) {
+		ret = __mpwr_serdev_at_cmd(mpwr, msg, timeout_ms, false, !ignore_timeout);
+		if (ret != -EINVAL && (!ignore_timeout || ret != -ETIMEDOUT))
+			return ret;
+
+		if (ret != -ETIMEDOUT)
+			msleep(1000);
+	}
+
+	dev_err(mpwr->dev, "AT command '%s' returned ERROR\n", msg);
+	return ret;
+}
+
+static int mpwr_serdev_at_cmd_with_retry(struct mpwr_dev *mpwr, const char *msg,
+					 int timeout_ms, int tries)
+{
+	return __mpwr_serdev_at_cmd_with_retry(mpwr, msg, timeout_ms, tries, false);
+}
+
+static int mpwr_serdev_at_cmd_with_retry_ignore_timeout(struct mpwr_dev *mpwr, const char *msg,
+							int timeout_ms, int tries)
+{
+	return __mpwr_serdev_at_cmd_with_retry(mpwr, msg, timeout_ms, tries, true);
+}
+
+static void mpwr_serdev_receive_msg(struct mpwr_dev *mpwr, const char *msg)
+{
+	dev_dbg(mpwr->dev, "RECV: %s\n", msg);
+
+	if (mpwr->variant->recv_msg)
+		mpwr->variant->recv_msg(mpwr, msg);
+
+        if (!test_bit(MPWR_F_RECEIVING_MSG, mpwr->flags))
+                return;
+
+	if (!strcmp(msg, "OK")) {
+                clear_bit(MPWR_F_RECEIVING_MSG, mpwr->flags);
+                mpwr->msg_ok = true;
+		wake_up(&mpwr->wait);
+                return;
+	} else if (!strcmp(msg, "ERROR")) {
+                clear_bit(MPWR_F_RECEIVING_MSG, mpwr->flags);
+                mpwr->msg_ok = false;
+		wake_up(&mpwr->wait);
+                return;
+	} else {
+                int len = strlen(msg);
+
+                if (mpwr->msg_len + len + 1 > sizeof(mpwr->msg)) {
+                        dev_warn(mpwr->dev, "message buffer overflow, ignoring message\n");
+                        return;
+                }
+
+                memcpy(mpwr->msg + mpwr->msg_len, msg, len + 1);
+                mpwr->msg_len += len + 1;
+        }
+}
+
+static int mpwr_serdev_receive_buf(struct serdev_device *serdev,
+				   const unsigned char *buf, size_t count)
+{
+	struct mpwr_dev *mpwr = serdev_device_get_drvdata(serdev);
+	size_t avail = sizeof(mpwr->rcvbuf) - mpwr->rcvbuf_fill;
+	char* p;
+
+	if (avail < count)
+		count = avail;
+
+	if (avail > 0) {
+		memcpy(mpwr->rcvbuf + mpwr->rcvbuf_fill, buf, count);
+		mpwr->rcvbuf_fill += count;
+	}
+
+	while (true) {
+		p = strnstr(mpwr->rcvbuf, "\r\n", mpwr->rcvbuf_fill);
+		if (p) {
+			if (p > mpwr->rcvbuf) {
+				*p = 0;
+				mpwr_serdev_receive_msg(mpwr, mpwr->rcvbuf);
+			}
+
+			mpwr->rcvbuf_fill -= (p - mpwr->rcvbuf) + 2;
+			memmove(mpwr->rcvbuf, p + 2, mpwr->rcvbuf_fill);
+		} else {
+			if (sizeof(mpwr->rcvbuf) - mpwr->rcvbuf_fill == 0) {
+				mpwr->rcvbuf_fill = 0;
+				dev_warn(mpwr->dev, "rcvbuf overflow\n");
+			}
+
+			break;
+		}
+	}
+
+        return count;
+}
+
+static const struct serdev_device_ops mpwr_serdev_ops = {
+	.receive_buf = mpwr_serdev_receive_buf,
+	.write_wakeup = serdev_device_write_wakeup,
+};
+
+static int mpwr_serdev_probe(struct serdev_device *serdev)
+{
+	struct device *dev = &serdev->dev;
+        struct mpwr_dev* mpwr;
+        int ret;
+
+	ret = mpwr_probe_generic(dev, &mpwr);
+	if (ret)
+		return ret;
+
+	serdev_device_set_drvdata(serdev, mpwr);
+	serdev_device_set_client_ops(serdev, &mpwr_serdev_ops);
+	mpwr->serdev = serdev;
+
+        return 0;
+}
+
+static void mpwr_serdev_remove(struct serdev_device *serdev)
+{
+	struct mpwr_dev *mpwr = serdev_device_get_drvdata(serdev);
+
+	mpwr_remove_generic(mpwr);
+}
+
+static const struct of_device_id mpwr_of_match_serdev[] = {
+	{ .compatible = "quectel,eg25",
+	  .data = &mpwr_eg25_variant },
+	{},
+};
+MODULE_DEVICE_TABLE(of, mpwr_of_match_serdev);
+
+static void mpwr_serdev_shutdown(struct device *dev)
+{
+	struct mpwr_dev *mpwr = dev_get_drvdata(dev);
+
+	mpwr_shutdown_generic(mpwr);
+}
+
+static struct serdev_device_driver mpwr_serdev_driver = {
+        .probe  = mpwr_serdev_probe,
+        .remove = mpwr_serdev_remove,
+        .driver = {
+                .name = DRIVER_NAME,
+                .of_match_table = mpwr_of_match_serdev,
+		.pm = &mpwr_pm_ops,
+		.shutdown = mpwr_serdev_shutdown,
+        },
+};
+
+// }}}
+// {{{ platdev
+
+static int mpwr_pdev_probe(struct platform_device *pdev)
+{
+        struct mpwr_dev* mpwr;
+        int ret;
+
+	ret = mpwr_probe_generic(&pdev->dev, &mpwr);
+	if (ret)
+		return ret;
+
+	platform_set_drvdata(pdev, mpwr);
+        return 0;
+}
+
+static int mpwr_pdev_remove(struct platform_device *pdev)
+{
+	struct mpwr_dev *mpwr = platform_get_drvdata(pdev);
+
+	return mpwr_remove_generic(mpwr);
+}
+
+static void mpwr_pdev_shutdown(struct platform_device *pdev)
+{
+	struct mpwr_dev *mpwr = platform_get_drvdata(pdev);
+
+	mpwr_shutdown_generic(mpwr);
+}
+
+static const struct of_device_id mpwr_of_match_plat[] = {
+	{ .compatible = "zte,mg3732",
+	  .data = &mpwr_mg2723_variant },
+	{},
+};
+MODULE_DEVICE_TABLE(of, mpwr_of_match_plat);
+
+static struct platform_driver mpwr_platform_driver = {
+	.probe = mpwr_pdev_probe,
+	.remove = mpwr_pdev_remove,
+	.shutdown = mpwr_pdev_shutdown,
+	.driver = {
+		.name = DRIVER_NAME,
+		.of_match_table = mpwr_of_match_plat,
+		.pm = &mpwr_pm_ops,
+	},
+};
+
+// }}}
+// {{{ driver init
+
+static int __init mpwr_driver_init(void)
+{
+	int ret;
+
+	mpwr_class = class_create(THIS_MODULE, "modem-power");
+	if (IS_ERR(mpwr_class))
+		return PTR_ERR(mpwr_class);
+
+	ret = serdev_device_driver_register(&mpwr_serdev_driver);
+	if (ret)
+		goto err_class;
+
+	ret = platform_driver_register(&mpwr_platform_driver);
+	if (ret)
+		goto err_serdev;
+
+	return ret;
+
+err_serdev:
+	serdev_device_driver_unregister(&mpwr_serdev_driver);
+err_class:
+	class_destroy(mpwr_class);
+	return ret;
+}
+
+static void __exit mpwr_driver_exit(void)
+{
+	serdev_device_driver_unregister(&mpwr_serdev_driver);
+	platform_driver_unregister(&mpwr_platform_driver);
+	class_destroy(mpwr_class);
+}
+
+module_init(mpwr_driver_init);
+module_exit(mpwr_driver_exit);
+
+MODULE_DESCRIPTION("Modem power manager");
+MODULE_AUTHOR("Ondrej Jirman <megous@megous.com>");
+MODULE_LICENSE("GPL v2");
+
+// }}}
diff -Nuar -r --no-dereference linux-5.15.139/drivers/misc/sunxi-addr/Makefile linux/drivers/misc/sunxi-addr/Makefile
--- linux-5.15.139/drivers/misc/sunxi-addr/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ linux/drivers/misc/sunxi-addr/Makefile	2024-01-03 16:06:25.935131000 +0800
@@ -0,0 +1,5 @@
+#
+# Makefile for wifi mac addr manager drivers
+#
+sunxi_addr-objs := sunxi-addr.o sha256.o
+obj-$(CONFIG_SUNXI_ADDR_MGT)   += sunxi_addr.o
diff -Nuar -r --no-dereference linux-5.15.139/drivers/misc/sunxi-addr/Kconfig linux/drivers/misc/sunxi-addr/Kconfig
--- linux-5.15.139/drivers/misc/sunxi-addr/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ linux/drivers/misc/sunxi-addr/Kconfig	2024-01-03 16:06:25.935131000 +0800
@@ -0,0 +1,6 @@
+config SUNXI_ADDR_MGT
+  tristate "Allwinner Network MAC Addess Manager"
+  depends on BT || ETHERNET || WLAN
+  depends on NVMEM_SUNXI_SID
+  help
+    allwinner network mac address management
diff -Nuar -r --no-dereference linux-5.15.139/drivers/misc/sunxi-addr/sha256.c linux/drivers/misc/sunxi-addr/sha256.c
--- linux-5.15.139/drivers/misc/sunxi-addr/sha256.c	1970-01-01 08:00:00.000000000 +0800
+++ linux/drivers/misc/sunxi-addr/sha256.c	2024-01-03 16:06:25.935131000 +0800
@@ -0,0 +1,178 @@
+/*
+ * Local implement of sha256.
+ *
+ * Copyright (C) 2013 Allwinner.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+#include <linux/kernel.h>
+#include <linux/string.h>
+
+/****************************** MACROS ******************************/
+#define ROTRIGHT(a, b) (((a) >> (b)) | ((a) << (32 - (b))))
+#define CH(x, y, z)    (((x) & (y)) ^ (~(x) & (z)))
+#define MAJ(x, y, z)   (((x) & (y)) ^  ((x) & (z)) ^ ((y) & (z)))
+#define EP0(x)         (ROTRIGHT(x,  2) ^ ROTRIGHT(x, 13) ^ ROTRIGHT(x, 22))
+#define EP1(x)         (ROTRIGHT(x,  6) ^ ROTRIGHT(x, 11) ^ ROTRIGHT(x, 25))
+#define SIG0(x)        (ROTRIGHT(x,  7) ^ ROTRIGHT(x, 18) ^ ((x) >> 3))
+#define SIG1(x)        (ROTRIGHT(x, 17) ^ ROTRIGHT(x, 19) ^ ((x) >> 10))
+
+/**************************** VARIABLES *****************************/
+static const uint32_t k[64] = {
+	0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
+	0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
+	0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
+	0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
+	0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
+	0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
+	0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
+	0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
+	0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
+	0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
+	0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
+	0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
+	0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
+	0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
+	0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
+	0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
+};
+
+struct sha256_ctx {
+	uint8_t data[64];   /* current 512-bit chunk of message data, just like a buffer */
+	uint32_t datalen;   /* sign the data length of current chunk */
+	uint64_t bitlen;    /* the bit length of the total message */
+	uint32_t state[8];  /* store the middle state of hash abstract */
+};
+
+/*********************** FUNCTION DEFINITIONS ***********************/
+static void sha256_transform(struct sha256_ctx *ctx, const uint8_t *data)
+{
+	uint32_t a, b, c, d, e, f, g, h, i, j, t1, t2, m[64];
+
+	/* initialization */
+	for (i = 0, j = 0; i < 16; ++i, j += 4)
+		m[i] = (data[j] << 24) | (data[j + 1] << 16) |
+			(data[j + 2] << 8) | (data[j + 3]);
+	for ( ; i < 64; ++i)
+		m[i] = SIG1(m[i - 2]) + m[i - 7] + SIG0(m[i - 15]) + m[i - 16];
+
+	a = ctx->state[0];
+	b = ctx->state[1];
+	c = ctx->state[2];
+	d = ctx->state[3];
+	e = ctx->state[4];
+	f = ctx->state[5];
+	g = ctx->state[6];
+	h = ctx->state[7];
+
+	for (i = 0; i < 64; ++i) {
+		t1 = h + EP1(e) + CH(e, f, g) + k[i] + m[i];
+		t2 = EP0(a) + MAJ(a, b, c);
+		h = g;
+		g = f;
+		f = e;
+		e = d + t1;
+		d = c;
+		c = b;
+		b = a;
+		a = t1 + t2;
+	}
+
+	ctx->state[0] += a;
+	ctx->state[1] += b;
+	ctx->state[2] += c;
+	ctx->state[3] += d;
+	ctx->state[4] += e;
+	ctx->state[5] += f;
+	ctx->state[6] += g;
+	ctx->state[7] += h;
+}
+
+static void sha256_init(struct sha256_ctx *ctx)
+{
+	ctx->datalen = 0;
+	ctx->bitlen = 0;
+	ctx->state[0] = 0x6a09e667;
+	ctx->state[1] = 0xbb67ae85;
+	ctx->state[2] = 0x3c6ef372;
+	ctx->state[3] = 0xa54ff53a;
+	ctx->state[4] = 0x510e527f;
+	ctx->state[5] = 0x9b05688c;
+	ctx->state[6] = 0x1f83d9ab;
+	ctx->state[7] = 0x5be0cd19;
+}
+
+static void sha256_update(struct sha256_ctx *ctx, const uint8_t *data, size_t len)
+{
+	uint32_t i;
+
+	for (i = 0; i < len; ++i) {
+		ctx->data[ctx->datalen] = data[i];
+		ctx->datalen++;
+		if (ctx->datalen == 64) {
+			/* 64 byte = 512 bit  means the buffer ctx->data has
+			 * fully stored one chunk of message,
+			 * so do the sha256 hash map for the current chunk.
+			 */
+			sha256_transform(ctx, ctx->data);
+			ctx->bitlen += 512;
+			ctx->datalen = 0;
+		}
+	}
+}
+
+static void sha256_final(struct sha256_ctx *ctx, uint8_t *hash)
+{
+	uint32_t i;
+
+	i = ctx->datalen;
+
+	/* Pad whatever data is left in the buffer. */
+	if (ctx->datalen < 56) {
+		ctx->data[i++] = 0x80;  /* pad 10000000 = 0x80 */
+		while (i < 56)
+			ctx->data[i++] = 0x00;
+	} else {
+		ctx->data[i++] = 0x80;
+		while (i < 64)
+			ctx->data[i++] = 0x00;
+		sha256_transform(ctx, ctx->data);
+		memset(ctx->data, 0, 56);
+	}
+
+	/* Append to the padding the total message's length in bits and transform. */
+	ctx->bitlen += ctx->datalen * 8;
+	ctx->data[63] = ctx->bitlen;
+	ctx->data[62] = ctx->bitlen >> 8;
+	ctx->data[61] = ctx->bitlen >> 16;
+	ctx->data[60] = ctx->bitlen >> 24;
+	ctx->data[59] = ctx->bitlen >> 32;
+	ctx->data[58] = ctx->bitlen >> 40;
+	ctx->data[57] = ctx->bitlen >> 48;
+	ctx->data[56] = ctx->bitlen >> 56;
+	sha256_transform(ctx, ctx->data);
+
+	/* copying the final state to the output hash(use big endian). */
+	for (i = 0; i < 4; ++i) {
+		hash[i]      = (ctx->state[0] >> (24 - i * 8)) & 0x000000ff;
+		hash[i + 4]  = (ctx->state[1] >> (24 - i * 8)) & 0x000000ff;
+		hash[i + 8]  = (ctx->state[2] >> (24 - i * 8)) & 0x000000ff;
+		hash[i + 12] = (ctx->state[3] >> (24 - i * 8)) & 0x000000ff;
+		hash[i + 16] = (ctx->state[4] >> (24 - i * 8)) & 0x000000ff;
+		hash[i + 20] = (ctx->state[5] >> (24 - i * 8)) & 0x000000ff;
+		hash[i + 24] = (ctx->state[6] >> (24 - i * 8)) & 0x000000ff;
+		hash[i + 28] = (ctx->state[7] >> (24 - i * 8)) & 0x000000ff;
+	}
+}
+
+int hmac_sha256(const uint8_t *plaintext, ssize_t psize, uint8_t *output)
+{
+	struct sha256_ctx ctx;
+
+	sha256_init(&ctx);
+	sha256_update(&ctx, plaintext, psize);
+	sha256_final(&ctx, output);
+	return 0;
+}
diff -Nuar -r --no-dereference linux-5.15.139/drivers/misc/sunxi-addr/sunxi-addr.c linux/drivers/misc/sunxi-addr/sunxi-addr.c
--- linux-5.15.139/drivers/misc/sunxi-addr/sunxi-addr.c	1970-01-01 08:00:00.000000000 +0800
+++ linux/drivers/misc/sunxi-addr/sunxi-addr.c	2024-01-03 16:06:25.935131000 +0800
@@ -0,0 +1,358 @@
+/*
+ * The driver of SUNXI NET MAC ADDR Manager.
+ *
+ * Copyright (C) 2013 Allwinner.
+ *
+ * This file is licensed under the terms of the GNU General Public
+ * License version 2.  This program is licensed "as is" without any
+ * warranty of any kind, whether express or implied.
+ */
+#define DEBUG
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/miscdevice.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+
+#define ADDR_MGT_DBG(fmt, arg...) printk(KERN_DEBUG "[ADDR_MGT] %s: " fmt "\n",\
+				__func__, ## arg)
+#define ADDR_MGT_ERR(fmt, arg...) printk(KERN_ERR "[ADDR_MGT] %s: " fmt "\n",\
+				__func__, ## arg)
+
+#define MODULE_CUR_VERSION  "v1.0.9"
+
+#define MATCH_STR_LEN       20
+#define ADDR_VAL_LEN        6
+#define ADDR_STR_LEN        18
+#define ID_LEN              16
+#define HASH_LEN            32
+
+#define TYPE_ANY            0
+#define TYPE_BURN           1
+#define TYPE_IDGEN          2
+#define TYPE_USER           3
+#define TYPE_RAND           4
+
+#define ADDR_FMT_STR        0
+#define ADDR_FMT_VAL        1
+
+#define IS_TYPE_INVALID(x)  ((x < TYPE_ANY) || (x > TYPE_RAND))
+
+#define ADDR_CLASS_ATTR_ADD(name) \
+static ssize_t addr_##name##_show(struct class *class, \
+		struct class_attribute *attr, char *buffer) \
+{ \
+	char addr[ADDR_STR_LEN]; \
+	if (IS_TYPE_INVALID(get_addr_by_name(ADDR_FMT_STR, addr, #name))) \
+		return 0; \
+	return sprintf(buffer, "%.17s\n", addr); \
+} \
+static ssize_t addr_##name##_store(struct class *class, \
+		struct class_attribute *attr, \
+		const char *buffer, size_t count) \
+{ \
+	if (count != ADDR_STR_LEN) { \
+		ADDR_MGT_ERR("Length wrong."); \
+		return -EINVAL; \
+	} \
+	set_addr_by_name(TYPE_USER, ADDR_FMT_STR, buffer, #name); \
+	return count; \
+} \
+static CLASS_ATTR_RW(addr_##name);
+
+struct addr_mgt_info {
+	unsigned int type_def;
+	unsigned int type_cur;
+	unsigned int flag;
+	char *addr;
+	char *name;
+};
+
+static struct addr_mgt_info info[] = {
+	{TYPE_ANY, TYPE_ANY, 1, NULL, "wifi"},
+	{TYPE_ANY, TYPE_ANY, 0, NULL, "bt"  },
+	{TYPE_ANY, TYPE_ANY, 1, NULL, "eth" },
+};
+
+extern int hmac_sha256(const uint8_t *plaintext, ssize_t psize, uint8_t *output);
+extern int sunxi_get_soc_chipid(unsigned char *chipid);
+
+static int addr_parse(int fmt, const char *addr, int check)
+{
+	char val_buf[ADDR_VAL_LEN];
+	char cmp_buf[ADDR_VAL_LEN];
+	int  ret = ADDR_VAL_LEN;
+
+	if (fmt == ADDR_FMT_STR)
+		ret = sscanf(addr, "%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx",
+					&val_buf[0], &val_buf[1], &val_buf[2],
+					&val_buf[3], &val_buf[4], &val_buf[5]);
+	else
+		memcpy(val_buf, addr, ADDR_VAL_LEN);
+
+	if (ret != ADDR_VAL_LEN)
+		return -1;
+
+	if (check && (val_buf[0] & 0x3))
+		return -1;
+
+	memset(cmp_buf, 0x00, ADDR_VAL_LEN);
+	if (memcmp(val_buf, cmp_buf, ADDR_VAL_LEN) == 0)
+		return -1;
+
+	memset(cmp_buf, 0xFF, ADDR_VAL_LEN);
+	if (memcmp(val_buf, cmp_buf, ADDR_VAL_LEN) == 0)
+		return -1;
+
+	return 0;
+}
+
+static struct addr_mgt_info *addr_find_by_name(char *name)
+{
+	int i = 0;
+	for (i = 0; i < ARRAY_SIZE(info); i++) {
+		if (strcmp(info[i].name, name) == 0)
+			return &info[i];
+	}
+	return NULL;
+}
+
+static int get_addr_by_name(int fmt, char *addr, char *name)
+{
+	struct addr_mgt_info *t;
+
+	t = addr_find_by_name(name);
+	if (t == NULL) {
+		ADDR_MGT_ERR("can't find addr named: %s", name);
+		return -1;
+	}
+
+	if (IS_TYPE_INVALID(t->type_cur)) {
+		ADDR_MGT_ERR("addr type invalid");
+		return -1;
+	}
+
+	if (addr_parse(ADDR_FMT_VAL, t->addr, t->flag)) {
+		ADDR_MGT_ERR("addr parse fail(%s)", t->addr);
+		return -1;
+	}
+
+	if (fmt == ADDR_FMT_STR)
+		sprintf(addr, "%02X:%02X:%02X:%02X:%02X:%02X",
+				t->addr[0], t->addr[1], t->addr[2],
+				t->addr[3], t->addr[4], t->addr[5]);
+	else
+		memcpy(addr, t->addr, ADDR_VAL_LEN);
+
+	return t->type_cur;
+}
+
+static int set_addr_by_name(int type, int fmt, const char *addr, char *name)
+{
+	struct addr_mgt_info *t;
+
+	t = addr_find_by_name(name);
+	if (t == NULL) {
+		ADDR_MGT_ERR("can't find addr named: %s", name);
+		return -1;
+	}
+
+	if (addr_parse(fmt, addr, t->flag)) {
+		ADDR_MGT_ERR("addr parse fail(%s)", addr);
+		return -1;
+	}
+
+	t->type_cur = type;
+	if (fmt == ADDR_FMT_STR)
+		sscanf(addr, "%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx",
+				&t->addr[0], &t->addr[1], &t->addr[2],
+				&t->addr[3], &t->addr[4], &t->addr[5]);
+	else
+		memcpy(t->addr, addr, ADDR_VAL_LEN);
+
+	return 0;
+}
+
+int get_custom_mac_address(int fmt, char *name, char *addr)
+{
+	return get_addr_by_name(fmt, addr, name);
+}
+EXPORT_SYMBOL_GPL(get_custom_mac_address);
+
+static int addr_factory(struct device_node *np,
+			int idx, int type, char *mac, char *name)
+{
+	int  ret, i;
+	char match[MATCH_STR_LEN];
+	const char *p;
+	char id[ID_LEN], hash[HASH_LEN], cmp_buf[ID_LEN];
+	struct timespec64 curtime;
+
+	switch (type) {
+	case TYPE_BURN:
+		sprintf(match, "addr_%s", name);
+		ret = of_property_read_string_index(np, match, 0, &p);
+		if (ret)
+			return -1;
+
+		ret = sscanf(p, "%02hhx:%02hhx:%02hhx:%02hhx:%02hhx:%02hhx",
+			&mac[0], &mac[1], &mac[2],
+			&mac[3], &mac[4], &mac[5]);
+
+		if (ret != ADDR_VAL_LEN)
+			return -1;
+		break;
+	case TYPE_IDGEN:
+		if (idx > HASH_LEN / ADDR_VAL_LEN - 1)
+			return -1;
+		if (sunxi_get_soc_chipid(id))
+			return -1;
+		memset(cmp_buf, 0x00, ID_LEN);
+		if (memcmp(id, cmp_buf, ID_LEN) == 0)
+			return -1;
+		if (hmac_sha256(id, ID_LEN, hash))
+			return -1;
+		memcpy(mac, &hash[idx * ADDR_VAL_LEN], ADDR_VAL_LEN);
+		break;
+	case TYPE_RAND:
+		for (i = 0; i < ADDR_VAL_LEN; i++) {
+			ktime_get_real_ts64(&curtime);
+			mac[i] = (char)curtime.tv_nsec;
+		}
+		break;
+	default:
+		ADDR_MGT_ERR("unsupport type: %d", type);
+		return -1;
+	}
+	return 0;
+}
+
+static int addr_init(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	int  type, i, j;
+	char match[MATCH_STR_LEN];
+	char addr[ADDR_VAL_LEN];
+	int  type_tab[] = {TYPE_BURN, TYPE_IDGEN, TYPE_RAND};
+
+	/* init addr type and value */
+	for (i = 0; i < ARRAY_SIZE(info); i++) {
+		sprintf(match, "type_addr_%s", info[i].name);
+		if (of_property_read_u32(np, match, &type)) {
+			ADDR_MGT_DBG("Failed to get type_def_%s, use default: %d",
+						info[i].name, info[i].type_def);
+		} else {
+			info[i].type_def = type;
+			info[i].type_cur = type;
+		}
+
+		if (IS_TYPE_INVALID(info[i].type_def))
+			return -1;
+		if (info[i].type_def != TYPE_ANY) {
+			if (addr_factory(np, i, info[i].type_def, addr, info[i].name))
+				return -1;
+		} else {
+			for (j = 0; j < ARRAY_SIZE(type_tab); j++) {
+				if (!addr_factory(np, i, type_tab[j], addr, info[i].name)) {
+					info[i].type_cur = type_tab[j];
+					break;
+				}
+			}
+		}
+
+		if (info[i].flag)
+			addr[0] &= 0xFC;
+
+		if (addr_parse(ADDR_FMT_VAL, addr, info[i].flag))
+			return -1;
+		else {
+			info[i].addr = devm_kzalloc(&pdev->dev, ADDR_VAL_LEN, GFP_KERNEL);
+			memcpy(info[i].addr, addr, ADDR_VAL_LEN);
+		}
+	}
+	return 0;
+}
+
+static ssize_t summary_show(struct class *class,
+				struct class_attribute *attr, char *buffer)
+{
+	int i = 0, ret = 0;
+
+	ret += sprintf(&buffer[ret], "name cfg cur address\n");
+	for (i = 0; i < ARRAY_SIZE(info); i++) {
+		ret += sprintf(&buffer[ret],
+			"%4s  %d   %d  %02X:%02X:%02X:%02X:%02X:%02X\n",
+			info[i].name,   info[i].type_def, info[i].type_cur,
+			info[i].addr[0], info[i].addr[1], info[i].addr[2],
+			info[i].addr[3], info[i].addr[4], info[i].addr[5]);
+	}
+	return ret;
+}
+static CLASS_ATTR_RO(summary);
+
+ADDR_CLASS_ATTR_ADD(wifi);
+ADDR_CLASS_ATTR_ADD(bt);
+ADDR_CLASS_ATTR_ADD(eth);
+
+static struct attribute *addr_class_attrs[] = {
+	&class_attr_summary.attr,
+	&class_attr_addr_wifi.attr,
+	&class_attr_addr_bt.attr,
+	&class_attr_addr_eth.attr,
+	NULL
+};
+ATTRIBUTE_GROUPS(addr_class);
+
+static struct class addr_class = {
+	.name = "addr_mgt",
+	.owner = THIS_MODULE,
+	.class_groups = addr_class_groups,
+};
+
+static const struct of_device_id addr_mgt_ids[] = {
+	{ .compatible = "allwinner,sunxi-addr_mgt" },
+	{ /* Sentinel */ }
+};
+
+static int addr_mgt_probe(struct platform_device *pdev)
+{
+	int status;
+
+	ADDR_MGT_DBG("module version: %s", MODULE_CUR_VERSION);
+	status = class_register(&addr_class);
+	if (status < 0) {
+		ADDR_MGT_ERR("class register error, status: %d.", status);
+		return -1;
+	}
+
+	if (addr_init(pdev)) {
+		ADDR_MGT_ERR("failed to init addr.");
+		class_unregister(&addr_class);
+		return -1;
+	}
+	ADDR_MGT_DBG("success.");
+	return 0;
+}
+
+static int addr_mgt_remove(struct platform_device *pdev)
+{
+	class_unregister(&addr_class);
+	return 0;
+}
+
+static struct platform_driver addr_mgt_driver = {
+	.probe  = addr_mgt_probe,
+	.remove = addr_mgt_remove,
+	.driver = {
+		.owner = THIS_MODULE,
+		.name  = "sunxi-addr-mgt",
+		.of_match_table = addr_mgt_ids,
+	},
+};
+
+module_platform_driver_probe(addr_mgt_driver, addr_mgt_probe);
+
+MODULE_AUTHOR("Allwinnertech");
+MODULE_DESCRIPTION("Network MAC Addess Manager");
+MODULE_LICENSE("GPL");
diff -Nuar -r --no-dereference linux-5.15.139/drivers/power/supply/axp20x_battery.c linux/drivers/power/supply/axp20x_battery.c
--- linux-5.15.139/drivers/power/supply/axp20x_battery.c	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/power/supply/axp20x_battery.c	2024-01-03 16:06:25.935131000 +0800
@@ -34,6 +34,7 @@
 
 #define AXP20X_PWR_STATUS_BAT_CHARGING	BIT(2)
 
+#define AXP20X_PWR_OP_BATT_CHARGING	BIT(6)
 #define AXP20X_PWR_OP_BATT_PRESENT	BIT(5)
 #define AXP20X_PWR_OP_BATT_ACTIVATED	BIT(3)
 
@@ -56,14 +57,22 @@
 
 #define AXP20X_V_OFF_MASK		GENMASK(2, 0)
 
+#define DRVNAME "axp20x-battery-power-supply"
+
 struct axp20x_batt_ps;
 
+struct axp_irq_data {
+	const char *name;
+	irq_handler_t handler;
+};
+
 struct axp_data {
 	int	ccc_scale;
 	int	ccc_offset;
 	bool	has_fg_valid;
 	int	(*get_max_voltage)(struct axp20x_batt_ps *batt, int *val);
 	int	(*set_max_voltage)(struct axp20x_batt_ps *batt, int val);
+	const struct axp_irq_data *irqs;
 };
 
 struct axp20x_batt_ps {
@@ -73,6 +82,7 @@
 	struct iio_channel *batt_chrg_i;
 	struct iio_channel *batt_dischrg_i;
 	struct iio_channel *batt_v;
+	int health;
 	/* Maximum constant charge current */
 	unsigned int max_ccc;
 	const struct axp_data	*data;
@@ -181,6 +191,25 @@
 	return 0;
 }
 
+static int axp20x_get_ocv_voltage(struct axp20x_batt_ps *axp, int *val)
+{
+	int ret;
+	unsigned int ocvh, ocvl, ocv;
+
+	ret = regmap_read(axp->regmap, AXP288_FG_OCVH_REG, &ocvh);
+	if (ret)
+		return ret;
+
+	ret = regmap_read(axp->regmap, AXP288_FG_OCVL_REG, &ocvl);
+	if (ret)
+		return ret;
+
+	ocv = ocvh << 4 | (ocvl & 0xf);
+
+	*val = ocv * 1100;
+	return 0;
+}
+
 static int axp20x_battery_get_prop(struct power_supply *psy,
 				   enum power_supply_property psp,
 				   union power_supply_propval *val)
@@ -200,12 +229,12 @@
 		break;
 
 	case POWER_SUPPLY_PROP_STATUS:
-		ret = regmap_read(axp20x_batt->regmap, AXP20X_PWR_INPUT_STATUS,
+		ret = regmap_read(axp20x_batt->regmap, AXP20X_PWR_OP_MODE,
 				  &reg);
 		if (ret)
 			return ret;
 
-		if (reg & AXP20X_PWR_STATUS_BAT_CHARGING) {
+		if (reg & AXP20X_PWR_OP_BATT_CHARGING) {
 			val->intval = POWER_SUPPLY_STATUS_CHARGING;
 			return 0;
 		}
@@ -245,7 +274,7 @@
 			return 0;
 		}
 
-		val->intval = POWER_SUPPLY_HEALTH_GOOD;
+		val->intval = axp20x_batt->health;
 		break;
 
 	case POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT:
@@ -278,6 +307,9 @@
 		val->intval *= 1000;
 		break;
 
+	case POWER_SUPPLY_PROP_VOLTAGE_OCV:
+		return axp20x_get_ocv_voltage(axp20x_batt, &val->intval);
+
 	case POWER_SUPPLY_PROP_CAPACITY:
 		/* When no battery is present, return capacity is 100% */
 		ret = regmap_read(axp20x_batt->regmap, AXP20X_PWR_OP_MODE,
@@ -375,6 +407,11 @@
 		val = AXP20X_CHRG_CTRL1_TGT_4_2V;
 		break;
 
+	case 4350000:
+	case 4360000:
+		val = AXP20X_CHRG_CTRL1_TGT_4_36V;
+		break;
+
 	default:
 		/*
 		 * AXP20x max voltage can be set to 4.36V and AXP22X max voltage
@@ -494,6 +531,7 @@
 	POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT,
 	POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX,
 	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_VOLTAGE_OCV,
 	POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN,
 	POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN,
 	POWER_SUPPLY_PROP_CAPACITY,
@@ -519,11 +557,84 @@
 	.set_property = axp20x_battery_set_prop,
 };
 
+static irqreturn_t axp20x_battery_changed_irq(int irq, void *devid)
+{
+	struct axp20x_batt_ps *axp20x_batt = devid;
+
+	power_supply_changed(axp20x_batt->batt);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t axp20x_battery_temp_cold_irq(int irq, void *devid)
+{
+	struct axp20x_batt_ps *axp20x_batt = devid;
+
+	axp20x_batt->health = POWER_SUPPLY_HEALTH_COLD;
+
+	power_supply_changed(axp20x_batt->batt);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t axp20x_battery_temp_hot_irq(int irq, void *devid)
+{
+	struct axp20x_batt_ps *axp20x_batt = devid;
+
+	axp20x_batt->health = POWER_SUPPLY_HEALTH_OVERHEAT;
+
+	power_supply_changed(axp20x_batt->batt);
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t axp20x_battery_temp_normal_irq(int irq, void *devid)
+{
+	struct axp20x_batt_ps *axp20x_batt = devid;
+
+	axp20x_batt->health = POWER_SUPPLY_HEALTH_GOOD;
+
+	power_supply_changed(axp20x_batt->batt);
+
+	return IRQ_HANDLED;
+}
+
+static const struct axp_irq_data axp20x_irqs[] = {
+	{ "BATT_PLUGIN",		axp20x_battery_changed_irq },
+	{ "BATT_REMOVAL",		axp20x_battery_changed_irq },
+	{ "BATT_HEALTH_DEAD",		axp20x_battery_changed_irq },
+	{ "BATT_HEALTH_GOOD",		axp20x_battery_changed_irq },
+	{ "BATT_CHARGING",		axp20x_battery_changed_irq },
+	{ "BATT_CHARGING_DONE",		axp20x_battery_changed_irq },
+	{}
+};
+
+static const struct axp_irq_data axp813_irqs[] = {
+	{ "BATT_PLUGIN",		axp20x_battery_changed_irq },
+	{ "BATT_REMOVAL",		axp20x_battery_changed_irq },
+	{ "BATT_HEALTH_DEAD",		axp20x_battery_changed_irq },
+	{ "BATT_HEALTH_GOOD",		axp20x_battery_changed_irq },
+	{ "BATT_CHARGING",		axp20x_battery_changed_irq },
+	{ "BATT_CHARGING_DONE",		axp20x_battery_changed_irq },
+	{ "BATT_LOW_PWR_LVL1",		axp20x_battery_changed_irq },
+	{ "BATT_LOW_PWR_LVL2",		axp20x_battery_changed_irq },
+	{ "BATT_CHG_TEMP_HIGH",		axp20x_battery_temp_hot_irq },
+	{ "BATT_CHG_TEMP_HIGH_END",	axp20x_battery_temp_normal_irq },
+	{ "BATT_CHG_TEMP_LOW",		axp20x_battery_temp_cold_irq },
+	{ "BATT_CHG_TEMP_LOW_END",	axp20x_battery_temp_normal_irq },
+	{ "BATT_ACT_TEMP_HIGH",		axp20x_battery_temp_hot_irq },
+	{ "BATT_ACT_TEMP_HIGH_END",	axp20x_battery_temp_normal_irq },
+	{ "BATT_ACT_TEMP_LOW",		axp20x_battery_temp_cold_irq },
+	{ "BATT_ACT_TEMP_LOW_END",	axp20x_battery_temp_normal_irq },
+	{}
+};
+
 static const struct axp_data axp209_data = {
 	.ccc_scale = 100000,
 	.ccc_offset = 300000,
 	.get_max_voltage = axp20x_battery_get_max_voltage,
 	.set_max_voltage = axp20x_battery_set_max_voltage,
+	.irqs = axp20x_irqs,
 };
 
 static const struct axp_data axp221_data = {
@@ -532,6 +643,7 @@
 	.has_fg_valid = true,
 	.get_max_voltage = axp22x_battery_get_max_voltage,
 	.set_max_voltage = axp22x_battery_set_max_voltage,
+	.irqs = axp20x_irqs,
 };
 
 static const struct axp_data axp813_data = {
@@ -540,6 +652,7 @@
 	.has_fg_valid = true,
 	.get_max_voltage = axp813_battery_get_max_voltage,
 	.set_max_voltage = axp20x_battery_set_max_voltage,
+	.irqs = axp813_irqs,
 };
 
 static const struct of_device_id axp20x_battery_ps_id[] = {
@@ -558,10 +671,13 @@
 
 static int axp20x_power_probe(struct platform_device *pdev)
 {
+	struct axp20x_dev *axp20x = dev_get_drvdata(pdev->dev.parent);
 	struct axp20x_batt_ps *axp20x_batt;
 	struct power_supply_config psy_cfg = {};
 	struct power_supply_battery_info info;
 	struct device *dev = &pdev->dev;
+	const struct axp_irq_data *irq_data;
+	int irq, ret;
 
 	if (!of_device_is_available(pdev->dev.of_node))
 		return -ENODEV;
@@ -613,6 +729,8 @@
 		return PTR_ERR(axp20x_batt->batt);
 	}
 
+	axp20x_batt->health = POWER_SUPPLY_HEALTH_GOOD;
+
 	if (!power_supply_get_battery_info(axp20x_batt->batt, &info)) {
 		int vmin = info.voltage_min_design_uv;
 		int ccc = info.constant_charge_current_max_ua;
@@ -635,6 +753,25 @@
 		}
 	}
 
+	/* Request irqs after registering, as irqs may trigger immediately */
+	for (irq_data = axp20x_batt->data->irqs; irq_data->name; irq_data++) {
+		irq = platform_get_irq_byname(pdev, irq_data->name);
+		if (irq < 0) {
+			dev_err(&pdev->dev, "No IRQ for %s: %d\n",
+				irq_data->name, irq);
+			return irq;
+		}
+		irq = regmap_irq_get_virq(axp20x->regmap_irqc, irq);
+		ret = devm_request_any_context_irq(&pdev->dev, irq,
+						   irq_data->handler, 0,
+						   DRVNAME, axp20x_batt);
+		if (ret < 0) {
+			dev_err(&pdev->dev, "Error requesting %s IRQ: %d\n",
+				irq_data->name, ret);
+			return ret;
+		}
+	}
+
 	/*
 	 * Update max CCC to a valid value if battery info is present or set it
 	 * to current register value by default.
@@ -642,13 +779,66 @@
 	axp20x_get_constant_charge_current(axp20x_batt,
 					   &axp20x_batt->max_ccc);
 
+	if (of_machine_is_compatible("pine64,pinephone-1.2") > 0 ||
+		of_machine_is_compatible("pine64,pinephone-1.1") > 0 ||
+		of_machine_is_compatible("pine64,pinephone-1.0") > 0) {
+		// 3kOhm NTC inside PinePhone batery
+		// ---------------------------------
+		//
+		// Charging:
+		//  0 - 15 C: Max 0.2C CC to 4.35V : 9750 Ohm - 4710 Ohm
+		// 15 - 50 C: Max 0.5C CC to 4.35V : 4710 Ohm - 1080 Ohm
+		//
+		// Discharging:
+		// -10 C : 16500 Ohm
+		//  55 C : 896 Ohm
+		// enable TS pin input to ADC
+
+		dev_info(dev, "Configuring battery thermal regulation for Pinephone\n");
+
+		ret = regmap_update_bits(axp20x_batt->regmap, 0x82, BIT(0), BIT(0));
+		if (ret)
+			goto warn_bat;
+
+		// safety thresholds:
+
+		// voltage = reg_val * 12800 uV (range is 0 - 3.264V)
+		ret = regmap_write(axp20x_batt->regmap, 0x38,  9750 * 80 / 12800); // V_LTF-charge
+		if (ret)
+			goto warn_bat;
+
+		ret = regmap_write(axp20x_batt->regmap, 0x39,  1080 * 80 / 12800); // V_HTF-charge
+		if (ret)
+			goto warn_bat;
+
+		ret = regmap_write(axp20x_batt->regmap, 0x3c, 16500 * 80 / 12800); // V_LTF-work
+		if (ret)
+			goto warn_bat;
+
+		ret = regmap_write(axp20x_batt->regmap, 0x3d,   896 * 80 / 12800); // V_HTF-work
+		if (ret)
+			goto warn_bat;
+
+		// There is a hysteresis of 460.8 mV(refer to TS pin voltage) for UTP
+		// threshold, and there is a hysteresis of 57.6 mV for OTP threshold.
+
+		// use TS pin only when charging, make it affect the charger, I = 80uA
+		ret = regmap_update_bits(axp20x_batt->regmap, 0x84, 0x37, 0x31);
+		if (ret)
+			goto warn_bat;
+	}
+
+	return 0;
+
+warn_bat:
+	dev_err(dev, "Failed to configure battery thermal regulation\n");
 	return 0;
 }
 
 static struct platform_driver axp20x_batt_driver = {
 	.probe    = axp20x_power_probe,
 	.driver   = {
-		.name  = "axp20x-battery-power-supply",
+		.name		= DRVNAME,
 		.of_match_table = axp20x_battery_ps_id,
 	},
 };
diff -Nuar -r --no-dereference linux-5.15.139/drivers/power/supply/power_supply_sysfs.c linux/drivers/power/supply/power_supply_sysfs.c
--- linux-5.15.139/drivers/power/supply/power_supply_sysfs.c	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/power/supply/power_supply_sysfs.c	2024-01-03 16:06:25.935131000 +0800
@@ -199,6 +199,8 @@
 	POWER_SUPPLY_ATTR(TIME_TO_FULL_NOW),
 	POWER_SUPPLY_ATTR(TIME_TO_FULL_AVG),
 	POWER_SUPPLY_ENUM_ATTR(TYPE),
+	POWER_SUPPLY_ATTR(USB_BC_ENABLED),
+	POWER_SUPPLY_ATTR(USB_DCP_INPUT_CURRENT_LIMIT),
 	POWER_SUPPLY_ATTR(USB_TYPE),
 	POWER_SUPPLY_ENUM_ATTR(SCOPE),
 	POWER_SUPPLY_ATTR(PRECHARGE_CURRENT),
diff -Nuar -r --no-dereference linux-5.15.139/drivers/power/supply/Makefile linux/drivers/power/supply/Makefile
--- linux-5.15.139/drivers/power/supply/Makefile	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/power/supply/Makefile	2024-01-03 16:06:25.935131000 +0800
@@ -104,3 +104,4 @@
 obj-$(CONFIG_BATTERY_ACER_A500)	+= acer_a500_battery.o
 obj-$(CONFIG_BATTERY_SURFACE)	+= surface_battery.o
 obj-$(CONFIG_CHARGER_SURFACE)	+= surface_charger.o
+obj-$(CONFIG_BATTERY_RK818)	+= rk818_battery.o
diff -Nuar -r --no-dereference linux-5.15.139/drivers/power/supply/axp20x_usb_power.c linux/drivers/power/supply/axp20x_usb_power.c
--- linux-5.15.139/drivers/power/supply/axp20x_usb_power.c	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/power/supply/axp20x_usb_power.c	2024-01-03 16:06:25.935131000 +0800
@@ -52,6 +52,13 @@
 #define AXP20X_ADC_EN1_VBUS_VOLT	BIT(3)
 
 #define AXP20X_VBUS_MON_VBUS_VALID	BIT(3)
+#define AXP813_CHRG_CTRL3_VBUS_CUR_LIMIT_MASK GENMASK(7, 4)
+#define AXP813_CHRG_CTRL3_VBUS_CUR_LIMIT_OFFSET 4
+
+#define AXP813_BC_RESULT_MASK		GENMASK(7, 5)
+#define AXP813_BC_RESULT_SDP		(1 << 5)
+#define AXP813_BC_RESULT_CDP		(2 << 5)
+#define AXP813_BC_RESULT_DCP		(3 << 5)
 
 #define AXP813_BC_EN		BIT(0)
 
@@ -175,6 +182,110 @@
 	return 0;
 }
 
+static int
+axp813_usb_power_get_input_current_limit(struct axp20x_usb_power *power,
+					 int *intval)
+{
+	unsigned int v;
+	int ret = regmap_read(power->regmap, AXP813_CHRG_CTRL3, &v);
+
+	if (ret)
+		return ret;
+
+	v &= AXP813_CHRG_CTRL3_VBUS_CUR_LIMIT_MASK;
+	v >>= AXP813_CHRG_CTRL3_VBUS_CUR_LIMIT_OFFSET;
+
+	switch (v) {
+	case 0:
+		*intval = 100000;
+		return 0;
+	case 1:
+		*intval = 500000;
+		return 0;
+	case 2:
+		*intval = 900000;
+		return 0;
+	case 3:
+		*intval = 1500000;
+		return 0;
+	case 4:
+		*intval = 2000000;
+		return 0;
+	case 5:
+		*intval = 2500000;
+		return 0;
+	case 6:
+		*intval = 3000000;
+		return 0;
+	case 7:
+		*intval = 3500000;
+		return 0;
+	default:
+		*intval = 4000000;
+		return 0;
+	}
+}
+
+static int
+axp813_get_usb_bc_enabled(struct axp20x_usb_power *power, int *intval)
+{
+	unsigned int reg;
+	int ret;
+
+	ret = regmap_read(power->regmap, AXP288_BC_GLOBAL, &reg);
+	if (ret)
+		return ret;
+
+	*intval = !!(reg & AXP813_BC_EN);
+	return 0;
+}
+
+static enum power_supply_usb_type axp813_usb_types[] = {
+	POWER_SUPPLY_USB_TYPE_PD,
+	POWER_SUPPLY_USB_TYPE_SDP,
+	POWER_SUPPLY_USB_TYPE_DCP,
+	POWER_SUPPLY_USB_TYPE_CDP,
+	POWER_SUPPLY_USB_TYPE_UNKNOWN,
+};
+
+static int axp813_get_usb_type(struct axp20x_usb_power *power,
+			       union power_supply_propval *val)
+{
+	unsigned int reg;
+	int ret;
+
+	ret = regmap_read(power->regmap, AXP288_BC_GLOBAL, &reg);
+	if (ret)
+		return ret;
+
+	if (!(reg & AXP813_BC_EN)) {
+		val->intval = POWER_SUPPLY_USB_TYPE_PD;
+		return 0;
+	}
+
+	ret = regmap_read(power->regmap, AXP288_BC_DET_STAT, &reg);
+	if (ret)
+		return ret;
+
+	switch (reg & AXP813_BC_RESULT_MASK) {
+	case AXP813_BC_RESULT_SDP:
+		val->intval = POWER_SUPPLY_USB_TYPE_SDP;
+		break;
+	case AXP813_BC_RESULT_CDP:
+		val->intval = POWER_SUPPLY_USB_TYPE_CDP;
+		break;
+	case AXP813_BC_RESULT_DCP:
+		val->intval = POWER_SUPPLY_USB_TYPE_DCP;
+		break;
+	default:
+		val->intval = POWER_SUPPLY_USB_TYPE_UNKNOWN;
+		break;
+	}
+
+	return 0;
+}
+
+
 static int axp20x_usb_power_get_property(struct power_supply *psy,
 	enum power_supply_property psp, union power_supply_propval *val)
 {
@@ -213,8 +324,6 @@
 		val->intval = ret * 1700; /* 1 step = 1.7 mV */
 		return 0;
 	case POWER_SUPPLY_PROP_CURRENT_MAX:
-		if (power->axp20x_id == AXP813_ID)
-			return axp813_get_current_max(power, &val->intval);
 		return axp20x_get_current_max(power, &val->intval);
 	case POWER_SUPPLY_PROP_CURRENT_NOW:
 		if (IS_ENABLED(CONFIG_AXP20X_ADC)) {
@@ -273,6 +382,30 @@
 	case POWER_SUPPLY_PROP_ONLINE:
 		val->intval = !!(input & AXP20X_PWR_STATUS_VBUS_USED);
 		break;
+
+	case POWER_SUPPLY_PROP_USB_TYPE:
+		if (power->axp20x_id == AXP813_ID)
+			return axp813_get_usb_type(power, val);
+
+		return -EINVAL;
+
+	case POWER_SUPPLY_PROP_USB_BC_ENABLED:
+		if (power->axp20x_id == AXP813_ID)
+			return axp813_get_usb_bc_enabled(power, &val->intval);
+
+		return -EINVAL;
+
+	case POWER_SUPPLY_PROP_USB_DCP_INPUT_CURRENT_LIMIT:
+		if (power->axp20x_id == AXP813_ID)
+			return axp813_get_current_max(power, &val->intval);
+
+		return -EINVAL;
+
+	case POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:
+		if (power->axp20x_id == AXP813_ID)
+			return axp813_usb_power_get_input_current_limit(power,
+								&val->intval);
+		fallthrough;
 	default:
 		return -EINVAL;
 	}
@@ -316,6 +449,37 @@
 	return -EINVAL;
 }
 
+static const unsigned axp813_input_current_limits_table[] = {
+	100000,
+	500000,
+	900000,
+	1500000,
+	2000000,
+	2500000,
+	3000000,
+	3500000,
+	4000000,
+};
+
+static int
+axp813_usb_power_set_input_current_limit(struct axp20x_usb_power *power,
+					 int intval)
+{
+	unsigned int reg;
+
+	if (intval < 100000)
+		return -EINVAL;
+
+	for (reg = ARRAY_SIZE(axp813_input_current_limits_table) - 1; reg > 0; reg--)
+		if (intval >= axp813_input_current_limits_table[reg])
+			break;
+
+	return regmap_update_bits(power->regmap,
+				  AXP813_CHRG_CTRL3,
+				  AXP813_CHRG_CTRL3_VBUS_CUR_LIMIT_MASK,
+				  reg << AXP813_CHRG_CTRL3_VBUS_CUR_LIMIT_OFFSET);
+}
+
 static int axp813_usb_power_set_current_max(struct axp20x_usb_power *power,
 					    int intval)
 {
@@ -364,6 +528,14 @@
 	return -EINVAL;
 }
 
+static int
+axp813_set_usb_bc_enabled(struct axp20x_usb_power *power, int val)
+{
+	return regmap_update_bits(power->regmap, AXP288_BC_GLOBAL,
+				  AXP813_BC_EN,
+				  val ? AXP813_BC_EN : 0);
+}
+
 static int axp20x_usb_power_set_property(struct power_supply *psy,
 					 enum power_supply_property psp,
 					 const union power_supply_propval *val)
@@ -380,11 +552,26 @@
 		return axp20x_usb_power_set_voltage_min(power, val->intval);
 
 	case POWER_SUPPLY_PROP_CURRENT_MAX:
+		return axp20x_usb_power_set_current_max(power, val->intval);
+
+	case POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT:
+		if (power->axp20x_id == AXP813_ID)
+			return axp813_usb_power_set_input_current_limit(power,
+								val->intval);
+		return -EINVAL;
+
+	case POWER_SUPPLY_PROP_USB_BC_ENABLED:
+		if (power->axp20x_id == AXP813_ID)
+			return axp813_set_usb_bc_enabled(power, val->intval);
+
+		return -EINVAL;
+
+	case POWER_SUPPLY_PROP_USB_DCP_INPUT_CURRENT_LIMIT:
 		if (power->axp20x_id == AXP813_ID)
 			return axp813_usb_power_set_current_max(power,
 								val->intval);
-		return axp20x_usb_power_set_current_max(power, val->intval);
 
+		return -EINVAL;
 	default:
 		return -EINVAL;
 	}
@@ -408,7 +595,10 @@
 		return power->axp20x_id == AXP813_ID;
 
 	return psp == POWER_SUPPLY_PROP_VOLTAGE_MIN ||
-	       psp == POWER_SUPPLY_PROP_CURRENT_MAX;
+	       psp == POWER_SUPPLY_PROP_CURRENT_MAX ||
+	       psp == POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT ||
+	       psp == POWER_SUPPLY_PROP_USB_BC_ENABLED ||
+	       psp == POWER_SUPPLY_PROP_USB_DCP_INPUT_CURRENT_LIMIT;
 }
 
 static enum power_supply_property axp20x_usb_power_properties[] = {
@@ -427,6 +617,18 @@
 	POWER_SUPPLY_PROP_ONLINE,
 	POWER_SUPPLY_PROP_VOLTAGE_MIN,
 	POWER_SUPPLY_PROP_CURRENT_MAX,
+	POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT,
+};
+
+static enum power_supply_property axp813_usb_power_properties[] = {
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_ONLINE,
+	POWER_SUPPLY_PROP_VOLTAGE_MIN,
+	POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT,
+	POWER_SUPPLY_PROP_USB_BC_ENABLED,
+	POWER_SUPPLY_PROP_USB_DCP_INPUT_CURRENT_LIMIT,
+	POWER_SUPPLY_PROP_USB_TYPE,
 };
 
 static const struct power_supply_desc axp20x_usb_power_desc = {
@@ -449,6 +651,18 @@
 	.set_property = axp20x_usb_power_set_property,
 };
 
+static const struct power_supply_desc axp813_usb_power_desc = {
+	.name = "axp20x-usb",
+	.type = POWER_SUPPLY_TYPE_USB,
+	.properties = axp813_usb_power_properties,
+	.num_properties = ARRAY_SIZE(axp813_usb_power_properties),
+	.property_is_writeable = axp20x_usb_power_prop_writeable,
+	.get_property = axp20x_usb_power_get_property,
+	.set_property = axp20x_usb_power_set_property,
+	.usb_types = axp813_usb_types,
+	.num_usb_types = ARRAY_SIZE(axp813_usb_types),
+};
+
 static const char * const axp20x_irq_names[] = {
 	"VBUS_PLUGIN",
 	"VBUS_REMOVAL",
@@ -461,6 +675,13 @@
 	"VBUS_REMOVAL",
 };
 
+static const char * const axp813_irq_names[] = {
+	"VBUS_PLUGIN",
+	"VBUS_REMOVAL",
+	"BC_USB_CHNG",
+	"MV_CHNG",
+};
+
 struct axp_data {
 	const struct power_supply_desc	*power_desc;
 	const char * const		*irq_names;
@@ -490,9 +711,9 @@
 };
 
 static const struct axp_data axp813_data = {
-	.power_desc	= &axp22x_usb_power_desc,
-	.irq_names	= axp22x_irq_names,
-	.num_irq_names	= ARRAY_SIZE(axp22x_irq_names),
+	.power_desc	= &axp813_usb_power_desc,
+	.irq_names	= axp813_irq_names,
+	.num_irq_names	= ARRAY_SIZE(axp813_irq_names),
 	.axp20x_id	= AXP813_ID,
 };
 
@@ -624,6 +845,18 @@
 		if (ret)
 			return ret;
 	}
+
+	/*TODO: Re-work this into a supply property with OF based default value */
+	if (of_machine_is_compatible("pine64,pinephone-1.2") > 0 ||
+		of_machine_is_compatible("pine64,pinephone-1.1") > 0 ||
+		of_machine_is_compatible("pine64,pinephone-1.0") > 0) {
+
+		dev_info(&pdev->dev, "Increasing Vbus hold voltage to 4.5V\n");
+
+		ret = regmap_update_bits(axp20x->regmap, 0x30, 0x7 << 3, 0x5 << 3);
+		if (ret)
+			return ret;
+	}
 
 	psy_cfg.of_node = pdev->dev.of_node;
 	psy_cfg.drv_data = power;
diff -Nuar -r --no-dereference linux-5.15.139/drivers/power/supply/Kconfig linux/drivers/power/supply/Kconfig
--- linux-5.15.139/drivers/power/supply/Kconfig	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/power/supply/Kconfig	2024-01-03 16:06:25.935131000 +0800
@@ -849,4 +849,12 @@
 	  Microsoft Surface devices, i.e. Surface Pro 7, Surface Laptop 3,
 	  Surface Book 3, and Surface Laptop Go.
 
+config BATTERY_RK818
+	bool "RK818 Battery driver"
+	depends on MFD_RK808
+	default n
+	help
+	  If you say yes here you will get support for the battery of RK818 PMIC.
+	  This driver can give support for Rk818 Battery Charge Interface.
+
 endif # POWER_SUPPLY
diff -Nuar -r --no-dereference linux-5.15.139/drivers/power/supply/rk818_battery.c linux/drivers/power/supply/rk818_battery.c
--- linux-5.15.139/drivers/power/supply/rk818_battery.c	1970-01-01 08:00:00.000000000 +0800
+++ linux/drivers/power/supply/rk818_battery.c	2024-01-03 16:06:25.935131000 +0800
@@ -0,0 +1,3568 @@
+/*
+ * rk818 battery driver
+ *
+ * Copyright (C) 2016 Rockchip Electronics Co., Ltd
+ * chenjh <chenjh@rock-chips.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <linux/delay.h>
+#include <linux/fb.h>
+#include <linux/gpio.h>
+#include <linux/iio/consumer.h>
+#include <linux/iio/iio.h>
+#include <linux/irq.h>
+#include <linux/irqdomain.h>
+#include <linux/jiffies.h>
+#include <linux/mfd/rk808.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/platform_device.h>
+#include <linux/power_supply.h>
+//#include <linux/power/rk_usbbc.h>
+#include <linux/regmap.h>
+//#include <linux/rk_keys.h>
+#include <linux/rtc.h>
+#include <linux/time64.h>
+#include <linux/timer.h>
+//#include <linux/wakelock.h>
+#include <linux/workqueue.h>
+#include "rk818_battery.h"
+
+static int dbg_enable = 0;
+module_param_named(dbg_level, dbg_enable, int, 0644);
+
+#define DBG(args...) \
+	do { \
+		if (dbg_enable) { \
+			pr_info(args); \
+		} \
+	} while (0)
+
+#define BAT_INFO(fmt, args...) pr_info("rk818-bat: "fmt, ##args)
+
+/* default param */
+#define DEFAULT_BAT_RES			135
+#define DEFAULT_SLP_ENTER_CUR		300
+#define DEFAULT_SLP_EXIT_CUR		300
+#define DEFAULT_SLP_FILTER_CUR		100
+#define DEFAULT_PWROFF_VOL_THRESD	3400
+#define DEFAULT_MONITOR_SEC		5
+#define DEFAULT_ALGR_VOL_THRESD1	3850
+#define DEFAULT_ALGR_VOL_THRESD2	3950
+#define DEFAULT_MAX_SOC_OFFSET		60
+#define DEFAULT_FB_TEMP			TEMP_105C
+#define DEFAULT_ZERO_RESERVE_DSOC	10
+#define DEFAULT_POFFSET			42
+#define DEFAULT_COFFSET			0x832
+#define DEFAULT_SAMPLE_RES		20
+#define DEFAULT_ENERGY_MODE		0
+#define INVALID_COFFSET_MIN		0x780
+#define INVALID_COFFSET_MAX		0x980
+#define INVALID_VOL_THRESD		2500
+
+/* sample resistor and division */
+#define SAMPLE_RES_10MR			10
+#define SAMPLE_RES_20MR			20
+#define SAMPLE_RES_DIV1			1
+#define SAMPLE_RES_DIV2			2
+
+/* virtual params */
+#define VIRTUAL_CURRENT			1000
+#define VIRTUAL_VOLTAGE			3888
+#define VIRTUAL_SOC			66
+#define VIRTUAL_PRESET			1
+#define VIRTUAL_TEMPERATURE		188
+#define VIRTUAL_STATUS			POWER_SUPPLY_STATUS_CHARGING
+
+/* charge */
+#define FINISH_CHRG_CUR1			1000
+#define FINISH_CHRG_CUR2		1500
+#define FINISH_MAX_SOC_DELAY		20
+#define TERM_CHRG_DSOC			88
+#define TERM_CHRG_CURR			600
+#define TERM_CHRG_K			650
+#define SIMULATE_CHRG_INTV		8
+#define SIMULATE_CHRG_CURR		400
+#define SIMULATE_CHRG_K			1500
+#define FULL_CHRG_K			400
+
+/* zero algorithm */
+#define PWROFF_THRESD			3400
+#define MIN_ZERO_DSOC_ACCURACY		10	/*0.01%*/
+#define MIN_ZERO_OVERCNT		100
+#define MIN_ACCURACY			1
+#define DEF_PWRPATH_RES			50
+#define	WAIT_DSOC_DROP_SEC		15
+#define	WAIT_SHTD_DROP_SEC		30
+#define ZERO_GAP_XSOC1			10
+#define ZERO_GAP_XSOC2			5
+#define ZERO_GAP_XSOC3			3
+#define ZERO_LOAD_LVL1			1400
+#define ZERO_LOAD_LVL2			600
+#define ZERO_GAP_CALIB			5
+
+#define ADC_CALIB_THRESHOLD		4
+#define ADC_CALIB_LMT_MIN		3
+#define ADC_CALIB_CNT			5
+#define NTC_CALC_FACTOR			7
+
+/* time */
+#define	POWER_ON_SEC_BASE		1
+#define MINUTE(x)			((x) * 60)
+
+/* sleep */
+#define SLP_CURR_MAX			40
+#define SLP_CURR_MIN			6
+#define DISCHRG_TIME_STEP1		MINUTE(10)
+#define DISCHRG_TIME_STEP2		MINUTE(60)
+#define SLP_DSOC_VOL_THRESD		3600
+#define REBOOT_PERIOD_SEC		180
+#define REBOOT_MAX_CNT			80
+
+/* fcc */
+#define MIN_FCC				500
+
+/* TS detect battery temperature */
+#define ADC_CUR_MSK			0x03
+#define ADC_CUR_20UA			0x00
+#define ADC_CUR_40UA			0x01
+#define ADC_CUR_60UA			0x02
+#define ADC_CUR_80UA			0x03
+
+#define NTC_CALC_FACTOR_80UA		7
+#define NTC_CALC_FACTOR_60UA		9
+#define NTC_CALC_FACTOR_40UA		13
+#define NTC_CALC_FACTOR_20UA		27
+#define NTC_80UA_MAX_MEASURE		27500
+#define NTC_60UA_MAX_MEASURE		36666
+#define NTC_40UA_MAX_MEASURE		55000
+#define NTC_20UA_MAX_MEASURE		110000
+
+static const char *bat_status[] = {
+	"charge off", "dead charge", "trickle charge", "cc cv",
+	"finish", "usb over vol", "bat temp error", "timer error",
+};
+
+struct rk818_battery {
+	struct platform_device		*pdev;
+	struct rk808			*rk818;
+	struct regmap			*regmap;
+	struct device			*dev;
+	struct power_supply		*bat;
+	struct power_supply		*usb_psy;
+	struct power_supply		*ac_psy;
+	struct battery_platform_data	*pdata;
+	struct workqueue_struct		*bat_monitor_wq;
+	struct delayed_work		bat_delay_work;
+	struct delayed_work		calib_delay_work;
+	// struct wake_lock		wake_lock;
+	struct notifier_block           fb_nb;
+	struct timer_list		caltimer;
+	time64_t				rtc_base;
+	int				bat_res;
+	int				chrg_status;
+	bool				is_initialized;
+	bool				is_first_power_on;
+	u8				res_div;
+	int				current_max;
+	int				voltage_max;
+	int				current_avg;
+	int				voltage_avg;
+	int				voltage_ocv;
+	int				voltage_relax;
+	int				voltage_k;
+	int				voltage_b;
+	int				remain_cap;
+	int				design_cap;
+	int				nac;
+	int				fcc;
+	int				qmax;
+	int				dsoc;
+	int				rsoc;
+	int				poffset;
+	int				age_ocv_soc;
+	bool				age_allow_update;
+	int				age_level;
+	int				age_ocv_cap;
+	int				age_voltage;
+	int				age_adjust_cap;
+	unsigned long			age_keep_sec;
+	int				zero_timeout_cnt;
+	int				zero_remain_cap;
+	int				zero_dsoc;
+	int				zero_linek;
+	u64				zero_drop_sec;
+	u64				shtd_drop_sec;
+	int				sm_remain_cap;
+	int				sm_linek;
+	int				sm_chrg_dsoc;
+	int				sm_dischrg_dsoc;
+	int				algo_rest_val;
+	int				algo_rest_mode;
+	int				sleep_sum_cap;
+	int				sleep_remain_cap;
+	unsigned long			sleep_dischrg_sec;
+	unsigned long			sleep_sum_sec;
+	bool				sleep_chrg_online;
+	u8				sleep_chrg_status;
+	bool				adc_allow_update;
+	int                             fb_blank;
+	bool				s2r; /*suspend to resume*/
+	u32				work_mode;
+	int				temperature;
+	u32				monitor_ms;
+	u32				pwroff_min;
+	u32				adc_calib_cnt;
+	unsigned long			finish_base;
+	unsigned long			boot_base;
+	unsigned long			flat_match_sec;
+	unsigned long			plug_in_base;
+	unsigned long			plug_out_base;
+	u8				halt_cnt;
+	bool				is_halt;
+	bool				is_max_soc_offset;
+	bool				is_sw_reset;
+	bool				is_ocv_calib;
+	bool				is_first_on;
+	bool				is_force_calib;
+	int				last_dsoc;
+	int				ocv_pre_dsoc;
+	int				ocv_new_dsoc;
+	int				max_pre_dsoc;
+	int				max_new_dsoc;
+	int				force_pre_dsoc;
+	int				force_new_dsoc;
+	int				dbg_cap_low0;
+	int				dbg_pwr_dsoc;
+	int				dbg_pwr_rsoc;
+	int				dbg_pwr_vol;
+	int				dbg_chrg_min[10];
+	int				dbg_meet_soc;
+	int				dbg_calc_dsoc;
+	int				dbg_calc_rsoc;
+	u8				ac_in;
+	u8				usb_in;
+	int				is_charging;
+	unsigned long			charge_count;
+};
+
+#define DIV(x)	((x) ? (x) : 1)
+
+static void rk_send_wakeup_key(void)
+{
+	// TODO: WHAT TO DO HERE?
+}
+
+static u64 get_boot_sec(void)
+{
+	struct timespec64 ts;
+
+	ktime_get_boottime_ts64(&ts);
+
+	return ts.tv_sec;
+}
+
+static unsigned long base2sec(unsigned long x)
+{
+	if (x)
+		return (get_boot_sec() > x) ? (get_boot_sec() - x) : 0;
+	else
+		return 0;
+}
+
+static unsigned long base2min(unsigned long x)
+{
+	return base2sec(x) / 60;
+}
+
+static u32 interpolate(int value, u32 *table, int size)
+{
+	u8 i;
+	u16 d;
+
+	for (i = 0; i < size; i++) {
+		if (value < table[i])
+			break;
+	}
+
+	if ((i > 0) && (i < size)) {
+		d = (value - table[i - 1]) * (MAX_INTERPOLATE / (size - 1));
+		d /= table[i] - table[i - 1];
+		d = d + (i - 1) * (MAX_INTERPOLATE / (size - 1));
+	} else {
+		d = i * ((MAX_INTERPOLATE + size / 2) / size);
+	}
+
+	if (d > 1000)
+		d = 1000;
+
+	return d;
+}
+
+/* (a*b)/c */
+static int32_t ab_div_c(u32 a, u32 b, u32 c)
+{
+	bool sign;
+	u32 ans = MAX_INT;
+	int tmp;
+
+	sign = ((((a ^ b) ^ c) & 0x80000000) != 0);
+	if (c != 0) {
+		if (sign)
+			c = -c;
+		tmp = (a * b + (c >> 1)) / c;
+		if (tmp < MAX_INT)
+			ans = tmp;
+	}
+
+	if (sign)
+		ans = -ans;
+
+	return ans;
+}
+
+static int rk818_bat_read(struct rk818_battery *di, u8 reg)
+{
+	int ret, val;
+
+	ret = regmap_read(di->regmap, reg, &val);
+	if (ret)
+		dev_err(di->dev, "read reg:0x%x failed\n", reg);
+
+	return val;
+}
+
+static int rk818_bat_write(struct rk818_battery *di, u8 reg, u8 buf)
+{
+	int ret;
+
+	ret = regmap_write(di->regmap, reg, buf);
+	if (ret)
+		dev_err(di->dev, "i2c write reg: 0x%2x error\n", reg);
+
+	return ret;
+}
+
+static int rk818_bat_set_bits(struct rk818_battery *di, u8 reg, u8 mask, u8 buf)
+{
+	int ret;
+
+	ret = regmap_update_bits(di->regmap, reg, mask, buf);
+	if (ret)
+		dev_err(di->dev, "write reg:0x%x failed\n", reg);
+
+	return ret;
+}
+
+static int rk818_bat_clear_bits(struct rk818_battery *di, u8 reg, u8 mask)
+{
+	int ret;
+
+	ret = regmap_update_bits(di->regmap, reg, mask, 0);
+	if (ret)
+		dev_err(di->dev, "clr reg:0x%02x failed\n", reg);
+
+	return ret;
+}
+
+static void rk818_bat_dump_regs(struct rk818_battery *di, u8 start, u8 end)
+{
+	int i;
+
+	if (!dbg_enable)
+		return;
+
+	DBG("dump regs from: 0x%x-->0x%x\n", start, end);
+	for (i = start; i < end; i++)
+		DBG("0x%x: 0x%0x\n", i, rk818_bat_read(di, i));
+}
+
+static bool rk818_bat_chrg_online(struct rk818_battery *di)
+{
+	u8 buf;
+
+	buf = rk818_bat_read(di, RK818_VB_MON_REG);
+
+	return (buf & PLUG_IN_STS) ? true : false;
+}
+
+static int rk818_bat_get_coulomb_cap(struct rk818_battery *di)
+{
+	int val = 0;
+
+	val |= rk818_bat_read(di, RK818_GASCNT3_REG) << 24;
+	val |= rk818_bat_read(di, RK818_GASCNT2_REG) << 16;
+	val |= rk818_bat_read(di, RK818_GASCNT1_REG) << 8;
+	val |= rk818_bat_read(di, RK818_GASCNT0_REG) << 0;
+
+	return (val / 2390) * di->res_div;
+}
+
+static int rk818_bat_get_rsoc(struct rk818_battery *di)
+{
+	int remain_cap;
+
+	remain_cap = rk818_bat_get_coulomb_cap(di);
+	return (remain_cap + di->fcc / 200) * 100 / DIV(di->fcc);
+}
+
+static ssize_t bat_info_store(struct device *dev, struct device_attribute *attr,
+			      const char *buf, size_t count)
+{
+	char cmd;
+	struct rk818_battery *di = dev_get_drvdata(dev);
+
+	sscanf(buf, "%c", &cmd);
+
+	if (cmd == 'n')
+		rk818_bat_set_bits(di, RK818_MISC_MARK_REG,
+				   FG_RESET_NOW, FG_RESET_NOW);
+	else if (cmd == 'm')
+		rk818_bat_set_bits(di, RK818_MISC_MARK_REG,
+				   FG_RESET_LATE, FG_RESET_LATE);
+	else if (cmd == 'c')
+		rk818_bat_clear_bits(di, RK818_MISC_MARK_REG,
+				     FG_RESET_LATE | FG_RESET_NOW);
+	else if (cmd == 'r')
+		BAT_INFO("0x%2x\n", rk818_bat_read(di, RK818_MISC_MARK_REG));
+	else
+		BAT_INFO("command error\n");
+
+	return count;
+}
+
+static struct device_attribute rk818_bat_attr[] = {
+	__ATTR(bat, 0664, NULL, bat_info_store),
+};
+
+static void rk818_bat_enable_gauge(struct rk818_battery *di)
+{
+	u8 buf;
+
+	buf = rk818_bat_read(di, RK818_TS_CTRL_REG);
+	buf |= GG_EN;
+	rk818_bat_write(di, RK818_TS_CTRL_REG, buf);
+}
+
+static void rk818_bat_save_age_level(struct rk818_battery *di, u8 level)
+{
+	rk818_bat_write(di, RK818_UPDAT_LEVE_REG, level);
+}
+
+static u8 rk818_bat_get_age_level(struct  rk818_battery *di)
+{
+	return rk818_bat_read(di, RK818_UPDAT_LEVE_REG);
+}
+
+static int rk818_bat_get_vcalib0(struct rk818_battery *di)
+{
+	int val = 0;
+
+	val |= rk818_bat_read(di, RK818_VCALIB0_REGL) << 0;
+	val |= rk818_bat_read(di, RK818_VCALIB0_REGH) << 8;
+
+	DBG("<%s>. voffset0: 0x%x\n", __func__, val);
+	return val;
+}
+
+static int rk818_bat_get_vcalib1(struct rk818_battery *di)
+{
+	int val = 0;
+
+	val |= rk818_bat_read(di, RK818_VCALIB1_REGL) << 0;
+	val |= rk818_bat_read(di, RK818_VCALIB1_REGH) << 8;
+
+	DBG("<%s>. voffset1: 0x%x\n", __func__, val);
+	return val;
+}
+
+static int rk818_bat_get_ioffset(struct rk818_battery *di)
+{
+	int val = 0;
+
+	val |= rk818_bat_read(di, RK818_IOFFSET_REGL) << 0;
+	val |= rk818_bat_read(di, RK818_IOFFSET_REGH) << 8;
+
+	DBG("<%s>. ioffset: 0x%x\n", __func__, val);
+	return val;
+}
+
+static int rk818_bat_get_coffset(struct rk818_battery *di)
+{
+	int val = 0;
+
+	val |= rk818_bat_read(di, RK818_CAL_OFFSET_REGL) << 0;
+	val |= rk818_bat_read(di, RK818_CAL_OFFSET_REGH) << 8;
+
+	DBG("<%s>. coffset: 0x%x\n", __func__, val);
+	return val;
+}
+
+static void rk818_bat_set_coffset(struct rk818_battery *di, int val)
+{
+	u8 buf;
+
+	if ((val < INVALID_COFFSET_MIN) || (val > INVALID_COFFSET_MAX)) {
+		BAT_INFO("set invalid coffset=0x%x\n", val);
+		return;
+	}
+
+	buf = (val >> 8) & 0xff;
+	rk818_bat_write(di, RK818_CAL_OFFSET_REGH, buf);
+	buf = (val >> 0) & 0xff;
+	rk818_bat_write(di, RK818_CAL_OFFSET_REGL, buf);
+	DBG("<%s>. coffset: 0x%x\n", __func__, val);
+}
+
+static void rk818_bat_init_voltage_kb(struct rk818_battery *di)
+{
+	int vcalib0, vcalib1;
+
+	vcalib0 = rk818_bat_get_vcalib0(di);
+	vcalib1 = rk818_bat_get_vcalib1(di);
+	di->voltage_k = (4200 - 3000) * 1000 / DIV(vcalib1 - vcalib0);
+	di->voltage_b = 4200 - (di->voltage_k * vcalib1) / 1000;
+
+	DBG("voltage_k=%d(*1000),voltage_b=%d\n", di->voltage_k, di->voltage_b);
+}
+
+static int rk818_bat_get_ocv_voltage(struct rk818_battery *di)
+{
+	int vol, val = 0;
+
+	val |= rk818_bat_read(di, RK818_BAT_OCV_REGL) << 0;
+	val |= rk818_bat_read(di, RK818_BAT_OCV_REGH) << 8;
+
+	vol = di->voltage_k * val / 1000 + di->voltage_b;
+
+	return vol;
+}
+
+static int rk818_bat_get_avg_voltage(struct rk818_battery *di)
+{
+	int vol, val = 0;
+
+	val |= rk818_bat_read(di, RK818_BAT_VOL_REGL) << 0;
+	val |= rk818_bat_read(di, RK818_BAT_VOL_REGH) << 8;
+
+	vol = di->voltage_k * val / 1000 + di->voltage_b;
+
+	return vol;
+}
+
+static bool is_rk818_bat_relax_mode(struct rk818_battery *di)
+{
+	u8 status;
+
+	status = rk818_bat_read(di, RK818_GGSTS_REG);
+	if (!(status & RELAX_VOL1_UPD) || !(status & RELAX_VOL2_UPD))
+		return false;
+	else
+		return true;
+}
+
+static u16 rk818_bat_get_relax_vol1(struct rk818_battery *di)
+{
+	u16 vol, val = 0;
+
+	val |= rk818_bat_read(di, RK818_RELAX_VOL1_REGL) << 0;
+	val |= rk818_bat_read(di, RK818_RELAX_VOL1_REGH) << 8;
+	vol = di->voltage_k * val / 1000 + di->voltage_b;
+
+	return vol;
+}
+
+static u16 rk818_bat_get_relax_vol2(struct rk818_battery *di)
+{
+	u16 vol, val = 0;
+
+	val |= rk818_bat_read(di, RK818_RELAX_VOL2_REGL) << 0;
+	val |= rk818_bat_read(di, RK818_RELAX_VOL2_REGH) << 8;
+	vol = di->voltage_k * val / 1000 + di->voltage_b;
+
+	return vol;
+}
+
+static u16 rk818_bat_get_relax_voltage(struct rk818_battery *di)
+{
+	u16 relax_vol1, relax_vol2;
+
+	if (!is_rk818_bat_relax_mode(di))
+		return 0;
+
+	relax_vol1 = rk818_bat_get_relax_vol1(di);
+	relax_vol2 = rk818_bat_get_relax_vol2(di);
+
+	return relax_vol1 > relax_vol2 ? relax_vol1 : relax_vol2;
+}
+
+static int rk818_bat_get_avg_current(struct rk818_battery *di)
+{
+	int cur, val = 0;
+
+	val |= rk818_bat_read(di, RK818_BAT_CUR_AVG_REGL) << 0;
+	val |= rk818_bat_read(di, RK818_BAT_CUR_AVG_REGH) << 8;
+
+	if (val & 0x800)
+		val -= 4096;
+	cur = val * di->res_div * 1506 / 1000;
+
+	return cur;
+}
+
+static int rk818_bat_vol_to_ocvsoc(struct rk818_battery *di, int voltage)
+{
+	u32 *ocv_table, temp;
+	int ocv_size, ocv_soc;
+
+	ocv_table = di->pdata->ocv_table;
+	ocv_size = di->pdata->ocv_size;
+	temp = interpolate(voltage, ocv_table, ocv_size);
+	ocv_soc = ab_div_c(temp, MAX_PERCENTAGE, MAX_INTERPOLATE);
+
+	return ocv_soc;
+}
+
+static int rk818_bat_vol_to_ocvcap(struct rk818_battery *di, int voltage)
+{
+	u32 *ocv_table, temp;
+	int ocv_size, cap;
+
+	ocv_table = di->pdata->ocv_table;
+	ocv_size = di->pdata->ocv_size;
+	temp = interpolate(voltage, ocv_table, ocv_size);
+	cap = ab_div_c(temp, di->fcc, MAX_INTERPOLATE);
+
+	return cap;
+}
+
+static int rk818_bat_vol_to_zerosoc(struct rk818_battery *di, int voltage)
+{
+	u32 *ocv_table, temp;
+	int ocv_size, ocv_soc;
+
+	ocv_table = di->pdata->zero_table;
+	ocv_size = di->pdata->ocv_size;
+	temp = interpolate(voltage, ocv_table, ocv_size);
+	ocv_soc = ab_div_c(temp, MAX_PERCENTAGE, MAX_INTERPOLATE);
+
+	return ocv_soc;
+}
+
+static int rk818_bat_vol_to_zerocap(struct rk818_battery *di, int voltage)
+{
+	u32 *ocv_table, temp;
+	int ocv_size, cap;
+
+	ocv_table = di->pdata->zero_table;
+	ocv_size = di->pdata->ocv_size;
+	temp = interpolate(voltage, ocv_table, ocv_size);
+	cap = ab_div_c(temp, di->fcc, MAX_INTERPOLATE);
+
+	return cap;
+}
+
+static int rk818_bat_get_iadc(struct rk818_battery *di)
+{
+	int val = 0;
+
+	val |= rk818_bat_read(di, RK818_BAT_CUR_AVG_REGL) << 0;
+	val |= rk818_bat_read(di, RK818_BAT_CUR_AVG_REGH) << 8;
+	if (val > 2047)
+		val -= 4096;
+
+	return val;
+}
+
+static bool rk818_bat_adc_calib(struct rk818_battery *di)
+{
+	int i, ioffset, coffset, adc, save_coffset;
+
+	if ((di->chrg_status != CHARGE_FINISH) ||
+	    (di->adc_calib_cnt > ADC_CALIB_CNT) ||
+	    (base2min(di->boot_base) < ADC_CALIB_LMT_MIN) ||
+	    (abs(di->current_avg) < ADC_CALIB_THRESHOLD))
+		return false;
+
+	di->adc_calib_cnt++;
+	save_coffset = rk818_bat_get_coffset(di);
+	for (i = 0; i < 5; i++) {
+		adc = rk818_bat_get_iadc(di);
+		if (!rk818_bat_chrg_online(di)) {
+			rk818_bat_set_coffset(di, save_coffset);
+			BAT_INFO("quit, charger plugout when calib adc\n");
+			return false;
+		}
+		coffset = rk818_bat_get_coffset(di);
+		rk818_bat_set_coffset(di, coffset + adc);
+		msleep(2000);
+		adc = rk818_bat_get_iadc(di);
+		if (abs(adc) < ADC_CALIB_THRESHOLD) {
+			coffset = rk818_bat_get_coffset(di);
+			ioffset = rk818_bat_get_ioffset(di);
+			di->poffset = coffset - ioffset;
+			rk818_bat_write(di, RK818_POFFSET_REG, di->poffset);
+			BAT_INFO("new offset:c=0x%x, i=0x%x, p=0x%x\n",
+				 coffset, ioffset, di->poffset);
+			return true;
+		} else {
+			BAT_INFO("coffset calib again %d.., max_cnt=%d\n",
+				 i, di->adc_calib_cnt);
+			rk818_bat_set_coffset(di, coffset);
+			msleep(2000);
+		}
+	}
+
+	rk818_bat_set_coffset(di, save_coffset);
+
+	return false;
+}
+
+static void rk818_bat_set_ioffset_sample(struct rk818_battery *di)
+{
+	u8 ggcon;
+
+	ggcon = rk818_bat_read(di, RK818_GGCON_REG);
+	ggcon &= ~ADC_CAL_MIN_MSK;
+	ggcon |= ADC_CAL_8MIN;
+	rk818_bat_write(di, RK818_GGCON_REG, ggcon);
+}
+
+static void rk818_bat_set_ocv_sample(struct rk818_battery *di)
+{
+	u8 ggcon;
+
+	ggcon = rk818_bat_read(di, RK818_GGCON_REG);
+	ggcon &= ~OCV_SAMP_MIN_MSK;
+	ggcon |= OCV_SAMP_8MIN;
+	rk818_bat_write(di, RK818_GGCON_REG, ggcon);
+}
+
+static void rk818_bat_restart_relax(struct rk818_battery *di)
+{
+	u8 ggsts;
+
+	ggsts = rk818_bat_read(di, RK818_GGSTS_REG);
+	ggsts &= ~RELAX_VOL12_UPD_MSK;
+	rk818_bat_write(di, RK818_GGSTS_REG, ggsts);
+}
+
+static void rk818_bat_set_relax_sample(struct rk818_battery *di)
+{
+	u8 buf;
+	int enter_thres, exit_thres;
+	struct battery_platform_data *pdata = di->pdata;
+
+	enter_thres = pdata->sleep_enter_current * 1000 / 1506 / DIV(di->res_div);
+	exit_thres = pdata->sleep_exit_current * 1000 / 1506 / DIV(di->res_div);
+
+	/* set relax enter and exit threshold */
+	buf = enter_thres & 0xff;
+	rk818_bat_write(di, RK818_RELAX_ENTRY_THRES_REGL, buf);
+	buf = (enter_thres >> 8) & 0xff;
+	rk818_bat_write(di, RK818_RELAX_ENTRY_THRES_REGH, buf);
+
+	buf = exit_thres & 0xff;
+	rk818_bat_write(di, RK818_RELAX_EXIT_THRES_REGL, buf);
+	buf = (exit_thres >> 8) & 0xff;
+	rk818_bat_write(di, RK818_RELAX_EXIT_THRES_REGH, buf);
+
+	/* reset relax update state */
+	rk818_bat_restart_relax(di);
+	DBG("<%s>. sleep_enter_current = %d, sleep_exit_current = %d\n",
+	    __func__, pdata->sleep_enter_current, pdata->sleep_exit_current);
+}
+
+static bool is_rk818_bat_exist(struct rk818_battery *di)
+{
+	return (rk818_bat_read(di, RK818_SUP_STS_REG) & BAT_EXS) ? true : false;
+}
+
+static bool is_rk818_bat_first_pwron(struct rk818_battery *di)
+{
+	u8 buf;
+
+	buf = rk818_bat_read(di, RK818_GGSTS_REG);
+	if (buf & BAT_CON) {
+		buf &= ~BAT_CON;
+		rk818_bat_write(di, RK818_GGSTS_REG, buf);
+		return true;
+	}
+
+	return false;
+}
+
+static u8 rk818_bat_get_pwroff_min(struct rk818_battery *di)
+{
+	u8 cur, last;
+
+	cur = rk818_bat_read(di, RK818_NON_ACT_TIMER_CNT_REG);
+	last = rk818_bat_read(di, RK818_NON_ACT_TIMER_CNT_SAVE_REG);
+	rk818_bat_write(di, RK818_NON_ACT_TIMER_CNT_SAVE_REG, cur);
+
+	return (cur != last) ? cur : 0;
+}
+
+static u8 is_rk818_bat_initialized(struct rk818_battery *di)
+{
+	u8 val = rk818_bat_read(di, RK818_MISC_MARK_REG);
+
+	if (val & FG_INIT) {
+		val &= ~FG_INIT;
+		rk818_bat_write(di, RK818_MISC_MARK_REG, val);
+		return true;
+	} else {
+		return false;
+	}
+}
+
+static bool is_rk818_bat_ocv_valid(struct rk818_battery *di)
+{
+	return (!di->is_initialized && di->pwroff_min >= 30) ? true : false;
+}
+
+static void rk818_bat_init_age_algorithm(struct rk818_battery *di)
+{
+	int age_level, ocv_soc, ocv_cap, ocv_vol;
+
+	if (di->is_first_power_on || is_rk818_bat_ocv_valid(di)) {
+		DBG("<%s> enter.\n", __func__);
+		ocv_vol = rk818_bat_get_ocv_voltage(di);
+		ocv_soc = rk818_bat_vol_to_ocvsoc(di, ocv_vol);
+		ocv_cap = rk818_bat_vol_to_ocvcap(di, ocv_vol);
+		if (ocv_soc < 20) {
+			di->age_voltage = ocv_vol;
+			di->age_ocv_cap = ocv_cap;
+			di->age_ocv_soc = ocv_soc;
+			di->age_adjust_cap = 0;
+
+			if (ocv_soc <= 0)
+				di->age_level = 100;
+			else if (ocv_soc < 5)
+				di->age_level = 95;
+			else if (ocv_soc < 10)
+				di->age_level = 90;
+			else
+				di->age_level = 80;
+
+			age_level = rk818_bat_get_age_level(di);
+			if (age_level > di->age_level) {
+				di->age_allow_update = false;
+				age_level -= 5;
+				if (age_level <= 80)
+					age_level = 80;
+				rk818_bat_save_age_level(di, age_level);
+			} else {
+				di->age_allow_update = true;
+				di->age_keep_sec = get_boot_sec();
+			}
+
+			BAT_INFO("init_age_algorithm: "
+				 "age_vol:%d, age_ocv_cap:%d, "
+				 "age_ocv_soc:%d, old_age_level:%d, "
+				 "age_allow_update:%d, new_age_level:%d\n",
+				 di->age_voltage, di->age_ocv_cap,
+				 ocv_soc, age_level, di->age_allow_update,
+				 di->age_level);
+		}
+	}
+}
+
+static enum power_supply_property rk818_bat_props[] = {
+	POWER_SUPPLY_PROP_CURRENT_NOW,
+	POWER_SUPPLY_PROP_VOLTAGE_NOW,
+	POWER_SUPPLY_PROP_PRESENT,
+	POWER_SUPPLY_PROP_HEALTH,
+	POWER_SUPPLY_PROP_CAPACITY,
+	POWER_SUPPLY_PROP_TEMP,
+	POWER_SUPPLY_PROP_STATUS,
+	POWER_SUPPLY_PROP_CHARGE_COUNTER,
+	POWER_SUPPLY_PROP_CHARGE_FULL,
+	POWER_SUPPLY_PROP_VOLTAGE_MAX,
+	POWER_SUPPLY_PROP_CURRENT_MAX,
+};
+
+static int rk818_bat_get_usb_psy(struct device *dev, void *data)
+{
+	struct rk818_battery *di = data;
+	struct power_supply *psy = dev_get_drvdata(dev);
+
+	if (psy->desc->type == POWER_SUPPLY_TYPE_USB) {
+		di->usb_psy = psy;
+		return 1;
+	}
+
+	return 0;
+}
+
+static int rk818_bat_get_ac_psy(struct device *dev, void *data)
+{
+	struct rk818_battery *di = data;
+	struct power_supply *psy = dev_get_drvdata(dev);
+
+	if (psy->desc->type == POWER_SUPPLY_TYPE_MAINS) {
+		di->ac_psy = psy;
+		return 1;
+	}
+
+	return 0;
+}
+
+static void rk818_bat_get_chrg_psy(struct rk818_battery *di)
+{
+	if (!di->usb_psy)
+		class_for_each_device(power_supply_class, NULL, (void *)di,
+				      rk818_bat_get_usb_psy);
+	if (!di->ac_psy)
+		class_for_each_device(power_supply_class, NULL, (void *)di,
+				      rk818_bat_get_ac_psy);
+}
+
+static int rk818_bat_get_charge_state(struct rk818_battery *di)
+{
+	union power_supply_propval val;
+	int ret;
+
+	if (!di->usb_psy || !di->ac_psy)
+		rk818_bat_get_chrg_psy(di);
+
+	if (di->usb_psy) {
+		ret = di->usb_psy->desc->get_property(di->usb_psy,
+						      POWER_SUPPLY_PROP_ONLINE,
+						      &val);
+		if (!ret)
+			di->usb_in = val.intval;
+	}
+
+	if (di->ac_psy) {
+		ret = di->ac_psy->desc->get_property(di->ac_psy,
+						     POWER_SUPPLY_PROP_ONLINE,
+						     &val);
+		if (!ret)
+			di->ac_in = val.intval;
+	}
+
+	DBG("%s: ac_online=%d, usb_online=%d\n",
+	    __func__, di->ac_in, di->usb_in);
+
+	return (di->usb_in || di->ac_in);
+}
+
+static int rk818_battery_get_property(struct power_supply *psy,
+				      enum power_supply_property psp,
+				      union power_supply_propval *val)
+{
+	struct rk818_battery *di = power_supply_get_drvdata(psy);
+
+	switch (psp) {
+	case POWER_SUPPLY_PROP_CURRENT_NOW:
+		val->intval = di->current_avg * 1000;/*uA*/
+		if (di->pdata->bat_mode == MODE_VIRTUAL)
+			val->intval = VIRTUAL_CURRENT * 1000;
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_NOW:
+		val->intval = di->voltage_avg * 1000;/*uV*/
+		if (di->pdata->bat_mode == MODE_VIRTUAL)
+			val->intval = VIRTUAL_VOLTAGE * 1000;
+		break;
+	case POWER_SUPPLY_PROP_PRESENT:
+		val->intval = is_rk818_bat_exist(di);
+		if (di->pdata->bat_mode == MODE_VIRTUAL)
+			val->intval = VIRTUAL_PRESET;
+		break;
+	case POWER_SUPPLY_PROP_CAPACITY:
+		val->intval = di->dsoc;
+		if (di->pdata->bat_mode == MODE_VIRTUAL)
+			val->intval = VIRTUAL_SOC;
+		DBG("<%s>. report dsoc: %d\n", __func__, val->intval);
+		break;
+	case POWER_SUPPLY_PROP_HEALTH:
+		val->intval = POWER_SUPPLY_HEALTH_GOOD;
+		break;
+	case POWER_SUPPLY_PROP_TEMP:
+		val->intval = di->temperature;
+		if (di->pdata->bat_mode == MODE_VIRTUAL)
+			val->intval = VIRTUAL_TEMPERATURE;
+		break;
+	case POWER_SUPPLY_PROP_STATUS:
+		if (di->pdata->bat_mode == MODE_VIRTUAL)
+			val->intval = VIRTUAL_STATUS;
+		else if (di->dsoc == 100)
+			val->intval = POWER_SUPPLY_STATUS_FULL;
+		else if (rk818_bat_get_charge_state(di))
+			val->intval = POWER_SUPPLY_STATUS_CHARGING;
+		else
+			val->intval = POWER_SUPPLY_STATUS_DISCHARGING;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_COUNTER:
+		val->intval = di->charge_count;
+		break;
+	case POWER_SUPPLY_PROP_CHARGE_FULL:
+		val->intval = di->pdata->design_capacity * 1000;/* uAh */
+		break;
+	case POWER_SUPPLY_PROP_VOLTAGE_MAX:
+		val->intval = di->voltage_max * 1000;	/* uV */
+		break;
+	case POWER_SUPPLY_PROP_CURRENT_MAX:
+		val->intval = di->current_max * 1000;	/* uA */
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static const struct power_supply_desc rk818_bat_desc = {
+	.name		= "battery",
+	.type		= POWER_SUPPLY_TYPE_BATTERY,
+	.properties	= rk818_bat_props,
+	.num_properties	= ARRAY_SIZE(rk818_bat_props),
+	.get_property	= rk818_battery_get_property,
+};
+
+static int rk818_bat_init_power_supply(struct rk818_battery *di)
+{
+	struct power_supply_config psy_cfg = { .drv_data = di, };
+
+	di->bat = devm_power_supply_register(di->dev, &rk818_bat_desc, &psy_cfg);
+	if (IS_ERR(di->bat)) {
+		dev_err(di->dev, "register bat power supply fail\n");
+		return PTR_ERR(di->bat);
+	}
+
+	return 0;
+}
+
+static void rk818_bat_save_cap(struct rk818_battery *di, int cap)
+{
+	u8 buf;
+	static u32 old_cap;
+
+	if (cap >= di->qmax)
+		cap = di->qmax;
+	if (cap <= 0)
+		cap = 0;
+	if (old_cap == cap)
+		return;
+
+	old_cap = cap;
+	buf = (cap >> 24) & 0xff;
+	rk818_bat_write(di, RK818_REMAIN_CAP_REG3, buf);
+	buf = (cap >> 16) & 0xff;
+	rk818_bat_write(di, RK818_REMAIN_CAP_REG2, buf);
+	buf = (cap >> 8) & 0xff;
+	rk818_bat_write(di, RK818_REMAIN_CAP_REG1, buf);
+	buf = (cap >> 0) & 0xff;
+	rk818_bat_write(di, RK818_REMAIN_CAP_REG0, buf);
+}
+
+static int rk818_bat_get_prev_cap(struct rk818_battery *di)
+{
+	int val = 0;
+
+	val |= rk818_bat_read(di, RK818_REMAIN_CAP_REG3) << 24;
+	val |= rk818_bat_read(di, RK818_REMAIN_CAP_REG2) << 16;
+	val |= rk818_bat_read(di, RK818_REMAIN_CAP_REG1) << 8;
+	val |= rk818_bat_read(di, RK818_REMAIN_CAP_REG0) << 0;
+
+	return val;
+}
+
+static void rk818_bat_save_fcc(struct rk818_battery *di, u32 fcc)
+{
+	u8 buf;
+
+	buf = (fcc >> 24) & 0xff;
+	rk818_bat_write(di, RK818_NEW_FCC_REG3, buf);
+	buf = (fcc >> 16) & 0xff;
+	rk818_bat_write(di, RK818_NEW_FCC_REG2, buf);
+	buf = (fcc >> 8) & 0xff;
+	rk818_bat_write(di, RK818_NEW_FCC_REG1, buf);
+	buf = (fcc >> 0) & 0xff;
+	rk818_bat_write(di, RK818_NEW_FCC_REG0, buf);
+
+	BAT_INFO("save fcc: %d\n", fcc);
+}
+
+static int rk818_bat_get_fcc(struct rk818_battery *di)
+{
+	u32 fcc = 0;
+
+	fcc |= rk818_bat_read(di, RK818_NEW_FCC_REG3) << 24;
+	fcc |= rk818_bat_read(di, RK818_NEW_FCC_REG2) << 16;
+	fcc |= rk818_bat_read(di, RK818_NEW_FCC_REG1) << 8;
+	fcc |= rk818_bat_read(di, RK818_NEW_FCC_REG0) << 0;
+
+	if (fcc < MIN_FCC) {
+		BAT_INFO("invalid fcc(%d), use design cap", fcc);
+		fcc = di->pdata->design_capacity;
+		rk818_bat_save_fcc(di, fcc);
+	} else if (fcc > di->pdata->design_qmax) {
+		BAT_INFO("invalid fcc(%d), use qmax", fcc);
+		fcc = di->pdata->design_qmax;
+		rk818_bat_save_fcc(di, fcc);
+	}
+
+	return fcc;
+}
+
+static void rk818_bat_init_coulomb_cap(struct rk818_battery *di, u32 capacity)
+{
+	u8 buf;
+	u32 cap;
+
+	cap = capacity * 2390 / DIV(di->res_div);
+	buf = (cap >> 24) & 0xff;
+	rk818_bat_write(di, RK818_GASCNT_CAL_REG3, buf);
+	buf = (cap >> 16) & 0xff;
+	rk818_bat_write(di, RK818_GASCNT_CAL_REG2, buf);
+	buf = (cap >> 8) & 0xff;
+	rk818_bat_write(di, RK818_GASCNT_CAL_REG1, buf);
+	buf = ((cap >> 0) & 0xff);
+	rk818_bat_write(di, RK818_GASCNT_CAL_REG0, buf);
+
+	DBG("<%s>. new coulomb cap = %d\n", __func__, capacity);
+	di->remain_cap = capacity;
+	di->rsoc = rk818_bat_get_rsoc(di);
+}
+
+static void rk818_bat_save_dsoc(struct rk818_battery *di, u8 save_soc)
+{
+	static int last_soc = -1;
+
+	if (last_soc != save_soc) {
+		rk818_bat_write(di, RK818_SOC_REG, save_soc);
+		last_soc = save_soc;
+	}
+}
+
+static int rk818_bat_get_prev_dsoc(struct rk818_battery *di)
+{
+	return rk818_bat_read(di, RK818_SOC_REG);
+}
+
+static void rk818_bat_save_reboot_cnt(struct rk818_battery *di, u8 save_cnt)
+{
+	rk818_bat_write(di, RK818_REBOOT_CNT_REG, save_cnt);
+}
+
+static int rk818_bat_fb_notifier(struct notifier_block *nb,
+				 unsigned long event, void *data)
+{
+	struct rk818_battery *di;
+	struct fb_event *evdata = data;
+
+	if (event != FB_EARLY_EVENT_BLANK && event != FB_EVENT_BLANK)
+		return NOTIFY_OK;
+
+	di = container_of(nb, struct rk818_battery, fb_nb);
+	di->fb_blank = *(int *)evdata->data;
+
+	return 0;
+}
+
+static int rk818_bat_register_fb_notify(struct rk818_battery *di)
+{
+	memset(&di->fb_nb, 0, sizeof(di->fb_nb));
+	di->fb_nb.notifier_call = rk818_bat_fb_notifier;
+
+	return fb_register_client(&di->fb_nb);
+}
+
+static int rk818_bat_unregister_fb_notify(struct rk818_battery *di)
+{
+	return fb_unregister_client(&di->fb_nb);
+}
+
+static u8 rk818_bat_get_halt_cnt(struct rk818_battery *di)
+{
+	return rk818_bat_read(di, RK818_HALT_CNT_REG);
+}
+
+static void rk818_bat_inc_halt_cnt(struct rk818_battery *di)
+{
+	u8 cnt;
+
+	cnt = rk818_bat_read(di, RK818_HALT_CNT_REG);
+	rk818_bat_write(di, RK818_HALT_CNT_REG, ++cnt);
+}
+
+static bool is_rk818_bat_last_halt(struct rk818_battery *di)
+{
+	int pre_cap = rk818_bat_get_prev_cap(di);
+	int now_cap = rk818_bat_get_coulomb_cap(di);
+
+	/* over 10%: system halt last time */
+	if (abs(now_cap - pre_cap) > (di->fcc / 10)) {
+		rk818_bat_inc_halt_cnt(di);
+		return true;
+	} else {
+		return false;
+	}
+}
+
+static void rk818_bat_first_pwron(struct rk818_battery *di)
+{
+	int ocv_vol;
+
+	rk818_bat_save_fcc(di, di->design_cap);
+	ocv_vol = rk818_bat_get_ocv_voltage(di);
+	di->fcc = rk818_bat_get_fcc(di);
+	di->nac = rk818_bat_vol_to_ocvcap(di, ocv_vol);
+	di->rsoc = rk818_bat_vol_to_ocvsoc(di, ocv_vol);
+	di->dsoc = di->rsoc;
+	di->is_first_on = true;
+
+	BAT_INFO("first on: dsoc=%d, rsoc=%d cap=%d, fcc=%d, ov=%d\n",
+		 di->dsoc, di->rsoc, di->nac, di->fcc, ocv_vol);
+}
+
+static void rk818_bat_not_first_pwron(struct rk818_battery *di)
+{
+	int now_cap, pre_soc, pre_cap, ocv_cap, ocv_soc, ocv_vol;
+
+	di->fcc = rk818_bat_get_fcc(di);
+	pre_soc = rk818_bat_get_prev_dsoc(di);
+	pre_cap = rk818_bat_get_prev_cap(di);
+	now_cap = rk818_bat_get_coulomb_cap(di);
+	di->is_halt = is_rk818_bat_last_halt(di);
+	di->halt_cnt = rk818_bat_get_halt_cnt(di);
+	di->is_initialized = is_rk818_bat_initialized(di);
+	di->is_ocv_calib = is_rk818_bat_ocv_valid(di);
+
+	if (di->is_initialized) {
+		BAT_INFO("initialized yet..\n");
+		goto finish;
+	} else if (di->is_halt) {
+		BAT_INFO("system halt last time... cap: pre=%d, now=%d\n",
+			 pre_cap, now_cap);
+		if (now_cap < 0)
+			now_cap = 0;
+		rk818_bat_init_coulomb_cap(di, now_cap);
+		pre_cap = now_cap;
+		pre_soc = di->rsoc;
+		goto finish;
+	} else if (di->is_ocv_calib) {
+		ocv_vol = rk818_bat_get_ocv_voltage(di);
+		ocv_soc = rk818_bat_vol_to_ocvsoc(di, ocv_vol);
+		ocv_cap = rk818_bat_vol_to_ocvcap(di, ocv_vol);
+		pre_cap = ocv_cap;
+		di->ocv_pre_dsoc = pre_soc;
+		di->ocv_new_dsoc = ocv_soc;
+		if (abs(ocv_soc - pre_soc) >= di->pdata->max_soc_offset) {
+			di->ocv_pre_dsoc = pre_soc;
+			di->ocv_new_dsoc = ocv_soc;
+			di->is_max_soc_offset = true;
+			BAT_INFO("trigger max soc offset, dsoc: %d -> %d\n",
+				 pre_soc, ocv_soc);
+			pre_soc = ocv_soc;
+		}
+		BAT_INFO("OCV calib: cap=%d, rsoc=%d\n", ocv_cap, ocv_soc);
+	} else if (di->pwroff_min > 0) {
+		ocv_vol = rk818_bat_get_ocv_voltage(di);
+		ocv_soc = rk818_bat_vol_to_ocvsoc(di, ocv_vol);
+		ocv_cap = rk818_bat_vol_to_ocvcap(di, ocv_vol);
+		di->force_pre_dsoc = pre_soc;
+		di->force_new_dsoc = ocv_soc;
+		if (abs(ocv_soc - pre_soc) >= 80) {
+			di->is_force_calib = true;
+			BAT_INFO("dsoc force calib: %d -> %d\n",
+				 pre_soc, ocv_soc);
+			pre_soc = ocv_soc;
+			pre_cap = ocv_cap;
+		}
+	}
+
+finish:
+	di->dsoc = pre_soc;
+	di->nac = pre_cap;
+	if (di->nac < 0)
+		di->nac = 0;
+
+	BAT_INFO("dsoc=%d cap=%d v=%d ov=%d rv=%d min=%d psoc=%d pcap=%d\n",
+		 di->dsoc, di->nac, rk818_bat_get_avg_voltage(di),
+		 rk818_bat_get_ocv_voltage(di), rk818_bat_get_relax_voltage(di),
+		 di->pwroff_min, rk818_bat_get_prev_dsoc(di),
+		 rk818_bat_get_prev_cap(di));
+}
+
+static bool rk818_bat_ocv_sw_reset(struct rk818_battery *di)
+{
+	u8 buf;
+
+	buf = rk818_bat_read(di, RK818_MISC_MARK_REG);
+	if (((buf & FG_RESET_LATE) && di->pwroff_min >= 30) ||
+	    (buf & FG_RESET_NOW)) {
+		buf &= ~FG_RESET_LATE;
+		buf &= ~FG_RESET_NOW;
+		rk818_bat_write(di, RK818_MISC_MARK_REG, buf);
+		BAT_INFO("manual reset fuel gauge\n");
+		return true;
+	} else {
+		return false;
+	}
+}
+
+static void rk818_bat_init_rsoc(struct rk818_battery *di)
+{
+	di->is_first_power_on = is_rk818_bat_first_pwron(di);
+	di->is_sw_reset = rk818_bat_ocv_sw_reset(di);
+	di->pwroff_min = rk818_bat_get_pwroff_min(di);
+
+	if (di->is_first_power_on || di->is_sw_reset)
+		rk818_bat_first_pwron(di);
+	else
+		rk818_bat_not_first_pwron(di);
+}
+
+static u8 rk818_bat_get_chrg_status(struct rk818_battery *di)
+{
+	u8 status;
+
+	status = rk818_bat_read(di, RK818_SUP_STS_REG) & CHRG_STATUS_MSK;
+	switch (status) {
+	case CHARGE_OFF:
+		DBG("CHARGE-OFF ...\n");
+		break;
+	case DEAD_CHARGE:
+		BAT_INFO("DEAD CHARGE...\n");
+		break;
+	case TRICKLE_CHARGE:
+		BAT_INFO("TRICKLE CHARGE...\n ");
+		break;
+	case CC_OR_CV:
+		DBG("CC or CV...\n");
+		break;
+	case CHARGE_FINISH:
+		DBG("CHARGE FINISH...\n");
+		break;
+	case USB_OVER_VOL:
+		BAT_INFO("USB OVER VOL...\n");
+		break;
+	case BAT_TMP_ERR:
+		BAT_INFO("BAT TMP ERROR...\n");
+		break;
+	case TIMER_ERR:
+		BAT_INFO("TIMER ERROR...\n");
+		break;
+	case USB_EXIST:
+		BAT_INFO("USB EXIST...\n");
+		break;
+	case USB_EFF:
+		BAT_INFO("USB EFF...\n");
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return status;
+}
+
+static u8 rk818_bat_parse_fb_temperature(struct rk818_battery *di)
+{
+	u8 reg;
+	int index, fb_temp;
+
+	reg = DEFAULT_FB_TEMP;
+	fb_temp = di->pdata->fb_temp;
+	for (index = 0; index < ARRAY_SIZE(feedback_temp_array); index++) {
+		if (fb_temp < feedback_temp_array[index])
+			break;
+		reg = (index << FB_TEMP_SHIFT);
+	}
+
+	return reg;
+}
+
+static u8 rk818_bat_parse_finish_ma(struct rk818_battery *di, int fcc)
+{
+	u8 ma;
+
+	if (di->pdata->sample_res == SAMPLE_RES_10MR)
+		ma = FINISH_100MA;
+	else if (fcc > 5000)
+		ma = FINISH_250MA;
+	else if (fcc >= 4000)
+		ma = FINISH_200MA;
+	else if (fcc >= 3000)
+		ma = FINISH_150MA;
+	else
+		ma = FINISH_100MA;
+
+	return ma;
+}
+
+static void rk818_bat_init_chrg_config(struct rk818_battery *di)
+{
+	u8 usb_ctrl, chrg_ctrl2, chrg_ctrl3;
+	u8 thermal, ggcon, finish_ma, fb_temp;
+
+	finish_ma = rk818_bat_parse_finish_ma(di, di->fcc);
+	fb_temp = rk818_bat_parse_fb_temperature(di);
+
+	ggcon = rk818_bat_read(di, RK818_GGCON_REG);
+	thermal = rk818_bat_read(di, RK818_THERMAL_REG);
+	usb_ctrl = rk818_bat_read(di, RK818_USB_CTRL_REG);
+	chrg_ctrl2 = rk818_bat_read(di, RK818_CHRG_CTRL_REG2);
+	chrg_ctrl3 = rk818_bat_read(di, RK818_CHRG_CTRL_REG3);
+
+	/* set charge finish current */
+	chrg_ctrl3 |= CHRG_TERM_DIG_SIGNAL;
+	chrg_ctrl2 &= ~FINISH_CUR_MSK;
+	chrg_ctrl2 |= finish_ma;
+
+	/* disable cccv mode */
+	chrg_ctrl3 &= ~CHRG_TIMER_CCCV_EN;
+
+	/* set feed back temperature */
+	if (di->pdata->fb_temp)
+		usb_ctrl |= CHRG_CT_EN;
+	else
+		usb_ctrl &= ~CHRG_CT_EN;
+	thermal &= ~FB_TEMP_MSK;
+	thermal |= fb_temp;
+
+	/* adc current mode */
+	ggcon |= ADC_CUR_MODE;
+
+	rk818_bat_write(di, RK818_GGCON_REG, ggcon);
+	rk818_bat_write(di, RK818_THERMAL_REG, thermal);
+	rk818_bat_write(di, RK818_USB_CTRL_REG, usb_ctrl);
+	rk818_bat_write(di, RK818_CHRG_CTRL_REG2, chrg_ctrl2);
+	rk818_bat_write(di, RK818_CHRG_CTRL_REG3, chrg_ctrl3);
+}
+
+static void rk818_bat_init_coffset(struct rk818_battery *di)
+{
+	int coffset, ioffset;
+
+	ioffset = rk818_bat_get_ioffset(di);
+	di->poffset = rk818_bat_read(di, RK818_POFFSET_REG);
+	if (!di->poffset)
+		di->poffset = DEFAULT_POFFSET;
+
+	coffset = di->poffset + ioffset;
+	if (coffset < INVALID_COFFSET_MIN || coffset > INVALID_COFFSET_MAX)
+		coffset = DEFAULT_COFFSET;
+
+	rk818_bat_set_coffset(di, coffset);
+
+	DBG("<%s>. offset: p=0x%x, i=0x%x, c=0x%x\n",
+	    __func__, di->poffset, ioffset, rk818_bat_get_coffset(di));
+}
+
+static void rk818_bat_caltimer_isr(struct timer_list *t)
+{
+	struct rk818_battery *di = from_timer(di, t, caltimer);
+
+	mod_timer(&di->caltimer, jiffies + MINUTE(8) * HZ);
+	queue_delayed_work(di->bat_monitor_wq, &di->calib_delay_work,
+			   msecs_to_jiffies(10));
+}
+
+static void rk818_bat_internal_calib(struct work_struct *work)
+{
+	int ioffset, poffset;
+	struct rk818_battery *di = container_of(work,
+			struct rk818_battery, calib_delay_work.work);
+
+	/* calib coffset */
+	poffset = rk818_bat_read(di, RK818_POFFSET_REG);
+	if (poffset)
+		di->poffset = poffset;
+	else
+		di->poffset = DEFAULT_POFFSET;
+
+	ioffset = rk818_bat_get_ioffset(di);
+	rk818_bat_set_coffset(di, ioffset + di->poffset);
+
+	/* calib voltage kb */
+	rk818_bat_init_voltage_kb(di);
+	BAT_INFO("caltimer: ioffset=0x%x, coffset=0x%x, poffset=%d\n",
+		 ioffset, rk818_bat_get_coffset(di), di->poffset);
+}
+
+static void rk818_bat_init_caltimer(struct rk818_battery *di)
+{
+	timer_setup(&di->caltimer, rk818_bat_caltimer_isr, 0);
+	di->caltimer.expires = jiffies + MINUTE(8) * HZ;
+	add_timer(&di->caltimer);
+	INIT_DELAYED_WORK(&di->calib_delay_work, rk818_bat_internal_calib);
+}
+
+static void rk818_bat_init_zero_table(struct rk818_battery *di)
+{
+	int i, diff, min, max;
+	size_t ocv_size, length;
+
+	ocv_size = di->pdata->ocv_size;
+	length = sizeof(di->pdata->zero_table) * ocv_size;
+	di->pdata->zero_table =
+			devm_kzalloc(di->dev, length, GFP_KERNEL);
+	if (!di->pdata->zero_table) {
+		di->pdata->zero_table = di->pdata->ocv_table;
+		dev_err(di->dev, "malloc zero table fail\n");
+		return;
+	}
+
+	min = di->pdata->pwroff_vol,
+	max = di->pdata->ocv_table[ocv_size - 4];
+	diff = (max - min) / DIV(ocv_size - 1);
+	for (i = 0; i < ocv_size; i++)
+		di->pdata->zero_table[i] = min + (i * diff);
+
+	for (i = 0; i < ocv_size; i++)
+		DBG("zero[%d] = %d\n", i, di->pdata->zero_table[i]);
+
+	for (i = 0; i < ocv_size; i++)
+		DBG("ocv[%d] = %d\n", i, di->pdata->ocv_table[i]);
+}
+
+static void rk818_bat_calc_sm_linek(struct rk818_battery *di)
+{
+	int linek, current_avg;
+	u8 diff, delta;
+
+	delta = abs(di->dsoc - di->rsoc);
+	diff = delta * 3;/* speed:3/4 */
+	current_avg = rk818_bat_get_avg_current(di);
+	if (current_avg >= 0) {
+		if (di->dsoc < di->rsoc)
+			linek = 1000 * (delta + diff) / DIV(diff);
+		else if (di->dsoc > di->rsoc)
+			linek = 1000 * diff / DIV(delta + diff);
+		else
+			linek = 1000;
+		di->dbg_meet_soc = (di->dsoc >= di->rsoc) ?
+				   (di->dsoc + diff) : (di->rsoc + diff);
+	} else {
+		if (di->dsoc < di->rsoc)
+			linek = -1000 * diff / DIV(delta + diff);
+		else if (di->dsoc > di->rsoc)
+			linek = -1000 * (delta + diff) / DIV(diff);
+		else
+			linek = -1000;
+		di->dbg_meet_soc = (di->dsoc >= di->rsoc) ?
+				   (di->dsoc - diff) : (di->rsoc - diff);
+	}
+
+	di->sm_linek = linek;
+	di->sm_remain_cap = di->remain_cap;
+	di->dbg_calc_dsoc = di->dsoc;
+	di->dbg_calc_rsoc = di->rsoc;
+
+	DBG("<%s>.diff=%d, k=%d, cur=%d\n", __func__, diff, linek, current_avg);
+}
+
+static void rk818_bat_calc_zero_linek(struct rk818_battery *di)
+{
+	int dead_voltage, ocv_voltage;
+	int voltage_avg, current_avg, vsys;
+	int ocv_cap, dead_cap, xsoc;
+	int ocv_soc, dead_soc;
+	int pwroff_vol;
+	int i, cnt, vol_old, vol_now;
+	int org_linek = 0, min_gap_xsoc;
+
+	if ((abs(di->current_avg) < 500) && (di->dsoc > 10))
+		pwroff_vol = di->pdata->pwroff_vol + 50;
+	else
+		pwroff_vol = di->pdata->pwroff_vol;
+
+	do {
+		vol_old = rk818_bat_get_avg_voltage(di);
+		msleep(100);
+		vol_now = rk818_bat_get_avg_voltage(di);
+		cnt++;
+	} while ((vol_old == vol_now) && (cnt < 11));
+
+	voltage_avg = 0;
+	for (i = 0; i < 10; i++) {
+		voltage_avg += rk818_bat_get_avg_voltage(di);
+		msleep(100);
+	}
+
+	/* calc estimate ocv voltage */
+	voltage_avg /= 10;
+	current_avg = rk818_bat_get_avg_current(di);
+	vsys = voltage_avg + (current_avg * DEF_PWRPATH_RES) / 1000;
+
+	DBG("ZERO0: shtd_vol: org = %d, now = %d, zero_reserve_dsoc = %d\n",
+	    di->pdata->pwroff_vol, pwroff_vol, di->pdata->zero_reserve_dsoc);
+
+	dead_voltage = pwroff_vol - current_avg *
+				(di->bat_res + DEF_PWRPATH_RES) / 1000;
+	ocv_voltage = voltage_avg - (current_avg * di->bat_res) / 1000;
+	DBG("ZERO0: dead_voltage(shtd) = %d, ocv_voltage(now) = %d\n",
+	    dead_voltage, ocv_voltage);
+
+	/* calc estimate soc and cap */
+	dead_soc = rk818_bat_vol_to_zerosoc(di, dead_voltage);
+	dead_cap = rk818_bat_vol_to_zerocap(di, dead_voltage);
+	DBG("ZERO0: dead_soc = %d, dead_cap = %d\n",
+	    dead_soc, dead_cap);
+
+	ocv_soc = rk818_bat_vol_to_zerosoc(di, ocv_voltage);
+	ocv_cap = rk818_bat_vol_to_zerocap(di, ocv_voltage);
+	DBG("ZERO0: ocv_soc = %d, ocv_cap = %d\n",
+	    ocv_soc, ocv_cap);
+
+	/* xsoc: available rsoc */
+	xsoc = ocv_soc - dead_soc;
+
+	/* min_gap_xsoc: reserve xsoc */
+	if (abs(current_avg) > ZERO_LOAD_LVL1)
+		min_gap_xsoc = ZERO_GAP_XSOC3;
+	else if (abs(current_avg) > ZERO_LOAD_LVL2)
+		min_gap_xsoc = ZERO_GAP_XSOC2;
+	else
+		min_gap_xsoc = ZERO_GAP_XSOC1;
+
+	if ((xsoc <= 30) && (di->dsoc >= di->pdata->zero_reserve_dsoc))
+		min_gap_xsoc = min_gap_xsoc + ZERO_GAP_CALIB;
+
+	di->zero_remain_cap = di->remain_cap;
+	di->zero_timeout_cnt = 0;
+	if ((di->dsoc <= 1) && (xsoc > 0)) {
+		di->zero_linek = 400;
+		di->zero_drop_sec = 0;
+	} else if (xsoc >= 0) {
+		di->zero_drop_sec = 0;
+		di->zero_linek = (di->zero_dsoc + xsoc / 2) / DIV(xsoc);
+		org_linek = di->zero_linek;
+		/* battery energy mode to use up voltage */
+		if ((di->pdata->energy_mode) &&
+		    (xsoc - di->dsoc >= ZERO_GAP_XSOC3) &&
+		    (di->dsoc <= 10) && (di->zero_linek < 300)) {
+			di->zero_linek = 300;
+			DBG("ZERO-new: zero_linek adjust step0...\n");
+		/* reserve enough power yet, slow down any way */
+		} else if ((xsoc - di->dsoc >= min_gap_xsoc) ||
+			   ((xsoc - di->dsoc >= ZERO_GAP_XSOC2) &&
+			    (di->dsoc <= 10) && (xsoc > 15))) {
+			if (xsoc <= 20 &&
+			    di->dsoc >= di->pdata->zero_reserve_dsoc)
+				di->zero_linek = 1200;
+			else if (xsoc - di->dsoc >= 2 * min_gap_xsoc)
+				di->zero_linek = 400;
+			else if (xsoc - di->dsoc >= 3 + min_gap_xsoc)
+				di->zero_linek = 600;
+			else
+				di->zero_linek = 800;
+			DBG("ZERO-new: zero_linek adjust step1...\n");
+		/* control zero mode beginning enter */
+		} else if ((di->zero_linek > 1800) && (di->dsoc > 70)) {
+			di->zero_linek = 1800;
+			DBG("ZERO-new: zero_linek adjust step2...\n");
+		/* dsoc close to xsoc: it must reserve power */
+		} else if ((di->zero_linek > 1000) && (di->zero_linek < 1200)) {
+			di->zero_linek = 1200;
+			DBG("ZERO-new: zero_linek adjust step3...\n");
+		/* dsoc[5~15], dsoc < xsoc */
+		} else if ((di->dsoc <= 15 && di->dsoc > 5) &&
+			   (di->zero_linek <= 1200)) {
+			/* slow down */
+			if (xsoc - di->dsoc >= min_gap_xsoc)
+				di->zero_linek = 800;
+			/* reserve power */
+			else
+				di->zero_linek = 1200;
+			DBG("ZERO-new: zero_linek adjust step4...\n");
+		/* dsoc[5, 100], dsoc < xsoc */
+		} else if ((di->zero_linek < 1000) && (di->dsoc >= 5)) {
+			if ((xsoc - di->dsoc) < min_gap_xsoc) {
+				/* reserve power */
+				di->zero_linek = 1200;
+			} else {
+				if (abs(di->current_avg) > 500)/* heavy */
+					di->zero_linek = 900;
+				else
+					di->zero_linek = 1000;
+			}
+			DBG("ZERO-new: zero_linek adjust step5...\n");
+		/* dsoc[0~5], dsoc < xsoc */
+		} else if ((di->zero_linek < 1000) && (di->dsoc <= 5)) {
+			if ((xsoc - di->dsoc) <= 3)
+				di->zero_linek = 1200;
+			else
+				di->zero_linek = 800;
+				DBG("ZERO-new: zero_linek adjust step6...\n");
+		}
+	} else {
+		/* xsoc < 0 */
+		di->zero_linek = 1000;
+		if (!di->zero_drop_sec)
+			di->zero_drop_sec = get_boot_sec();
+		if (base2sec(di->zero_drop_sec) >= WAIT_DSOC_DROP_SEC) {
+			DBG("ZERO0: t=%lu\n", base2sec(di->zero_drop_sec));
+			di->zero_drop_sec = 0;
+			di->dsoc--;
+			di->zero_dsoc = (di->dsoc + 1) * 1000 -
+						MIN_ACCURACY;
+		}
+	}
+
+	if (voltage_avg < pwroff_vol - 70) {
+		if (!di->shtd_drop_sec)
+			di->shtd_drop_sec = get_boot_sec();
+		if (base2sec(di->shtd_drop_sec) > WAIT_SHTD_DROP_SEC) {
+			BAT_INFO("voltage extreme low...soc:%d->0\n", di->dsoc);
+			di->shtd_drop_sec = 0;
+			di->dsoc = 0;
+		}
+	} else {
+		di->shtd_drop_sec = 0;
+	}
+
+	DBG("ZERO-new: org_linek=%d, zero_linek=%d, dsoc=%d, Xsoc=%d, "
+	    "rsoc=%d, gap=%d, v=%d, vsys=%d\n"
+	    "ZERO-new: di->zero_dsoc=%d, zero_remain_cap=%d, zero_drop=%ld, "
+	    "sht_drop=%ld\n\n",
+	    org_linek, di->zero_linek, di->dsoc, xsoc, di->rsoc,
+	    min_gap_xsoc, voltage_avg, vsys, di->zero_dsoc, di->zero_remain_cap,
+	    base2sec(di->zero_drop_sec), base2sec(di->shtd_drop_sec));
+}
+
+static void rk818_bat_finish_algo_prepare(struct rk818_battery *di)
+{
+	di->finish_base = get_boot_sec();
+	if (!di->finish_base)
+		di->finish_base = 1;
+}
+
+static void rk818_bat_smooth_algo_prepare(struct rk818_battery *di)
+{
+	int tmp_soc;
+
+	tmp_soc = di->sm_chrg_dsoc / 1000;
+	if (tmp_soc != di->dsoc)
+		di->sm_chrg_dsoc = di->dsoc * 1000;
+
+	tmp_soc = di->sm_dischrg_dsoc / 1000;
+	if (tmp_soc != di->dsoc)
+		di->sm_dischrg_dsoc =
+		(di->dsoc + 1) * 1000 - MIN_ACCURACY;
+
+	DBG("<%s>. tmp_soc=%d, dsoc=%d, dsoc:sm_dischrg=%d, sm_chrg=%d\n",
+	    __func__, tmp_soc, di->dsoc, di->sm_dischrg_dsoc, di->sm_chrg_dsoc);
+
+	rk818_bat_calc_sm_linek(di);
+}
+
+static void rk818_bat_zero_algo_prepare(struct rk818_battery *di)
+{
+	int tmp_dsoc;
+
+	di->zero_timeout_cnt = 0;
+	tmp_dsoc = di->zero_dsoc / 1000;
+	if (tmp_dsoc != di->dsoc)
+		di->zero_dsoc = (di->dsoc + 1) * 1000 - MIN_ACCURACY;
+
+	DBG("<%s>. first calc, reinit linek\n", __func__);
+
+	rk818_bat_calc_zero_linek(di);
+}
+
+static void rk818_bat_calc_zero_algorithm(struct rk818_battery *di)
+{
+	int tmp_soc = 0, sm_delta_dsoc = 0;
+
+	tmp_soc = di->zero_dsoc / 1000;
+	if (tmp_soc == di->dsoc)
+		goto out;
+
+	DBG("<%s>. enter: dsoc=%d, rsoc=%d\n", __func__, di->dsoc, di->rsoc);
+	/* when discharge slow down, take sm chrg into calc */
+	if (di->dsoc < di->rsoc) {
+		/* take sm charge rest into calc */
+		tmp_soc = di->sm_chrg_dsoc / 1000;
+		if (tmp_soc == di->dsoc) {
+			sm_delta_dsoc = di->sm_chrg_dsoc - di->dsoc * 1000;
+			di->sm_chrg_dsoc = di->dsoc * 1000;
+			di->zero_dsoc += sm_delta_dsoc;
+			DBG("ZERO1: take sm chrg,delta=%d\n", sm_delta_dsoc);
+		}
+	}
+
+	/* when discharge speed up, take sm dischrg into calc */
+	if (di->dsoc > di->rsoc) {
+		/* take sm discharge rest into calc */
+		tmp_soc = di->sm_dischrg_dsoc / 1000;
+		if (tmp_soc == di->dsoc) {
+			sm_delta_dsoc = di->sm_dischrg_dsoc -
+				((di->dsoc + 1) * 1000 - MIN_ACCURACY);
+			di->sm_dischrg_dsoc = (di->dsoc + 1) * 1000 -
+								MIN_ACCURACY;
+			di->zero_dsoc += sm_delta_dsoc;
+			DBG("ZERO1: take sm dischrg,delta=%d\n", sm_delta_dsoc);
+		}
+	}
+
+	/* check overflow */
+	if (di->zero_dsoc > (di->dsoc + 1) * 1000 - MIN_ACCURACY) {
+		DBG("ZERO1: zero dsoc overflow: %d\n", di->zero_dsoc);
+		di->zero_dsoc = (di->dsoc + 1) * 1000 - MIN_ACCURACY;
+	}
+
+	/* check new dsoc */
+	tmp_soc = di->zero_dsoc / 1000;
+	if (tmp_soc != di->dsoc) {
+		/* avoid dsoc jump when heavy load */
+		if ((di->dsoc - tmp_soc) > 1) {
+			di->dsoc--;
+			di->zero_dsoc = (di->dsoc + 1) * 1000 - MIN_ACCURACY;
+			DBG("ZERO1: heavy load...\n");
+		} else {
+			di->dsoc = tmp_soc;
+		}
+		di->zero_drop_sec = 0;
+	}
+
+out:
+	DBG("ZERO1: zero_dsoc(Y0)=%d, dsoc=%d, rsoc=%d, tmp_soc=%d\n",
+	    di->zero_dsoc, di->dsoc, di->rsoc, tmp_soc);
+	DBG("ZERO1: sm_dischrg_dsoc=%d, sm_chrg_dsoc=%d\n",
+	    di->sm_dischrg_dsoc, di->sm_chrg_dsoc);
+}
+
+static void rk818_bat_zero_algorithm(struct rk818_battery *di)
+{
+	int delta_cap = 0, delta_soc = 0;
+
+	di->zero_timeout_cnt++;
+	delta_cap = di->zero_remain_cap - di->remain_cap;
+	delta_soc = di->zero_linek * (delta_cap * 100) / DIV(di->fcc);
+
+	DBG("ZERO1: zero_linek=%d, zero_dsoc(Y0)=%d, dsoc=%d, rsoc=%d\n"
+	    "ZERO1: delta_soc(X0)=%d, delta_cap=%d, zero_remain_cap = %d\n"
+	    "ZERO1: timeout_cnt=%d, sm_dischrg=%d, sm_chrg=%d\n\n",
+	    di->zero_linek, di->zero_dsoc, di->dsoc, di->rsoc,
+	    delta_soc, delta_cap, di->zero_remain_cap,
+	    di->zero_timeout_cnt, di->sm_dischrg_dsoc, di->sm_chrg_dsoc);
+
+	if ((delta_soc >= MIN_ZERO_DSOC_ACCURACY) ||
+	    (di->zero_timeout_cnt > MIN_ZERO_OVERCNT) ||
+	    (di->zero_linek == 0)) {
+		DBG("ZERO1:--------- enter calc -----------\n");
+		di->zero_timeout_cnt = 0;
+		di->zero_dsoc -= delta_soc;
+		rk818_bat_calc_zero_algorithm(di);
+		rk818_bat_calc_zero_linek(di);
+	}
+}
+
+static void rk818_bat_dump_time_table(struct rk818_battery *di)
+{
+	u8 i;
+	static int old_index;
+	static int old_min;
+	int mod = di->dsoc % 10;
+	int index = di->dsoc / 10;
+	u32 time;
+
+	if (rk818_bat_chrg_online(di))
+		time = base2min(di->plug_in_base);
+	else
+		time = base2min(di->plug_out_base);
+
+	if ((mod == 0) && (index > 0) && (old_index != index)) {
+		di->dbg_chrg_min[index - 1] = time - old_min;
+		old_min = time;
+		old_index = index;
+	}
+
+	for (i = 1; i < 11; i++)
+		DBG("Time[%d]=%d, ", (i * 10), di->dbg_chrg_min[i - 1]);
+	DBG("\n");
+}
+
+static void rk818_bat_debug_info(struct rk818_battery *di)
+{
+	u8 sup_tst, ggcon, ggsts, vb_mod, ts_ctrl, reboot_cnt;
+	u8 usb_ctrl, chrg_ctrl1, thermal;
+	u8 int_sts1, int_sts2;
+	u8 int_msk1, int_msk2;
+	u8 chrg_ctrl2, chrg_ctrl3, rtc, misc, dcdc_en;
+	char *work_mode[] = {"ZERO", "FINISH", "UN", "UN", "SMOOTH"};
+	char *bat_mode[] = {"BAT", "VIRTUAL"};
+
+	if (rk818_bat_chrg_online(di))
+		di->plug_out_base = get_boot_sec();
+	else
+		di->plug_in_base = get_boot_sec();
+
+	rk818_bat_dump_time_table(di);
+
+	if (!dbg_enable)
+		return;
+
+	ts_ctrl = rk818_bat_read(di, RK818_TS_CTRL_REG);
+	misc = rk818_bat_read(di, RK818_MISC_MARK_REG);
+	ggcon = rk818_bat_read(di, RK818_GGCON_REG);
+	ggsts = rk818_bat_read(di, RK818_GGSTS_REG);
+	sup_tst = rk818_bat_read(di, RK818_SUP_STS_REG);
+	vb_mod = rk818_bat_read(di, RK818_VB_MON_REG);
+	usb_ctrl = rk818_bat_read(di, RK818_USB_CTRL_REG);
+	chrg_ctrl1 = rk818_bat_read(di, RK818_CHRG_CTRL_REG1);
+	chrg_ctrl2 = rk818_bat_read(di, RK818_CHRG_CTRL_REG2);
+	chrg_ctrl3 = rk818_bat_read(di, RK818_CHRG_CTRL_REG3);
+	rtc = rk818_bat_read(di, 0);
+	thermal = rk818_bat_read(di, RK818_THERMAL_REG);
+	int_sts1 = rk818_bat_read(di, RK818_INT_STS_REG1);
+	int_sts2 = rk818_bat_read(di, RK818_INT_STS_REG2);
+	int_msk1 = rk818_bat_read(di, RK818_INT_STS_MSK_REG1);
+	int_msk2 = rk818_bat_read(di, RK818_INT_STS_MSK_REG2);
+	dcdc_en = rk818_bat_read(di, RK818_DCDC_EN_REG);
+	reboot_cnt = rk818_bat_read(di, RK818_REBOOT_CNT_REG);
+
+	DBG("\n------- DEBUG REGS, [Ver: %s] -------------------\n"
+	    "GGCON=0x%2x, GGSTS=0x%2x, RTC=0x%2x, DCDC_EN2=0x%2x\n"
+	    "SUP_STS= 0x%2x, VB_MOD=0x%2x, USB_CTRL=0x%2x\n"
+	    "THERMAL=0x%2x, MISC_MARK=0x%2x, TS_CTRL=0x%2x\n"
+	    "CHRG_CTRL:REG1=0x%2x, REG2=0x%2x, REG3=0x%2x\n"
+	    "INT_STS:  REG1=0x%2x, REG2=0x%2x\n"
+	    "INT_MSK:  REG1=0x%2x, REG2=0x%2x\n",
+	    DRIVER_VERSION, ggcon, ggsts, rtc, dcdc_en,
+	    sup_tst, vb_mod, usb_ctrl,
+	    thermal, misc, ts_ctrl,
+	    chrg_ctrl1, chrg_ctrl2, chrg_ctrl3,
+	    int_sts1, int_sts2, int_msk1, int_msk2
+	   );
+
+	DBG("###############################################################\n"
+	    "Dsoc=%d, Rsoc=%d, Vavg=%d, Iavg=%d, Cap=%d, Fcc=%d, d=%d\n"
+	    "K=%d, Mode=%s, Oldcap=%d, Is=%d, Ip=%d, Vs=%d\n"
+	    "fb_temp=%d, bat_temp=%d, sample_res=%d, USB=%d, DC=%d\n"
+	    "off:i=0x%x, c=0x%x, p=%d, Rbat=%d, age_ocv_cap=%d, fb=%d, hot=%d\n"
+	    "adp:finish=%lu, boot_min=%lu, sleep_min=%lu, adc=%d, Vsys=%d\n"
+	    "bat:%s, meet: soc=%d, calc: dsoc=%d, rsoc=%d, Vocv=%d\n"
+	    "pwr: dsoc=%d, rsoc=%d, vol=%d, halt: st=%d, cnt=%d, reboot=%d\n"
+	    "ocv_c=%d: %d -> %d; max_c=%d: %d -> %d; force_c=%d: %d -> %d\n"
+	    "min=%d, init=%d, sw=%d, below0=%d, first=%d, changed=%d\n"
+	    "###############################################################\n",
+	    di->dsoc, di->rsoc, di->voltage_avg, di->current_avg,
+	    di->remain_cap, di->fcc, di->rsoc - di->dsoc,
+	    di->sm_linek, work_mode[di->work_mode], di->sm_remain_cap,
+	    di->res_div * chrg_cur_sel_array[chrg_ctrl1 & 0x0f],
+	    chrg_cur_input_array[usb_ctrl & 0x0f],
+	    chrg_vol_sel_array[(chrg_ctrl1 & 0x70) >> 4],
+	    feedback_temp_array[(thermal & 0x0c) >> 2], di->temperature,
+	    di->pdata->sample_res, di->usb_in, di->ac_in,
+	    rk818_bat_get_ioffset(di),
+	    rk818_bat_get_coffset(di), di->poffset, di->bat_res,
+	    di->age_adjust_cap, di->fb_blank, !!(thermal & HOTDIE_STS),
+	    base2min(di->finish_base),
+	    base2min(di->boot_base), di->sleep_sum_sec / 60,
+	    di->adc_allow_update,
+	    di->voltage_avg + di->current_avg * DEF_PWRPATH_RES / 1000,
+	    bat_mode[di->pdata->bat_mode], di->dbg_meet_soc, di->dbg_calc_dsoc,
+	    di->dbg_calc_rsoc, di->voltage_ocv, di->dbg_pwr_dsoc,
+	    di->dbg_pwr_rsoc, di->dbg_pwr_vol, di->is_halt, di->halt_cnt,
+	    reboot_cnt, di->is_ocv_calib, di->ocv_pre_dsoc, di->ocv_new_dsoc,
+	    di->is_max_soc_offset, di->max_pre_dsoc, di->max_new_dsoc,
+	    di->is_force_calib, di->force_pre_dsoc, di->force_new_dsoc,
+	    di->pwroff_min, di->is_initialized, di->is_sw_reset,
+	    di->dbg_cap_low0, di->is_first_on, di->last_dsoc
+	   );
+}
+
+static void rk818_bat_init_capacity(struct rk818_battery *di, u32 cap)
+{
+	int delta_cap;
+
+	delta_cap = cap - di->remain_cap;
+	if (!delta_cap)
+		return;
+
+	di->age_adjust_cap += delta_cap;
+	rk818_bat_init_coulomb_cap(di, cap);
+	rk818_bat_smooth_algo_prepare(di);
+	rk818_bat_zero_algo_prepare(di);
+}
+
+static void rk818_bat_update_age_fcc(struct rk818_battery *di)
+{
+	int fcc, remain_cap, age_keep_min, lock_fcc;
+
+	lock_fcc = rk818_bat_get_coulomb_cap(di);
+	remain_cap = lock_fcc - di->age_ocv_cap - di->age_adjust_cap;
+	age_keep_min = base2min(di->age_keep_sec);
+
+	DBG("%s: lock_fcc=%d, age_ocv_cap=%d, age_adjust_cap=%d, remain_cap=%d,"
+	    "age_allow_update=%d, age_keep_min=%d\n",
+	    __func__, lock_fcc, di->age_ocv_cap, di->age_adjust_cap, remain_cap,
+	    di->age_allow_update, age_keep_min);
+
+	if ((di->chrg_status == CHARGE_FINISH) && (di->age_allow_update) &&
+	    (age_keep_min < 1200)) {
+		di->age_allow_update = false;
+		fcc = remain_cap * 100 / DIV(100 - di->age_ocv_soc);
+		BAT_INFO("lock_fcc=%d, calc_cap=%d, age: soc=%d, cap=%d, "
+			 "level=%d, fcc:%d->%d?\n",
+			 lock_fcc, remain_cap, di->age_ocv_soc,
+			 di->age_ocv_cap, di->age_level, di->fcc, fcc);
+
+		if ((fcc < di->qmax) && (fcc > MIN_FCC)) {
+			BAT_INFO("fcc:%d->%d!\n", di->fcc, fcc);
+			di->fcc = fcc;
+			rk818_bat_init_capacity(di, di->fcc);
+			rk818_bat_save_fcc(di, di->fcc);
+			rk818_bat_save_age_level(di, di->age_level);
+		}
+	}
+}
+
+static void rk818_bat_wait_finish_sig(struct rk818_battery *di)
+{
+	int chrg_finish_vol = di->pdata->max_chrg_voltage;
+
+	if (!rk818_bat_chrg_online(di))
+		return;
+
+	if ((di->chrg_status == CHARGE_FINISH) && (di->adc_allow_update) &&
+	    (di->voltage_avg > chrg_finish_vol - 150)) {
+		rk818_bat_update_age_fcc(di);
+		if (rk818_bat_adc_calib(di))
+			di->adc_allow_update = false;
+	}
+}
+
+static void rk818_bat_finish_algorithm(struct rk818_battery *di)
+{
+	unsigned long finish_sec, soc_sec;
+	int plus_soc, finish_current, rest = 0;
+
+	/* rsoc */
+	if ((di->remain_cap != di->fcc) &&
+	    (rk818_bat_get_chrg_status(di) == CHARGE_FINISH)) {
+		di->age_adjust_cap += (di->fcc - di->remain_cap);
+		rk818_bat_init_coulomb_cap(di, di->fcc);
+	}
+
+	/* dsoc */
+	if (di->dsoc < 100) {
+		if (!di->finish_base)
+			di->finish_base = get_boot_sec();
+		finish_current = (di->rsoc - di->dsoc) >  FINISH_MAX_SOC_DELAY ?
+					FINISH_CHRG_CUR2 : FINISH_CHRG_CUR1;
+		finish_sec = base2sec(di->finish_base);
+		soc_sec = di->fcc * 3600 / 100 / DIV(finish_current);
+		plus_soc = finish_sec / DIV(soc_sec);
+		if (finish_sec > soc_sec) {
+			rest = finish_sec % soc_sec;
+			di->dsoc += plus_soc;
+			di->finish_base = get_boot_sec();
+			if (di->finish_base > rest)
+				di->finish_base = get_boot_sec() - rest;
+		}
+		DBG("<%s>.CHARGE_FINISH:dsoc<100,dsoc=%d\n"
+		    "soc_time=%lu, sec_finish=%lu, plus_soc=%d, rest=%d\n",
+		    __func__, di->dsoc, soc_sec, finish_sec, plus_soc, rest);
+	}
+}
+
+static void rk818_bat_calc_smooth_dischrg(struct rk818_battery *di)
+{
+	int tmp_soc = 0, sm_delta_dsoc = 0, zero_delta_dsoc = 0;
+
+	tmp_soc = di->sm_dischrg_dsoc / 1000;
+	if (tmp_soc == di->dsoc)
+		goto out;
+
+	DBG("<%s>. enter: dsoc=%d, rsoc=%d\n", __func__, di->dsoc, di->rsoc);
+	/* when dischrge slow down, take sm charge rest into calc */
+	if (di->dsoc < di->rsoc) {
+		tmp_soc = di->sm_chrg_dsoc / 1000;
+		if (tmp_soc == di->dsoc) {
+			sm_delta_dsoc = di->sm_chrg_dsoc - di->dsoc * 1000;
+			di->sm_chrg_dsoc = di->dsoc * 1000;
+			di->sm_dischrg_dsoc += sm_delta_dsoc;
+			DBG("<%s>. take sm dischrg, delta=%d\n",
+			    __func__, sm_delta_dsoc);
+		}
+	}
+
+	/* when discharge speed up, take zero discharge rest into calc */
+	if (di->dsoc > di->rsoc) {
+		tmp_soc = di->zero_dsoc / 1000;
+		if (tmp_soc == di->dsoc) {
+			zero_delta_dsoc = di->zero_dsoc - ((di->dsoc + 1) *
+						1000 - MIN_ACCURACY);
+			di->zero_dsoc = (di->dsoc + 1) * 1000 - MIN_ACCURACY;
+			di->sm_dischrg_dsoc += zero_delta_dsoc;
+			DBG("<%s>. take zero schrg, delta=%d\n",
+			    __func__, zero_delta_dsoc);
+		}
+	}
+
+	/* check up overflow */
+	if ((di->sm_dischrg_dsoc) > ((di->dsoc + 1) * 1000 - MIN_ACCURACY)) {
+		DBG("<%s>. dischrg_dsoc up overflow\n", __func__);
+		di->sm_dischrg_dsoc = (di->dsoc + 1) *
+					1000 - MIN_ACCURACY;
+	}
+
+	/* check new dsoc */
+	tmp_soc = di->sm_dischrg_dsoc / 1000;
+	if (tmp_soc != di->dsoc) {
+		di->dsoc = tmp_soc;
+		di->sm_chrg_dsoc = di->dsoc * 1000;
+	}
+out:
+	DBG("<%s>. dsoc=%d, rsoc=%d, dsoc:sm_dischrg=%d, sm_chrg=%d, zero=%d\n",
+	    __func__, di->dsoc, di->rsoc, di->sm_dischrg_dsoc, di->sm_chrg_dsoc,
+	    di->zero_dsoc);
+
+}
+
+static void rk818_bat_calc_smooth_chrg(struct rk818_battery *di)
+{
+	int tmp_soc = 0, sm_delta_dsoc = 0, zero_delta_dsoc = 0;
+
+	tmp_soc = di->sm_chrg_dsoc / 1000;
+	if (tmp_soc == di->dsoc)
+		goto out;
+
+	DBG("<%s>. enter: dsoc=%d, rsoc=%d\n", __func__, di->dsoc, di->rsoc);
+	/* when charge slow down, take zero & sm dischrg into calc */
+	if (di->dsoc > di->rsoc) {
+		/* take sm discharge rest into calc */
+		tmp_soc = di->sm_dischrg_dsoc / 1000;
+		if (tmp_soc == di->dsoc) {
+			sm_delta_dsoc = di->sm_dischrg_dsoc -
+					((di->dsoc + 1) * 1000 - MIN_ACCURACY);
+			di->sm_dischrg_dsoc = (di->dsoc + 1) * 1000 -
+							MIN_ACCURACY;
+			di->sm_chrg_dsoc += sm_delta_dsoc;
+			DBG("<%s>. take sm dischrg, delta=%d\n",
+			   __func__, sm_delta_dsoc);
+		}
+
+		/* take zero discharge rest into calc */
+		tmp_soc = di->zero_dsoc / 1000;
+		if (tmp_soc == di->dsoc) {
+			zero_delta_dsoc = di->zero_dsoc -
+			((di->dsoc + 1) * 1000 - MIN_ACCURACY);
+			di->zero_dsoc = (di->dsoc + 1) * 1000 - MIN_ACCURACY;
+			di->sm_chrg_dsoc += zero_delta_dsoc;
+			DBG("<%s>. take zero dischrg, delta=%d\n",
+			    __func__, zero_delta_dsoc);
+		}
+	}
+
+	/* check down overflow */
+	if (di->sm_chrg_dsoc < di->dsoc * 1000) {
+		DBG("<%s>. chrg_dsoc down overflow\n", __func__);
+		di->sm_chrg_dsoc = di->dsoc * 1000;
+	}
+
+	/* check new dsoc */
+	tmp_soc = di->sm_chrg_dsoc / 1000;
+	if (tmp_soc != di->dsoc) {
+		di->dsoc = tmp_soc;
+		di->sm_dischrg_dsoc = (di->dsoc + 1) * 1000 - MIN_ACCURACY;
+	}
+out:
+	DBG("<%s>.dsoc=%d, rsoc=%d, dsoc: sm_dischrg=%d, sm_chrg=%d, zero=%d\n",
+	    __func__, di->dsoc, di->rsoc, di->sm_dischrg_dsoc, di->sm_chrg_dsoc,
+	    di->zero_dsoc);
+}
+
+static void rk818_bat_smooth_algorithm(struct rk818_battery *di)
+{
+	int ydsoc = 0, delta_cap = 0, old_cap = 0;
+	unsigned long tgt_sec = 0;
+
+	di->remain_cap = rk818_bat_get_coulomb_cap(di);
+
+	/* full charge: slow down */
+	if ((di->dsoc == 99) && (di->chrg_status == CC_OR_CV) &&
+	    (di->current_avg > 0)) {
+		di->sm_linek = FULL_CHRG_K;
+	/* terminal charge, slow down */
+	} else if ((di->current_avg >= TERM_CHRG_CURR) &&
+	    (di->chrg_status == CC_OR_CV) && (di->dsoc >= TERM_CHRG_DSOC)) {
+		di->sm_linek = TERM_CHRG_K;
+		DBG("<%s>. terminal mode..\n", __func__);
+	/* simulate charge, speed up */
+	} else if ((di->current_avg <= SIMULATE_CHRG_CURR) &&
+		   (di->current_avg > 0) && (di->chrg_status == CC_OR_CV) &&
+		   (di->dsoc < TERM_CHRG_DSOC) &&
+		   ((di->rsoc - di->dsoc) >= SIMULATE_CHRG_INTV)) {
+		di->sm_linek = SIMULATE_CHRG_K;
+		DBG("<%s>. simulate mode..\n", __func__);
+	} else {
+		/* charge and discharge switch */
+		if ((di->sm_linek * di->current_avg <= 0) ||
+		    (di->sm_linek == TERM_CHRG_K) ||
+		    (di->sm_linek == FULL_CHRG_K) ||
+		    (di->sm_linek == SIMULATE_CHRG_K)) {
+			DBG("<%s>. linek mode, retinit sm linek..\n", __func__);
+			rk818_bat_calc_sm_linek(di);
+		}
+	}
+
+	old_cap = di->sm_remain_cap;
+	/*
+	 * when dsoc equal rsoc(not include full, term, simulate case),
+	 * sm_linek should change to -1000/1000 smoothly to avoid dsoc+1/-1
+	 * right away, so change it after flat seconds
+	 */
+	if ((di->dsoc == di->rsoc) && (abs(di->sm_linek) != 1000) &&
+	    (di->sm_linek != FULL_CHRG_K && di->sm_linek != TERM_CHRG_K &&
+	     di->sm_linek != SIMULATE_CHRG_K)) {
+		if (!di->flat_match_sec)
+			di->flat_match_sec = get_boot_sec();
+		tgt_sec = di->fcc * 3600 / 100 / DIV(abs(di->current_avg)) / 3;
+		if (base2sec(di->flat_match_sec) >= tgt_sec) {
+			di->flat_match_sec = 0;
+			di->sm_linek = (di->current_avg >= 0) ? 1000 : -1000;
+		}
+		DBG("<%s>. flat_sec=%ld, tgt_sec=%ld, sm_k=%d\n", __func__,
+		    base2sec(di->flat_match_sec), tgt_sec, di->sm_linek);
+	} else {
+		di->flat_match_sec = 0;
+	}
+
+	/* abs(k)=1000 or dsoc=100, stop calc */
+	if ((abs(di->sm_linek) == 1000) || (di->current_avg >= 0 &&
+	     di->chrg_status == CC_OR_CV && di->dsoc >= 100)) {
+		DBG("<%s>. sm_linek=%d\n", __func__, di->sm_linek);
+		if (abs(di->sm_linek) == 1000) {
+			di->dsoc = di->rsoc;
+			di->sm_linek = (di->sm_linek > 0) ? 1000 : -1000;
+			DBG("<%s>. dsoc == rsoc, sm_linek=%d\n",
+			    __func__, di->sm_linek);
+		}
+		di->sm_remain_cap = di->remain_cap;
+		di->sm_chrg_dsoc = di->dsoc * 1000;
+		di->sm_dischrg_dsoc = (di->dsoc + 1) * 1000 - MIN_ACCURACY;
+		DBG("<%s>. sm_dischrg_dsoc=%d, sm_chrg_dsoc=%d\n",
+		    __func__, di->sm_dischrg_dsoc, di->sm_chrg_dsoc);
+	} else {
+		delta_cap = di->remain_cap - di->sm_remain_cap;
+		if (delta_cap == 0) {
+			DBG("<%s>. delta_cap = 0\n", __func__);
+			return;
+		}
+		ydsoc = di->sm_linek * abs(delta_cap) * 100 / DIV(di->fcc);
+		if (ydsoc == 0) {
+			DBG("<%s>. ydsoc = 0\n", __func__);
+			return;
+		}
+		di->sm_remain_cap = di->remain_cap;
+
+		DBG("<%s>. k=%d, ydsoc=%d; cap:old=%d, new:%d; delta_cap=%d\n",
+		    __func__, di->sm_linek, ydsoc, old_cap,
+		    di->sm_remain_cap, delta_cap);
+
+		/* discharge mode */
+		if (ydsoc < 0) {
+			di->sm_dischrg_dsoc += ydsoc;
+			rk818_bat_calc_smooth_dischrg(di);
+		/* charge mode */
+		} else {
+			di->sm_chrg_dsoc += ydsoc;
+			rk818_bat_calc_smooth_chrg(di);
+		}
+
+		if (di->s2r) {
+			di->s2r = false;
+			rk818_bat_calc_sm_linek(di);
+		}
+	}
+}
+
+/*
+ * cccv and finish switch all the time will cause dsoc freeze,
+ * if so, do finish chrg, 100ma is less than min finish_ma.
+ */
+static bool rk818_bat_fake_finish_mode(struct rk818_battery *di)
+{
+	if ((di->rsoc == 100) && (rk818_bat_get_chrg_status(di) == CC_OR_CV) &&
+	    (abs(di->current_avg) <= 100))
+		return true;
+	else
+		return false;
+}
+
+static void rk818_bat_display_smooth(struct rk818_battery *di)
+{
+	/* discharge: reinit "zero & smooth" algorithm to avoid handling dsoc */
+	if (di->s2r && !di->sleep_chrg_online) {
+		DBG("s2r: discharge, reset algorithm...\n");
+		di->s2r = false;
+		rk818_bat_zero_algo_prepare(di);
+		rk818_bat_smooth_algo_prepare(di);
+		return;
+	}
+
+	if (di->work_mode == MODE_FINISH) {
+		DBG("step1: charge finish...\n");
+		rk818_bat_finish_algorithm(di);
+		if ((rk818_bat_get_chrg_status(di) != CHARGE_FINISH) &&
+		    !rk818_bat_fake_finish_mode(di)) {
+			if ((di->current_avg < 0) &&
+			    (di->voltage_avg < di->pdata->zero_algorithm_vol)) {
+				DBG("step1: change to zero mode...\n");
+				rk818_bat_zero_algo_prepare(di);
+				di->work_mode = MODE_ZERO;
+			} else {
+				DBG("step1: change to smooth mode...\n");
+				rk818_bat_smooth_algo_prepare(di);
+				di->work_mode = MODE_SMOOTH;
+			}
+		}
+	} else if (di->work_mode == MODE_ZERO) {
+		DBG("step2: zero algorithm...\n");
+		rk818_bat_zero_algorithm(di);
+		if ((di->voltage_avg >= di->pdata->zero_algorithm_vol + 50) ||
+		    (di->current_avg >= 0)) {
+			DBG("step2: change to smooth mode...\n");
+			rk818_bat_smooth_algo_prepare(di);
+			di->work_mode = MODE_SMOOTH;
+		} else if ((rk818_bat_get_chrg_status(di) == CHARGE_FINISH) ||
+			   rk818_bat_fake_finish_mode(di)) {
+			DBG("step2: change to finish mode...\n");
+			rk818_bat_finish_algo_prepare(di);
+			di->work_mode = MODE_FINISH;
+		}
+	} else {
+		DBG("step3: smooth algorithm...\n");
+		rk818_bat_smooth_algorithm(di);
+		if ((di->current_avg < 0) &&
+		    (di->voltage_avg < di->pdata->zero_algorithm_vol)) {
+			DBG("step3: change to zero mode...\n");
+			rk818_bat_zero_algo_prepare(di);
+			di->work_mode = MODE_ZERO;
+		} else if ((rk818_bat_get_chrg_status(di) == CHARGE_FINISH) ||
+			   rk818_bat_fake_finish_mode(di)) {
+			DBG("step3: change to finish mode...\n");
+			rk818_bat_finish_algo_prepare(di);
+			di->work_mode = MODE_FINISH;
+		}
+	}
+}
+
+static void rk818_bat_relax_vol_calib(struct rk818_battery *di)
+{
+	int soc, cap, vol;
+
+	vol = di->voltage_relax;
+	soc = rk818_bat_vol_to_ocvsoc(di, vol);
+	cap = rk818_bat_vol_to_ocvcap(di, vol);
+	rk818_bat_init_capacity(di, cap);
+	BAT_INFO("sleep ocv calib: rsoc=%d, cap=%d\n", soc, cap);
+}
+
+static void rk818_bat_relife_age_flag(struct rk818_battery *di)
+{
+	u8 ocv_soc, ocv_cap, soc_level;
+
+	if (di->voltage_relax <= 0)
+		return;
+
+	ocv_soc = rk818_bat_vol_to_ocvsoc(di, di->voltage_relax);
+	ocv_cap = rk818_bat_vol_to_ocvcap(di, di->voltage_relax);
+	DBG("<%s>. ocv_soc=%d, min=%lu, vol=%d\n", __func__,
+	    ocv_soc, di->sleep_dischrg_sec / 60, di->voltage_relax);
+
+	/* sleep enough time and ocv_soc enough low */
+	if (!di->age_allow_update && ocv_soc <= 10) {
+		di->age_voltage = di->voltage_relax;
+		di->age_ocv_cap = ocv_cap;
+		di->age_ocv_soc = ocv_soc;
+		di->age_adjust_cap = 0;
+
+		if (ocv_soc <= 1)
+			di->age_level = 100;
+		else if (ocv_soc < 5)
+			di->age_level = 90;
+		else
+			di->age_level = 80;
+
+		soc_level = rk818_bat_get_age_level(di);
+		if (soc_level > di->age_level) {
+			di->age_allow_update = false;
+		} else {
+			di->age_allow_update = true;
+			di->age_keep_sec = get_boot_sec();
+		}
+
+		BAT_INFO("resume: age_vol:%d, age_ocv_cap:%d, age_ocv_soc:%d, "
+			 "soc_level:%d, age_allow_update:%d, "
+			 "age_level:%d\n",
+			 di->age_voltage, di->age_ocv_cap, ocv_soc, soc_level,
+			 di->age_allow_update, di->age_level);
+	}
+}
+
+static int rk818_bat_sleep_dischrg(struct rk818_battery *di)
+{
+	bool ocv_soc_updated = false;
+	int tgt_dsoc, gap_soc, sleep_soc = 0;
+	int pwroff_vol = di->pdata->pwroff_vol;
+	unsigned long sleep_sec = di->sleep_dischrg_sec;
+
+	DBG("<%s>. enter: dsoc=%d, rsoc=%d, rv=%d, v=%d, sleep_min=%lu\n",
+	    __func__, di->dsoc, di->rsoc, di->voltage_relax,
+	    di->voltage_avg, sleep_sec / 60);
+
+	if (di->voltage_relax >= di->voltage_avg) {
+		rk818_bat_relax_vol_calib(di);
+		rk818_bat_restart_relax(di);
+		rk818_bat_relife_age_flag(di);
+		ocv_soc_updated = true;
+	}
+
+	/* handle dsoc */
+	if (di->dsoc <= di->rsoc) {
+		di->sleep_sum_cap = (SLP_CURR_MIN * sleep_sec / 3600);
+		sleep_soc = di->sleep_sum_cap * 100 / DIV(di->fcc);
+		tgt_dsoc = di->dsoc - sleep_soc;
+		if (sleep_soc > 0) {
+			BAT_INFO("calib0: rl=%d, dl=%d, intval=%d\n",
+				 di->rsoc, di->dsoc, sleep_soc);
+			if (di->dsoc < 5) {
+				di->dsoc--;
+			} else if ((tgt_dsoc < 5) && (di->dsoc >= 5)) {
+				if (di->dsoc == 5)
+					di->dsoc--;
+				else
+					di->dsoc = 5;
+			} else if (tgt_dsoc > 5) {
+				di->dsoc = tgt_dsoc;
+			}
+		}
+
+		DBG("%s: dsoc<=rsoc, sum_cap=%d==>sleep_soc=%d, tgt_dsoc=%d\n",
+		    __func__, di->sleep_sum_cap, sleep_soc, tgt_dsoc);
+	} else {
+		/* di->dsoc > di->rsoc */
+		di->sleep_sum_cap = (SLP_CURR_MAX * sleep_sec / 3600);
+		sleep_soc = di->sleep_sum_cap / DIV(di->fcc / 100);
+		gap_soc = di->dsoc - di->rsoc;
+
+		BAT_INFO("calib1: rsoc=%d, dsoc=%d, intval=%d\n",
+			 di->rsoc, di->dsoc, sleep_soc);
+		if (gap_soc > sleep_soc) {
+			if ((gap_soc - 5) > (sleep_soc * 2))
+				di->dsoc -= (sleep_soc * 2);
+			else
+				di->dsoc -= sleep_soc;
+		} else {
+			di->dsoc = di->rsoc;
+		}
+
+		DBG("%s: dsoc>rsoc, sum_cap=%d=>sleep_soc=%d, gap_soc=%d\n",
+		    __func__, di->sleep_sum_cap, sleep_soc, gap_soc);
+	}
+
+	if (di->voltage_avg <= pwroff_vol - 70) {
+		di->dsoc = 0;
+		rk_send_wakeup_key();
+		BAT_INFO("low power sleeping, shutdown... %d\n", di->dsoc);
+	}
+
+	if (ocv_soc_updated && sleep_soc && (di->rsoc - di->dsoc) < 5 &&
+	    di->dsoc < 40) {
+		di->dsoc--;
+		BAT_INFO("low power sleeping, reserved... %d\n", di->dsoc);
+	}
+
+	if (di->dsoc <= 0) {
+		di->dsoc = 0;
+		rk_send_wakeup_key();
+		BAT_INFO("sleep dsoc is %d...\n", di->dsoc);
+	}
+
+	DBG("<%s>. out: dsoc=%d, rsoc=%d, sum_cap=%d\n",
+	    __func__, di->dsoc, di->rsoc, di->sleep_sum_cap);
+
+	return sleep_soc;
+}
+
+static void rk818_bat_power_supply_changed(struct rk818_battery *di)
+{
+	u8 status, thermal;
+	static int old_soc = -1;
+
+	if (di->dsoc > 100)
+		di->dsoc = 100;
+	else if (di->dsoc < 0)
+		di->dsoc = 0;
+
+	if (di->dsoc == old_soc)
+		return;
+
+	thermal = rk818_bat_read(di, RK818_THERMAL_REG);
+	status = rk818_bat_read(di, RK818_SUP_STS_REG);
+	status = (status & CHRG_STATUS_MSK) >> 4;
+	old_soc = di->dsoc;
+	di->last_dsoc = di->dsoc;
+	power_supply_changed(di->bat);
+	BAT_INFO("changed: dsoc=%d, rsoc=%d, v=%d, ov=%d c=%d, "
+		 "cap=%d, f=%d, st=%s, hotdie=%d\n",
+		 di->dsoc, di->rsoc, di->voltage_avg, di->voltage_ocv,
+		 di->current_avg, di->remain_cap, di->fcc, bat_status[status],
+		 !!(thermal & HOTDIE_STS));
+
+	BAT_INFO("dl=%d, rl=%d, v=%d, halt=%d, halt_n=%d, max=%d, "
+		 "init=%d, sw=%d, calib=%d, below0=%d, force=%d\n",
+		 di->dbg_pwr_dsoc, di->dbg_pwr_rsoc, di->dbg_pwr_vol,
+		 di->is_halt, di->halt_cnt, di->is_max_soc_offset,
+		 di->is_initialized, di->is_sw_reset, di->is_ocv_calib,
+		 di->dbg_cap_low0, di->is_force_calib);
+}
+
+static u8 rk818_bat_check_reboot(struct rk818_battery *di)
+{
+	u8 cnt;
+
+	cnt = rk818_bat_read(di, RK818_REBOOT_CNT_REG);
+	cnt++;
+
+	if (cnt >= REBOOT_MAX_CNT) {
+		BAT_INFO("reboot: %d --> %d\n", di->dsoc, di->rsoc);
+		di->dsoc = di->rsoc;
+		if (di->dsoc > 100)
+			di->dsoc = 100;
+		else if (di->dsoc < 0)
+			di->dsoc = 0;
+		rk818_bat_save_dsoc(di, di->dsoc);
+		cnt = REBOOT_MAX_CNT;
+	}
+
+	rk818_bat_save_reboot_cnt(di, cnt);
+	DBG("reboot cnt: %d\n", cnt);
+
+	return cnt;
+}
+
+static void rk818_bat_rsoc_daemon(struct rk818_battery *di)
+{
+	int est_vol, remain_cap;
+	static unsigned long sec;
+
+	if ((di->remain_cap < 0) && (di->fb_blank != 0)) {
+		if (!sec)
+			sec = get_boot_sec();
+		// wake_lock_timeout(&di->wake_lock,
+		// 		  (di->pdata->monitor_sec + 1) * HZ);
+
+		DBG("sec=%ld, hold_sec=%ld\n", sec, base2sec(sec));
+		if (base2sec(sec) >= 60) {
+			sec = 0;
+			di->dbg_cap_low0++;
+			est_vol = di->voltage_avg -
+					(di->bat_res * di->current_avg) / 1000;
+			remain_cap = rk818_bat_vol_to_ocvcap(di, est_vol);
+			rk818_bat_init_capacity(di, remain_cap);
+			BAT_INFO("adjust cap below 0 --> %d, rsoc=%d\n",
+				 di->remain_cap, di->rsoc);
+			// wake_unlock(&di->wake_lock);
+		}
+	} else {
+		sec = 0;
+	}
+}
+
+static void rk818_bat_update_info(struct rk818_battery *di)
+{
+	int is_charging;
+
+	di->voltage_avg = rk818_bat_get_avg_voltage(di);
+	di->current_avg = rk818_bat_get_avg_current(di);
+	di->voltage_relax = rk818_bat_get_relax_voltage(di);
+	di->rsoc = rk818_bat_get_rsoc(di);
+	di->remain_cap = rk818_bat_get_coulomb_cap(di);
+	di->chrg_status = rk818_bat_get_chrg_status(di);
+	is_charging = rk818_bat_get_charge_state(di);
+	if (is_charging != di->is_charging) {
+		di->is_charging = is_charging;
+		if (is_charging)
+			di->charge_count++;
+	}
+	if (di->voltage_avg > di->voltage_max)
+		di->voltage_max = di->voltage_avg;
+	if (di->current_avg > di->current_max)
+		di->current_max = di->current_avg;
+
+	/* smooth charge */
+	if (di->remain_cap > di->fcc) {
+		di->sm_remain_cap -= (di->remain_cap - di->fcc);
+		DBG("<%s>. cap: remain=%d, sm_remain=%d\n",
+		    __func__, di->remain_cap, di->sm_remain_cap);
+		rk818_bat_init_coulomb_cap(di, di->fcc);
+	}
+
+	if (di->chrg_status != CHARGE_FINISH)
+		di->finish_base = get_boot_sec();
+
+	/*
+	 * we need update fcc in continuous charging state, if discharge state
+	 * keep at least 2 hour, we decide not to update fcc, so clear the
+	 * fcc update flag: age_allow_update.
+	 */
+	if (base2min(di->plug_out_base) > 120)
+		di->age_allow_update = false;
+
+	/* do adc calib: status must from cccv mode to finish mode */
+	if (di->chrg_status == CC_OR_CV) {
+		di->adc_allow_update = true;
+		di->adc_calib_cnt = 0;
+	}
+}
+
+static void rk818_bat_init_ts1_detect(struct rk818_battery *di)
+{
+	u8 buf;
+	u32 *ntc_table = di->pdata->ntc_table;
+
+	if (!di->pdata->ntc_size)
+		return;
+
+	/* select ua */
+	buf = rk818_bat_read(di, RK818_TS_CTRL_REG);
+	buf &= ~TS1_CUR_MSK;
+	/* chose suitable UA for temperature detect */
+	if (ntc_table[0] < NTC_80UA_MAX_MEASURE) {
+		di->pdata->ntc_factor = NTC_CALC_FACTOR_80UA;
+		di->pdata->ntc_uA = 80;
+		buf |= ADC_CUR_80UA;
+	} else if (ntc_table[0] < NTC_60UA_MAX_MEASURE) {
+		di->pdata->ntc_factor = NTC_CALC_FACTOR_60UA;
+		di->pdata->ntc_uA = 60;
+		buf |= ADC_CUR_60UA;
+	} else if (ntc_table[0] < NTC_40UA_MAX_MEASURE) {
+		di->pdata->ntc_factor = NTC_CALC_FACTOR_40UA;
+		di->pdata->ntc_uA = 40;
+		buf |= ADC_CUR_40UA;
+	} else {
+		di->pdata->ntc_factor = NTC_CALC_FACTOR_20UA;
+		di->pdata->ntc_uA = 20;
+		buf |= ADC_CUR_20UA;
+	}
+	rk818_bat_write(di, RK818_TS_CTRL_REG, buf);
+
+	/* enable ADC_TS1_EN */
+	buf = rk818_bat_read(di, RK818_ADC_CTRL_REG);
+	buf |= ADC_TS1_EN;
+	rk818_bat_write(di, RK818_ADC_CTRL_REG, buf);
+}
+
+/*
+ * Due to hardware design issue, Vdelta = "(R_sample + R_other) * I_avg" will be
+ * included into TS1 adc value. We must subtract it to get correct adc value.
+ * The solution:
+ *
+ * (1) calculate Vdelta:
+ *
+ *   adc1 - Vdelta    ua1			  (adc2 * ua1) - (adc1 * ua2)
+ *   ------------- = -----  ==> equals: Vdelta = -----------------------------
+ *   adc2 - Vdelta    ua2				ua1 - ua2
+ *
+ *
+ * (2) calculate correct ADC value:
+ *
+ *     charging: ADC = adc1 - abs(Vdelta);
+ *  discharging: ADC = adc1 + abs(Vdelta);
+ */
+static int rk818_bat_get_ntc_res(struct rk818_battery *di)
+{
+	int adc1 = 0, adc2 = 0;
+	int ua1, ua2, v_delta, res, val;
+	u8 buf;
+
+	/* read sample ua1 */
+	buf = rk818_bat_read(di, RK818_TS_CTRL_REG);
+	DBG("<%s>. read adc1, sample uA=%d\n",
+	    __func__, ((buf & 0x03) + 1) * 20);
+
+	/* read adc adc1 */
+	ua1 = di->pdata->ntc_uA;
+	adc1 |= rk818_bat_read(di, RK818_TS1_ADC_REGL) << 0;
+	adc1 |= rk818_bat_read(di, RK818_TS1_ADC_REGH) << 8;
+
+	/* chose reference UA for adc2 */
+	ua2 = (ua1 != 20) ? 20 : 40;
+	buf = rk818_bat_read(di, RK818_TS_CTRL_REG);
+	buf &= ~TS1_CUR_MSK;
+	buf |= ((ua2 - 20) / 20);
+	rk818_bat_write(di, RK818_TS_CTRL_REG, buf);
+
+	/* read adc adc2 */
+	msleep(1000);
+
+	/* read sample ua2 */
+	buf = rk818_bat_read(di, RK818_TS_CTRL_REG);
+	DBG("<%s>. read adc2, sample uA=%d\n",
+	    __func__, ((buf & 0x03) + 1) * 20);
+
+	adc2 |= rk818_bat_read(di, RK818_TS1_ADC_REGL) << 0;
+	adc2 |= rk818_bat_read(di, RK818_TS1_ADC_REGH) << 8;
+
+	DBG("<%s>. ua1=%d, ua2=%d, adc1=%d, adc2=%d\n",
+	    __func__, ua1, ua2, adc1, adc2);
+
+	/* calculate delta voltage */
+	if (adc2 != adc1)
+		v_delta = abs((adc2 * ua1 - adc1 * ua2) / (ua2 - ua1));
+	else
+		v_delta = 0;
+
+	/* considering current avg direction, calcuate real adc value */
+	val = (di->current_avg >= 0) ? (adc1 - v_delta) : (adc1 + v_delta);
+
+	DBG("<%s>. Iavg=%d, Vdelta=%d, Vadc=%d\n",
+	    __func__, di->current_avg, v_delta, val);
+
+	res = val * di->pdata->ntc_factor;
+
+	DBG("<%s>. val=%d, ntc_res=%d, ntc_factor=%d, Rdelta=%d\n",
+	    __func__, val, res, di->pdata->ntc_factor,
+	    v_delta * di->pdata->ntc_factor);
+
+	DBG("<%s>. t=[%d'C(%d) ~ %dC(%d)]\n", __func__,
+	    di->pdata->ntc_degree_from, di->pdata->ntc_table[0],
+	    di->pdata->ntc_degree_from + di->pdata->ntc_size - 1,
+	    di->pdata->ntc_table[di->pdata->ntc_size - 1]);
+
+	rk818_bat_init_ts1_detect(di);
+
+	return res;
+}
+
+static BLOCKING_NOTIFIER_HEAD(rk818_bat_notifier_chain);
+
+int rk818_bat_temp_notifier_register(struct notifier_block *nb)
+{
+	return blocking_notifier_chain_register(&rk818_bat_notifier_chain, nb);
+}
+
+int rk818_bat_temp_notifier_unregister(struct notifier_block *nb)
+{
+	return blocking_notifier_chain_unregister(&rk818_bat_notifier_chain, nb);
+}
+
+static void rk818_bat_temp_notifier_callback(int temp)
+{
+	blocking_notifier_call_chain(&rk818_bat_notifier_chain, temp, NULL);
+}
+
+static void rk818_bat_update_temperature(struct rk818_battery *di)
+{
+	static int old_temp, first_time = 1;
+	u32 ntc_size, *ntc_table;
+	int i, res, temp;
+
+	ntc_table = di->pdata->ntc_table;
+	ntc_size = di->pdata->ntc_size;
+	di->temperature = VIRTUAL_TEMPERATURE;
+
+	if (ntc_size) {
+		res = rk818_bat_get_ntc_res(di);
+		if (res < ntc_table[ntc_size - 1]) {
+			di->temperature = di->pdata->ntc_degree_from +
+					  di->pdata->ntc_size - 1;
+			BAT_INFO("bat ntc upper max degree: R=%d\n", res);
+		} else if (res > ntc_table[0]) {
+			di->temperature = di->pdata->ntc_degree_from;
+			BAT_INFO("bat ntc lower min degree: R=%d\n", res);
+		} else {
+			for (i = 0; i < ntc_size; i++) {
+				if (res >= ntc_table[i])
+					break;
+			}
+
+			/* if first in, init old_temp */
+			temp = (i + di->pdata->ntc_degree_from) * 10;
+			if (first_time == 1) {
+				di->temperature = temp;
+				old_temp = temp;
+				first_time = 0;
+			}
+
+			/*
+			 * compare with old one, it's invalid when over 50
+			 * and we should use old data.
+			 */
+			if (abs(temp - old_temp) > 50)
+				temp = old_temp;
+			else
+				old_temp = temp;
+
+			di->temperature = temp;
+			DBG("<%s>. temperature = %d\n",
+			    __func__, di->temperature);
+			rk818_bat_temp_notifier_callback(di->temperature / 10);
+		}
+	}
+}
+
+static void rk818_bat_init_dsoc_algorithm(struct rk818_battery *di)
+{
+	u8 buf;
+	int16_t rest = 0;
+	unsigned long soc_sec;
+	const char *mode_name[] = { "MODE_ZERO", "MODE_FINISH",
+		"MODE_SMOOTH_CHRG", "MODE_SMOOTH_DISCHRG", "MODE_SMOOTH", };
+
+	/* get rest */
+	rest |= rk818_bat_read(di, RK818_CALC_REST_REGH) << 8;
+	rest |= rk818_bat_read(di, RK818_CALC_REST_REGL) << 0;
+
+	/* get mode */
+	buf = rk818_bat_read(di, RK818_MISC_MARK_REG);
+	di->algo_rest_mode = (buf & ALGO_REST_MODE_MSK) >> ALGO_REST_MODE_SHIFT;
+
+	if (rk818_bat_get_chrg_status(di) == CHARGE_FINISH) {
+		if (di->algo_rest_mode == MODE_FINISH) {
+			soc_sec = di->fcc * 3600 / 100 / FINISH_CHRG_CUR1;
+			if ((rest / DIV(soc_sec)) > 0) {
+				if (di->dsoc < 100) {
+					di->dsoc++;
+					di->algo_rest_val = rest % soc_sec;
+					BAT_INFO("algorithm rest(%d) dsoc "
+						 "inc: %d\n",
+						 rest, di->dsoc);
+				} else {
+					di->algo_rest_val = 0;
+				}
+			} else {
+				di->algo_rest_val = rest;
+			}
+		} else {
+			di->algo_rest_val = rest;
+		}
+	} else {
+		/* charge speed up */
+		if ((rest / 1000) > 0 && rk818_bat_chrg_online(di)) {
+			if (di->dsoc < di->rsoc) {
+				di->dsoc++;
+				di->algo_rest_val = rest % 1000;
+				BAT_INFO("algorithm rest(%d) dsoc inc: %d\n",
+					 rest, di->dsoc);
+			} else {
+				di->algo_rest_val = 0;
+			}
+		/* discharge speed up */
+		} else if (((rest / 1000) < 0) && !rk818_bat_chrg_online(di)) {
+			if (di->dsoc > di->rsoc) {
+				di->dsoc--;
+				di->algo_rest_val = rest % 1000;
+				BAT_INFO("algorithm rest(%d) dsoc sub: %d\n",
+					 rest, di->dsoc);
+			} else {
+				di->algo_rest_val = 0;
+			}
+		} else {
+			di->algo_rest_val = rest;
+		}
+	}
+
+	if (di->dsoc >= 100)
+		di->dsoc = 100;
+	else if (di->dsoc <= 0)
+		di->dsoc = 0;
+
+	/* init current mode */
+	di->voltage_avg = rk818_bat_get_avg_voltage(di);
+	di->current_avg = rk818_bat_get_avg_current(di);
+	if (rk818_bat_get_chrg_status(di) == CHARGE_FINISH) {
+		rk818_bat_finish_algo_prepare(di);
+		di->work_mode = MODE_FINISH;
+	} else {
+		rk818_bat_smooth_algo_prepare(di);
+		di->work_mode = MODE_SMOOTH;
+	}
+
+	DBG("<%s>. init: org_rest=%d, rest=%d, mode=%s; "
+	    "doc(x1000): zero=%d, chrg=%d, dischrg=%d, finish=%lu\n",
+	    __func__, rest, di->algo_rest_val, mode_name[di->algo_rest_mode],
+	    di->zero_dsoc, di->sm_chrg_dsoc, di->sm_dischrg_dsoc,
+	    di->finish_base);
+}
+
+static void rk818_bat_save_algo_rest(struct rk818_battery *di)
+{
+	u8 buf, mode;
+	int16_t algo_rest = 0;
+	int tmp_soc;
+	int zero_rest = 0, sm_chrg_rest = 0;
+	int sm_dischrg_rest = 0, finish_rest = 0;
+	const char *mode_name[] = { "MODE_ZERO", "MODE_FINISH",
+		"MODE_SMOOTH_CHRG", "MODE_SMOOTH_DISCHRG", "MODE_SMOOTH", };
+
+	/* zero dischrg */
+	tmp_soc = (di->zero_dsoc) / 1000;
+	if (tmp_soc == di->dsoc)
+		zero_rest = di->zero_dsoc - ((di->dsoc + 1) * 1000 -
+				MIN_ACCURACY);
+
+	/* sm chrg */
+	tmp_soc = di->sm_chrg_dsoc / 1000;
+	if (tmp_soc == di->dsoc)
+		sm_chrg_rest = di->sm_chrg_dsoc - di->dsoc * 1000;
+
+	/* sm dischrg */
+	tmp_soc = (di->sm_dischrg_dsoc) / 1000;
+	if (tmp_soc == di->dsoc)
+		sm_dischrg_rest = di->sm_dischrg_dsoc - ((di->dsoc + 1) * 1000 -
+				MIN_ACCURACY);
+
+	/* last time is also finish chrg, then add last rest */
+	if (di->algo_rest_mode == MODE_FINISH && di->algo_rest_val)
+		finish_rest = base2sec(di->finish_base) + di->algo_rest_val;
+	else
+		finish_rest = base2sec(di->finish_base);
+
+	/* total calc */
+	if ((rk818_bat_chrg_online(di) && (di->dsoc > di->rsoc)) ||
+	    (!rk818_bat_chrg_online(di) && (di->dsoc < di->rsoc)) ||
+	    (di->dsoc == di->rsoc)) {
+		di->algo_rest_val = 0;
+		algo_rest = 0;
+		DBG("<%s>. step1..\n", __func__);
+	} else if (di->work_mode == MODE_FINISH) {
+		algo_rest = finish_rest;
+		DBG("<%s>. step2..\n", __func__);
+	} else if (di->algo_rest_mode == MODE_FINISH) {
+		algo_rest = zero_rest + sm_dischrg_rest + sm_chrg_rest;
+		DBG("<%s>. step3..\n", __func__);
+	} else {
+		if (rk818_bat_chrg_online(di) && (di->dsoc < di->rsoc))
+			algo_rest = sm_chrg_rest + di->algo_rest_val;
+		else if (!rk818_bat_chrg_online(di) && (di->dsoc > di->rsoc))
+			algo_rest = zero_rest + sm_dischrg_rest +
+				    di->algo_rest_val;
+		else
+			algo_rest = zero_rest + sm_dischrg_rest + sm_chrg_rest +
+				    di->algo_rest_val;
+		DBG("<%s>. step4..\n", __func__);
+	}
+
+	/* check mode */
+	if ((di->work_mode == MODE_FINISH) || (di->work_mode == MODE_ZERO)) {
+		mode = di->work_mode;
+	} else {/* MODE_SMOOTH */
+		if (di->sm_linek > 0)
+			mode = MODE_SMOOTH_CHRG;
+		else
+			mode = MODE_SMOOTH_DISCHRG;
+	}
+
+	/* save mode */
+	buf = rk818_bat_read(di, RK818_MISC_MARK_REG);
+	buf &= ~ALGO_REST_MODE_MSK;
+	buf |= (mode << ALGO_REST_MODE_SHIFT);
+	rk818_bat_write(di, RK818_MISC_MARK_REG, buf);
+
+	/* save rest */
+	buf = (algo_rest >> 8) & 0xff;
+	rk818_bat_write(di, RK818_CALC_REST_REGH, buf);
+	buf = (algo_rest >> 0) & 0xff;
+	rk818_bat_write(di, RK818_CALC_REST_REGL, buf);
+
+	DBG("<%s>. rest: algo=%d, mode=%s, last_rest=%d; zero=%d, "
+	    "chrg=%d, dischrg=%d, finish=%lu\n",
+	    __func__, algo_rest, mode_name[mode], di->algo_rest_val, zero_rest,
+	    sm_chrg_rest, sm_dischrg_rest, base2sec(di->finish_base));
+}
+
+static void rk818_bat_save_data(struct rk818_battery *di)
+{
+	rk818_bat_save_dsoc(di, di->dsoc);
+	rk818_bat_save_cap(di, di->remain_cap);
+	rk818_bat_save_algo_rest(di);
+}
+
+static void rk818_battery_work(struct work_struct *work)
+{
+	struct rk818_battery *di =
+		container_of(work, struct rk818_battery, bat_delay_work.work);
+
+	rk818_bat_update_info(di);
+	rk818_bat_wait_finish_sig(di);
+	rk818_bat_rsoc_daemon(di);
+	rk818_bat_update_temperature(di);
+	rk818_bat_display_smooth(di);
+	rk818_bat_power_supply_changed(di);
+	rk818_bat_save_data(di);
+	rk818_bat_debug_info(di);
+
+	queue_delayed_work(di->bat_monitor_wq, &di->bat_delay_work,
+			   msecs_to_jiffies(di->monitor_ms));
+}
+
+static irqreturn_t rk818_vb_low_irq(int irq, void *bat)
+{
+	struct rk818_battery *di = (struct rk818_battery *)bat;
+
+	di->dsoc = 0;
+	rk_send_wakeup_key();
+	BAT_INFO("lower power yet, power off system! v=%d, c=%d, dsoc=%d\n",
+		 di->voltage_avg, di->current_avg, di->dsoc);
+
+	return IRQ_HANDLED;
+}
+
+static void rk818_bat_init_sysfs(struct rk818_battery *di)
+{
+	int i, ret;
+
+	for (i = 0; i < ARRAY_SIZE(rk818_bat_attr); i++) {
+		ret = sysfs_create_file(&di->dev->kobj,
+					&rk818_bat_attr[i].attr);
+		if (ret)
+			dev_err(di->dev, "create bat node(%s) error\n",
+				rk818_bat_attr[i].attr.name);
+	}
+}
+
+static int rk818_bat_init_irqs(struct rk818_battery *di)
+{
+	struct rk808 *rk818 = di->rk818;
+	struct platform_device *pdev = di->pdev;
+	int ret, vb_lo_irq;
+
+	vb_lo_irq = regmap_irq_get_virq(rk818->irq_data, RK818_IRQ_VB_LO);
+	if (vb_lo_irq < 0) {
+		dev_err(di->dev, "vb_lo_irq request failed!\n");
+		return vb_lo_irq;
+	}
+
+	ret = devm_request_threaded_irq(di->dev, vb_lo_irq, NULL,
+					rk818_vb_low_irq,
+					IRQF_TRIGGER_HIGH | IRQF_ONESHOT,
+					"rk818_vb_low", di);
+	if (ret) {
+		dev_err(&pdev->dev, "vb_lo_irq request failed!\n");
+		return ret;
+	}
+	enable_irq_wake(vb_lo_irq);
+
+	return 0;
+}
+
+static void rk818_bat_init_info(struct rk818_battery *di)
+{
+	di->design_cap = di->pdata->design_capacity;
+	di->qmax = di->pdata->design_qmax;
+	di->bat_res = di->pdata->bat_res;
+	di->monitor_ms = di->pdata->monitor_sec * TIMER_MS_COUNTS;
+	di->boot_base = POWER_ON_SEC_BASE;
+	di->res_div = (di->pdata->sample_res == SAMPLE_RES_20MR) ?
+		       SAMPLE_RES_DIV1 : SAMPLE_RES_DIV2;
+}
+
+static time64_t rk818_get_rtc_sec(void)
+{
+	int err;
+	struct rtc_time tm;
+	struct rtc_device *rtc = rtc_class_open(CONFIG_RTC_HCTOSYS_DEVICE);
+
+	err = rtc_read_time(rtc, &tm);
+	if (err) {
+		dev_err(rtc->dev.parent, "read hardware clk failed\n");
+		return 0;
+	}
+
+	err = rtc_valid_tm(&tm);
+	if (err) {
+		dev_err(rtc->dev.parent, "invalid date time\n");
+		return 0;
+	}
+
+	return rtc_tm_to_time64(&tm);
+}
+
+static int rk818_bat_rtc_sleep_sec(struct rk818_battery *di)
+{
+	int interval_sec;
+
+	interval_sec = rk818_get_rtc_sec() - di->rtc_base;
+
+	return (interval_sec > 0) ? interval_sec : 0;
+}
+
+static void rk818_bat_set_shtd_vol(struct rk818_battery *di)
+{
+	u8 val;
+
+	/* set vbat lowest 3.0v shutdown */
+	val = rk818_bat_read(di, RK818_VB_MON_REG);
+	val &= ~(VBAT_LOW_VOL_MASK | VBAT_LOW_ACT_MASK);
+	val |= (RK818_VBAT_LOW_3V0 | EN_VABT_LOW_SHUT_DOWN);
+	rk818_bat_write(di, RK818_VB_MON_REG, val);
+
+	/* disable low irq */
+	rk818_bat_set_bits(di, RK818_INT_STS_MSK_REG1,
+			   VB_LOW_INT_EN, VB_LOW_INT_EN);
+}
+
+static void rk818_bat_init_fg(struct rk818_battery *di)
+{
+	rk818_bat_enable_gauge(di);
+	rk818_bat_init_voltage_kb(di);
+	rk818_bat_init_coffset(di);
+	rk818_bat_set_relax_sample(di);
+	rk818_bat_set_ioffset_sample(di);
+	rk818_bat_set_ocv_sample(di);
+	rk818_bat_init_ts1_detect(di);
+	rk818_bat_init_rsoc(di);
+	rk818_bat_init_coulomb_cap(di, di->nac);
+	rk818_bat_init_age_algorithm(di);
+	rk818_bat_init_chrg_config(di);
+	rk818_bat_set_shtd_vol(di);
+	rk818_bat_init_zero_table(di);
+	rk818_bat_init_caltimer(di);
+	rk818_bat_init_dsoc_algorithm(di);
+
+	di->voltage_avg = rk818_bat_get_avg_voltage(di);
+	di->voltage_ocv = rk818_bat_get_ocv_voltage(di);
+	di->voltage_relax = rk818_bat_get_relax_voltage(di);
+	di->current_avg = rk818_bat_get_avg_current(di);
+	di->remain_cap = rk818_bat_get_coulomb_cap(di);
+	di->dbg_pwr_dsoc = di->dsoc;
+	di->dbg_pwr_rsoc = di->rsoc;
+	di->dbg_pwr_vol = di->voltage_avg;
+
+	rk818_bat_dump_regs(di, 0x99, 0xee);
+	DBG("nac=%d cap=%d ov=%d v=%d rv=%d dl=%d rl=%d c=%d\n",
+	    di->nac, di->remain_cap, di->voltage_ocv, di->voltage_avg,
+	    di->voltage_relax, di->dsoc, di->rsoc, di->current_avg);
+}
+
+#ifdef CONFIG_OF
+static int rk818_bat_parse_dt(struct rk818_battery *di)
+{
+	u32 out_value;
+	int length, ret;
+	size_t size;
+	struct device_node *np = di->dev->of_node;
+	struct battery_platform_data *pdata;
+	struct device *dev = di->dev;
+
+	pdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);
+	if (!pdata)
+		return -ENOMEM;
+
+	di->pdata = pdata;
+	/* init default param */
+	pdata->bat_res = DEFAULT_BAT_RES;
+	pdata->monitor_sec = DEFAULT_MONITOR_SEC;
+	pdata->pwroff_vol = DEFAULT_PWROFF_VOL_THRESD;
+	pdata->sleep_exit_current = DEFAULT_SLP_EXIT_CUR;
+	pdata->sleep_enter_current = DEFAULT_SLP_ENTER_CUR;
+	pdata->bat_mode = MODE_BATTARY;
+	pdata->max_soc_offset = DEFAULT_MAX_SOC_OFFSET;
+	pdata->sample_res = DEFAULT_SAMPLE_RES;
+	pdata->energy_mode = DEFAULT_ENERGY_MODE;
+	pdata->fb_temp = DEFAULT_FB_TEMP;
+	pdata->zero_reserve_dsoc = DEFAULT_ZERO_RESERVE_DSOC;
+
+	/* parse necessary param */
+	if (!of_find_property(np, "ocv_table", &length)) {
+		dev_err(dev, "ocv_table not found!\n");
+		return -EINVAL;
+	}
+
+	pdata->ocv_size = length / sizeof(u32);
+	if (pdata->ocv_size <= 0) {
+		dev_err(dev, "invalid ocv table\n");
+		return -EINVAL;
+	}
+
+	size = sizeof(*pdata->ocv_table) * pdata->ocv_size;
+	pdata->ocv_table = devm_kzalloc(di->dev, size, GFP_KERNEL);
+	if (!pdata->ocv_table)
+		return -ENOMEM;
+
+	ret = of_property_read_u32_array(np, "ocv_table",
+					 pdata->ocv_table,
+					 pdata->ocv_size);
+	if (ret < 0)
+		return ret;
+
+	ret = of_property_read_u32(np, "design_capacity", &out_value);
+	if (ret < 0) {
+		dev_err(dev, "design_capacity not found!\n");
+		return ret;
+	}
+	pdata->design_capacity = out_value;
+
+	ret = of_property_read_u32(np, "design_qmax", &out_value);
+	if (ret < 0) {
+		dev_err(dev, "design_qmax not found!\n");
+		return ret;
+	}
+	pdata->design_qmax = out_value;
+	ret = of_property_read_u32(np, "max_chrg_voltage", &out_value);
+	if (ret < 0) {
+		dev_err(dev, "max_chrg_voltage missing!\n");
+		return ret;
+	}
+	pdata->max_chrg_voltage = out_value;
+	if (out_value >= 4300)
+		pdata->zero_algorithm_vol = DEFAULT_ALGR_VOL_THRESD2;
+	else
+		pdata->zero_algorithm_vol = DEFAULT_ALGR_VOL_THRESD1;
+
+	ret = of_property_read_u32(np, "fb_temperature", &pdata->fb_temp);
+	if (ret < 0)
+		dev_err(dev, "fb_temperature missing!\n");
+
+	ret = of_property_read_u32(np, "sample_res", &pdata->sample_res);
+	if (ret < 0)
+		dev_err(dev, "sample_res missing!\n");
+
+	ret = of_property_read_u32(np, "energy_mode", &pdata->energy_mode);
+	if (ret < 0)
+		dev_err(dev, "energy_mode missing!\n");
+
+	ret = of_property_read_u32(np, "max_soc_offset",
+				   &pdata->max_soc_offset);
+	if (ret < 0)
+		dev_err(dev, "max_soc_offset missing!\n");
+
+	ret = of_property_read_u32(np, "monitor_sec", &pdata->monitor_sec);
+	if (ret < 0)
+		dev_err(dev, "monitor_sec missing!\n");
+
+	ret = of_property_read_u32(np, "zero_algorithm_vol",
+				   &pdata->zero_algorithm_vol);
+	if (ret < 0)
+		dev_err(dev, "zero_algorithm_vol missing!\n");
+
+	ret = of_property_read_u32(np, "zero_reserve_dsoc",
+				  &pdata->zero_reserve_dsoc);
+
+	ret = of_property_read_u32(np, "virtual_power", &pdata->bat_mode);
+	if (ret < 0)
+		dev_err(dev, "virtual_power missing!\n");
+
+	ret = of_property_read_u32(np, "bat_res", &pdata->bat_res);
+	if (ret < 0)
+		dev_err(dev, "bat_res missing!\n");
+
+	ret = of_property_read_u32(np, "sleep_enter_current",
+				   &pdata->sleep_enter_current);
+	if (ret < 0)
+		dev_err(dev, "sleep_enter_current missing!\n");
+
+	ret = of_property_read_u32(np, "sleep_exit_current",
+				   &pdata->sleep_exit_current);
+	if (ret < 0)
+		dev_err(dev, "sleep_exit_current missing!\n");
+
+	ret = of_property_read_u32(np, "power_off_thresd", &pdata->pwroff_vol);
+	if (ret < 0)
+		dev_err(dev, "power_off_thresd missing!\n");
+
+	if (!of_find_property(np, "ntc_table", &length)) {
+		pdata->ntc_size = 0;
+	} else {
+		/* get ntc degree base value */
+		ret = of_property_read_u32_index(np, "ntc_degree_from", 1,
+						 &pdata->ntc_degree_from);
+		if (ret) {
+			dev_err(dev, "invalid ntc_degree_from\n");
+			return -EINVAL;
+		}
+
+		of_property_read_u32_index(np, "ntc_degree_from", 0,
+					   &out_value);
+		if (out_value)
+			pdata->ntc_degree_from = -pdata->ntc_degree_from;
+
+		pdata->ntc_size = length / sizeof(u32);
+	}
+
+	if (pdata->ntc_size) {
+		size = sizeof(*pdata->ntc_table) * pdata->ntc_size;
+		pdata->ntc_table = devm_kzalloc(di->dev, size, GFP_KERNEL);
+		if (!pdata->ntc_table)
+			return -ENOMEM;
+
+		ret = of_property_read_u32_array(np, "ntc_table",
+						 pdata->ntc_table,
+						 pdata->ntc_size);
+		if (ret < 0)
+			return ret;
+	}
+
+	DBG("the battery dts info dump:\n"
+	    "bat_res:%d\n"
+	    "design_capacity:%d\n"
+	    "design_qmax :%d\n"
+	    "sleep_enter_current:%d\n"
+	    "sleep_exit_current:%d\n"
+	    "zero_algorithm_vol:%d\n"
+	    "zero_reserve_dsoc:%d\n"
+	    "monitor_sec:%d\n"
+	    "max_soc_offset:%d\n"
+	    "virtual_power:%d\n"
+	    "pwroff_vol:%d\n"
+	    "sample_res:%d\n"
+	    "ntc_size=%d\n"
+	    "ntc_degree_from:%d\n"
+	    "ntc_degree_to:%d\n",
+	    pdata->bat_res, pdata->design_capacity, pdata->design_qmax,
+	    pdata->sleep_enter_current, pdata->sleep_exit_current,
+	    pdata->zero_algorithm_vol, pdata->zero_reserve_dsoc,
+	    pdata->monitor_sec,
+	    pdata->max_soc_offset, pdata->bat_mode, pdata->pwroff_vol,
+	    pdata->sample_res, pdata->ntc_size, pdata->ntc_degree_from,
+	    pdata->ntc_degree_from + pdata->ntc_size - 1
+	    );
+
+	return 0;
+}
+#else
+static int rk818_bat_parse_dt(struct rk818_battery *di)
+{
+	return -ENODEV;
+}
+#endif
+
+static const struct of_device_id rk818_battery_of_match[] = {
+	{ .compatible = "rockchip,rk818-battery", },
+	{ },
+};
+
+static int rk818_battery_probe(struct platform_device *pdev)
+{
+	const struct of_device_id *of_id =
+			of_match_device(rk818_battery_of_match, &pdev->dev);
+	struct rk818_battery *di;
+	struct rk808 *rk818 = dev_get_drvdata(pdev->dev.parent);
+	int ret;
+
+	if (!of_id) {
+		dev_err(&pdev->dev, "Failed to find matching dt id\n");
+		return -ENODEV;
+	}
+
+	di = devm_kzalloc(&pdev->dev, sizeof(*di), GFP_KERNEL);
+	if (!di)
+		return -ENOMEM;
+
+	di->rk818 = rk818;
+	di->pdev = pdev;
+	di->dev = &pdev->dev;
+	di->regmap = rk818->regmap;
+	platform_set_drvdata(pdev, di);
+
+	ret = rk818_bat_parse_dt(di);
+	if (ret < 0) {
+		dev_err(di->dev, "rk818 battery parse dt failed!\n");
+		return ret;
+	}
+
+	if (!is_rk818_bat_exist(di)) {
+		di->pdata->bat_mode = MODE_VIRTUAL;
+		dev_err(di->dev, "no battery, virtual power mode\n");
+	}
+
+	ret = rk818_bat_init_irqs(di);
+	if (ret != 0) {
+		dev_err(di->dev, "rk818 bat init irqs failed!\n");
+		return ret;
+	}
+
+	ret = rk818_bat_init_power_supply(di);
+	if (ret) {
+		dev_err(di->dev, "rk818 power supply register failed!\n");
+		return ret;
+	}
+
+	rk818_bat_init_info(di);
+	rk818_bat_init_fg(di);
+	rk818_bat_init_sysfs(di);
+	rk818_bat_register_fb_notify(di);
+	//wake_lock_init(&di->wake_lock, WAKE_LOCK_SUSPEND, "rk818_bat_lock");
+	di->bat_monitor_wq = alloc_ordered_workqueue("%s",
+			WQ_MEM_RECLAIM | WQ_FREEZABLE, "rk818-bat-monitor-wq");
+	INIT_DELAYED_WORK(&di->bat_delay_work, rk818_battery_work);
+	queue_delayed_work(di->bat_monitor_wq, &di->bat_delay_work,
+			   msecs_to_jiffies(TIMER_MS_COUNTS * 5));
+
+	BAT_INFO("driver version %s\n", DRIVER_VERSION);
+
+	return ret;
+}
+
+static int rk818_battery_suspend(struct platform_device *dev,
+				 pm_message_t state)
+{
+	struct rk818_battery *di = platform_get_drvdata(dev);
+	u8 val, st;
+
+	cancel_delayed_work_sync(&di->bat_delay_work);
+
+	di->s2r = false;
+	di->sleep_chrg_online = rk818_bat_chrg_online(di);
+	di->sleep_chrg_status = rk818_bat_get_chrg_status(di);
+	di->current_avg = rk818_bat_get_avg_current(di);
+	di->remain_cap = rk818_bat_get_coulomb_cap(di);
+	di->rsoc = rk818_bat_get_rsoc(di);
+	di->rtc_base = rk818_get_rtc_sec();
+	rk818_bat_save_data(di);
+	st = (rk818_bat_read(di, RK818_SUP_STS_REG) & CHRG_STATUS_MSK) >> 4;
+
+	/* if not CHARGE_FINISH, reinit finish_base.
+	 * avoid sleep loop between suspend and resume
+	 */
+	if (di->sleep_chrg_status != CHARGE_FINISH)
+		di->finish_base = get_boot_sec();
+
+	/* avoid: enter suspend from MODE_ZERO: load from heavy to light */
+	if ((di->work_mode == MODE_ZERO) &&
+	    (di->sleep_chrg_online) && (di->current_avg >= 0)) {
+		DBG("suspend: MODE_ZERO exit...\n");
+		/* it need't do prepare for mode finish and smooth, it will
+		 * be done in display_smooth
+		 */
+		if (di->sleep_chrg_status == CHARGE_FINISH) {
+			di->work_mode = MODE_FINISH;
+			di->finish_base = get_boot_sec();
+		} else {
+			di->work_mode = MODE_SMOOTH;
+			rk818_bat_smooth_algo_prepare(di);
+		}
+	}
+
+	/* set vbat low than 3.4v to generate a wakeup irq */
+	val = rk818_bat_read(di, RK818_VB_MON_REG);
+	val &= (~(VBAT_LOW_VOL_MASK | VBAT_LOW_ACT_MASK));
+	val |= (RK818_VBAT_LOW_3V4 | EN_VBAT_LOW_IRQ);
+	rk818_bat_write(di, RK818_VB_MON_REG, val);
+	rk818_bat_set_bits(di, RK818_INT_STS_MSK_REG1, VB_LOW_INT_EN, 0);
+
+	BAT_INFO("suspend: dl=%d rl=%d c=%d v=%d cap=%d at=%ld ch=%d st=%s\n",
+		 di->dsoc, di->rsoc, di->current_avg,
+		 rk818_bat_get_avg_voltage(di), rk818_bat_get_coulomb_cap(di),
+		 di->sleep_dischrg_sec, di->sleep_chrg_online, bat_status[st]);
+
+	return 0;
+}
+
+static int rk818_battery_resume(struct platform_device *dev)
+{
+	struct rk818_battery *di = platform_get_drvdata(dev);
+	int interval_sec, time_step, pwroff_vol;
+	u8 val, st;
+
+	di->s2r = true;
+	di->current_avg = rk818_bat_get_avg_current(di);
+	di->voltage_relax = rk818_bat_get_relax_voltage(di);
+	di->voltage_avg = rk818_bat_get_avg_voltage(di);
+	di->remain_cap = rk818_bat_get_coulomb_cap(di);
+	di->rsoc = rk818_bat_get_rsoc(di);
+	interval_sec = rk818_bat_rtc_sleep_sec(di);
+	di->sleep_sum_sec += interval_sec;
+	pwroff_vol = di->pdata->pwroff_vol;
+	st = (rk818_bat_read(di, RK818_SUP_STS_REG) & CHRG_STATUS_MSK) >> 4;
+
+	if (!di->sleep_chrg_online) {
+		/* only add up discharge sleep seconds */
+		di->sleep_dischrg_sec += interval_sec;
+		if (di->voltage_avg <= pwroff_vol + 50)
+			time_step = DISCHRG_TIME_STEP1;
+		else
+			time_step = DISCHRG_TIME_STEP2;
+	}
+
+	BAT_INFO("resume: dl=%d rl=%d c=%d v=%d rv=%d "
+		 "cap=%d dt=%d at=%ld ch=%d st=%s\n",
+		 di->dsoc, di->rsoc, di->current_avg, di->voltage_avg,
+		 di->voltage_relax, rk818_bat_get_coulomb_cap(di), interval_sec,
+		 di->sleep_dischrg_sec, di->sleep_chrg_online, bat_status[st]);
+
+	/* sleep: enough time and discharge */
+	if ((di->sleep_dischrg_sec > time_step) && (!di->sleep_chrg_online)) {
+		if (rk818_bat_sleep_dischrg(di))
+			di->sleep_dischrg_sec = 0;
+	}
+
+	rk818_bat_save_data(di);
+
+	/* set vbat lowest 3.0v shutdown */
+	val = rk818_bat_read(di, RK818_VB_MON_REG);
+	val &= ~(VBAT_LOW_VOL_MASK | VBAT_LOW_ACT_MASK);
+	val |= (RK818_VBAT_LOW_3V0 | EN_VABT_LOW_SHUT_DOWN);
+	rk818_bat_write(di, RK818_VB_MON_REG, val);
+	rk818_bat_set_bits(di, RK818_INT_STS_MSK_REG1,
+			   VB_LOW_INT_EN, VB_LOW_INT_EN);
+
+	/* charge/lowpower lock: for battery work to update dsoc and rsoc */
+	// if ((di->sleep_chrg_online) ||
+	//     (!di->sleep_chrg_online && di->voltage_avg < di->pdata->pwroff_vol))
+	// 	wake_lock_timeout(&di->wake_lock, msecs_to_jiffies(2000));
+
+	queue_delayed_work(di->bat_monitor_wq, &di->bat_delay_work,
+			   msecs_to_jiffies(1000));
+
+	return 0;
+}
+
+static void rk818_battery_shutdown(struct platform_device *dev)
+{
+	u8 cnt = 0;
+	struct rk818_battery *di = platform_get_drvdata(dev);
+
+	cancel_delayed_work_sync(&di->bat_delay_work);
+	cancel_delayed_work_sync(&di->calib_delay_work);
+	rk818_bat_unregister_fb_notify(di);
+	del_timer(&di->caltimer);
+	if (base2sec(di->boot_base) < REBOOT_PERIOD_SEC)
+		cnt = rk818_bat_check_reboot(di);
+	else
+		rk818_bat_save_reboot_cnt(di, 0);
+
+	BAT_INFO("shutdown: dl=%d rl=%d c=%d v=%d cap=%d f=%d ch=%d n=%d "
+		 "mode=%d rest=%d\n",
+		 di->dsoc, di->rsoc, di->current_avg, di->voltage_avg,
+		 di->remain_cap, di->fcc, rk818_bat_chrg_online(di), cnt,
+		 di->algo_rest_mode, di->algo_rest_val);
+}
+
+static struct platform_driver rk818_battery_driver = {
+	.probe = rk818_battery_probe,
+	.suspend = rk818_battery_suspend,
+	.resume = rk818_battery_resume,
+	.shutdown = rk818_battery_shutdown,
+	.driver = {
+		.name = "rk818-battery",
+		.of_match_table = rk818_battery_of_match,
+	},
+};
+
+static int __init battery_init(void)
+{
+	return platform_driver_register(&rk818_battery_driver);
+}
+fs_initcall_sync(battery_init);
+
+static void __exit battery_exit(void)
+{
+	platform_driver_unregister(&rk818_battery_driver);
+}
+module_exit(battery_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:rk818-battery");
+MODULE_AUTHOR("chenjh<chenjh@rock-chips.com>");
diff -Nuar -r --no-dereference linux-5.15.139/drivers/power/supply/rk818_battery.h linux/drivers/power/supply/rk818_battery.h
--- linux-5.15.139/drivers/power/supply/rk818_battery.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/drivers/power/supply/rk818_battery.h	2024-01-03 16:06:25.935131000 +0800
@@ -0,0 +1,168 @@
+/*
+ * rk818_battery.h: fuel gauge driver structures
+ *
+ * Copyright (C) 2016 Rockchip Electronics Co., Ltd
+ * Author: chenjh <chenjh@rock-chips.com>
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ */
+
+#ifndef RK818_BATTERY
+#define RK818_BATTERY
+
+/* RK818_INT_STS_MSK_REG2 */
+#define PLUG_IN_MSK		BIT(0)
+#define PLUG_OUT_MSK		BIT(1)
+#define CHRG_CVTLMT_INT_MSK	BIT(6)
+
+/* RK818_TS_CTRL_REG */
+#define GG_EN			BIT(7)
+#define ADC_CUR_EN		BIT(6)
+#define ADC_TS1_EN		BIT(5)
+#define ADC_TS2_EN		BIT(4)
+#define TS1_CUR_MSK		0x03
+
+/* RK818_GGCON */
+#define OCV_SAMP_MIN_MSK	0x0c
+#define OCV_SAMP_8MIN		(0x00 << 2)
+
+#define ADC_CAL_MIN_MSK		0x30
+#define ADC_CAL_8MIN		(0x00 << 4)
+#define ADC_CUR_MODE		BIT(1)
+
+/* RK818_GGSTS */
+#define BAT_CON			BIT(4)
+#define RELAX_VOL1_UPD		BIT(3)
+#define RELAX_VOL2_UPD		BIT(2)
+#define RELAX_VOL12_UPD_MSK	(RELAX_VOL1_UPD | RELAX_VOL2_UPD)
+
+/* RK818_SUP_STS_REG */
+#define CHRG_STATUS_MSK		0x70
+#define BAT_EXS			BIT(7)
+#define CHARGE_OFF		(0x0 << 4)
+#define DEAD_CHARGE		(0x1 << 4)
+#define TRICKLE_CHARGE		(0x2 << 4)
+#define CC_OR_CV		(0x3 << 4)
+#define CHARGE_FINISH		(0x4 << 4)
+#define USB_OVER_VOL		(0x5 << 4)
+#define BAT_TMP_ERR		(0x6 << 4)
+#define TIMER_ERR		(0x7 << 4)
+#define USB_VLIMIT_EN		BIT(3)
+#define USB_CLIMIT_EN		BIT(2)
+#define USB_EXIST		BIT(1)
+#define USB_EFF			BIT(0)
+
+/* RK818_USB_CTRL_REG */
+#define CHRG_CT_EN		BIT(7)
+#define FINISH_CUR_MSK		0xc0
+#define TEMP_105C		(0x02 << 2)
+#define FINISH_100MA		(0x00 << 6)
+#define FINISH_150MA		(0x01 << 6)
+#define FINISH_200MA		(0x02 << 6)
+#define FINISH_250MA		(0x03 << 6)
+
+/* RK818_CHRG_CTRL_REG3 */
+#define CHRG_TERM_MODE_MSK	BIT(5)
+#define CHRG_TERM_ANA_SIGNAL	(0 << 5)
+#define CHRG_TERM_DIG_SIGNAL	BIT(5)
+#define CHRG_TIMER_CCCV_EN	BIT(2)
+#define CHRG_EN			BIT(7)
+
+/* RK818_VB_MON_REG */
+#define	RK818_VBAT_LOW_3V0      0x02
+#define	RK818_VBAT_LOW_3V4      0x06
+#define PLUG_IN_STS		BIT(6)
+
+/* RK818_THERMAL_REG */
+#define FB_TEMP_MSK		0x0c
+#define HOTDIE_STS		BIT(1)
+
+/* RK818_INT_STS_MSK_REG1 */
+#define VB_LOW_INT_EN		BIT(1)
+
+/* RK818_MISC_MARK_REG */
+#define FG_INIT			BIT(5)
+#define FG_RESET_LATE		BIT(4)
+#define FG_RESET_NOW		BIT(3)
+#define ALGO_REST_MODE_MSK	(0xc0)
+#define ALGO_REST_MODE_SHIFT	6
+
+/* bit shift */
+#define FB_TEMP_SHIFT		2
+
+/* parse ocv table param */
+#define TIMER_MS_COUNTS		1000
+#define MAX_PERCENTAGE		100
+#define MAX_INTERPOLATE		1000
+#define MAX_INT			0x7FFF
+
+#define DRIVER_VERSION		"7.1"
+
+struct battery_platform_data {
+	u32 *ocv_table;
+	u32 *zero_table;
+	u32 *ntc_table;
+	u32 ocv_size;
+	u32 max_chrg_voltage;
+	u32 ntc_size;
+	int ntc_degree_from;
+	u32 pwroff_vol;
+	u32 monitor_sec;
+	u32 zero_algorithm_vol;
+	u32 zero_reserve_dsoc;
+	u32 bat_res;
+	u32 design_capacity;
+	u32 design_qmax;
+	u32 sleep_enter_current;
+	u32 sleep_exit_current;
+	u32 max_soc_offset;
+	u32 sample_res;
+	u32 bat_mode;
+	u32 fb_temp;
+	u32 energy_mode;
+	u32 cccv_hour;
+	u32 ntc_uA;
+	u32 ntc_factor;
+};
+
+enum work_mode {
+	MODE_ZERO = 0,
+	MODE_FINISH,
+	MODE_SMOOTH_CHRG,
+	MODE_SMOOTH_DISCHRG,
+	MODE_SMOOTH,
+};
+
+enum bat_mode {
+	MODE_BATTARY = 0,
+	MODE_VIRTUAL,
+};
+
+static const u16 feedback_temp_array[] = {
+	85, 95, 105, 115
+};
+
+static const u16 chrg_vol_sel_array[] = {
+	4050, 4100, 4150, 4200, 4250, 4300, 4350
+};
+
+static const u16 chrg_cur_sel_array[] = {
+	1000, 1200, 1400, 1600, 1800, 2000, 2250, 2400, 2600, 2800, 3000
+};
+
+static const u16 chrg_cur_input_array[] = {
+	450, 80, 850, 1000, 1250, 1500, 1750, 2000, 2250, 2500, 2750, 3000
+};
+
+void kernel_power_off(void);
+int rk818_bat_temp_notifier_register(struct notifier_block *nb);
+int rk818_bat_temp_notifier_unregister(struct notifier_block *nb);
+
+#endif
\ 
diff -Nuar -r --no-dereference linux-5.15.139/drivers/char/Makefile linux/drivers/char/Makefile
--- linux-5.15.139/drivers/char/Makefile	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/char/Makefile	2024-01-03 16:06:25.935131000 +0800
@@ -11,6 +11,7 @@
 obj-$(CONFIG_MSPEC)		+= mspec.o
 obj-$(CONFIG_UV_MMTIMER)	+= uv_mmtimer.o
 obj-$(CONFIG_IBM_BSR)		+= bsr.o
+obj-$(CONFIG_ARCH_SUNXI)        += sunxi-sysinfo/
 
 obj-$(CONFIG_PRINTER)		+= lp.o
 
@@ -46,3 +47,4 @@
 obj-$(CONFIG_XILLYBUS_CLASS)	+= xillybus/
 obj-$(CONFIG_POWERNV_OP_PANEL)	+= powernv-op-panel.o
 obj-$(CONFIG_ADI)		+= adi.o
+obj-$(CONFIG_DUMP_REG)          += dump_reg/
diff -Nuar -r --no-dereference linux-5.15.139/drivers/char/Kconfig linux/drivers/char/Kconfig
--- linux-5.15.139/drivers/char/Kconfig	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/char/Kconfig	2024-01-03 16:06:25.935131000 +0800
@@ -131,6 +131,8 @@
 	  If unsure, say M here to build it as a module called powernv-op-panel.
 
 source "drivers/char/ipmi/Kconfig"
+source "drivers/char/sunxi-sysinfo/Kconfig"
+source "drivers/char/dump_reg/Kconfig"
 
 config DS1620
 	tristate "NetWinder thermometer support"
diff -Nuar -r --no-dereference linux-5.15.139/drivers/char/sunxi-sysinfo/sunxi-sysinfo.c linux/drivers/char/sunxi-sysinfo/sunxi-sysinfo.c
--- linux-5.15.139/drivers/char/sunxi-sysinfo/sunxi-sysinfo.c	1970-01-01 08:00:00.000000000 +0800
+++ linux/drivers/char/sunxi-sysinfo/sunxi-sysinfo.c	2024-01-03 16:06:25.935131000 +0800
@@ -0,0 +1,178 @@
+/*
+ * Based on drivers/char/sunxi-sysinfo/sunxi-sysinfo.c
+ *
+ * Copyright (C) 2015 Allwinnertech Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/module.h>
+#include <linux/printk.h>
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/vmalloc.h>
+#include <linux/uaccess.h>
+#include <linux/fs.h>
+#include <linux/miscdevice.h>
+#include <linux/compat.h>
+#include <linux/platform_device.h>
+#include <linux/of_platform.h>
+#include <linux/of.h>
+
+extern int sunxi_get_soc_chipid(unsigned char *chipid);
+extern int sunxi_get_serial(unsigned  char *serial);
+
+struct sunxi_info_quirks {
+	char * platform_name;
+};
+
+static const struct sunxi_info_quirks sun5i_h6_info_quirks = {
+	.platform_name  = "sun50i-h6",
+};
+
+static const struct sunxi_info_quirks sun5i_h616_info_quirks = {
+	.platform_name  = "sun50i-h616",
+};
+
+struct sunxi_info_quirks *quirks;
+
+static int soc_info_open(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static int soc_info_release(struct inode *inode, struct file *file)
+{
+	return 0;
+}
+
+static const struct file_operations soc_info_ops = {
+	.owner   = THIS_MODULE,
+	.open    = soc_info_open,
+	.release = soc_info_release,
+};
+
+struct miscdevice soc_info_device = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name  = "sunxi_soc_info",
+	.fops  = &soc_info_ops,
+};
+
+static ssize_t sys_info_show(struct class *class,
+			     struct class_attribute *attr, char *buf)
+{
+	int i;
+	int databuf[4] = {0};
+	char tmpbuf[129] = {0};
+	size_t size = 0;
+
+	/* platform */
+	size += sprintf(buf + size, "sunxi_platform    : %s\n", quirks->platform_name);
+
+	/* chipid */
+	sunxi_get_soc_chipid((u8 *)databuf);
+
+	for (i = 0; i < 4; i++)
+		sprintf(tmpbuf + i*8, "%08x", databuf[i]);
+	tmpbuf[128] = 0;
+	size += sprintf(buf + size, "sunxi_chipid      : %s\n", tmpbuf);
+
+	/* serial */
+	sunxi_get_serial((u8 *)databuf);
+	for (i = 0; i < 4; i++)
+		sprintf(tmpbuf + i*8, "%08x", databuf[i]);
+	tmpbuf[128] = 0;
+	size += sprintf(buf + size, "sunxi_serial      : %s\n", tmpbuf);
+
+	return size;
+}
+
+static struct class_attribute info_class_attrs[] = {
+	__ATTR(sys_info, 0644, sys_info_show, NULL),
+};
+
+static struct class info_class = {
+	.name           = "sunxi_info",
+	.owner          = THIS_MODULE,
+};
+
+static const struct of_device_id sunxi_info_match[] = {
+        {
+		.compatible = "allwinner,sun50i-h6-sys-info",
+		.data = &sun5i_h6_info_quirks,
+        },
+        {
+		.compatible = "allwinner,sun50i-h616-sys-info",
+		.data = &sun5i_h616_info_quirks,
+        },
+        {}
+};
+
+static int sunxi_info_probe(struct platform_device *pdev)
+{
+	int i, ret = 0;
+
+	quirks = of_device_get_match_data(&pdev->dev);
+	if (quirks == NULL) {
+		dev_err(&pdev->dev, "Failed to determine the quirks to use\n");
+		return -ENODEV;
+	}
+
+	ret = class_register(&info_class);
+	if (ret != 0)
+		return ret;
+
+	/* need some class specific sysfs attributes */
+	for (i = 0; i < ARRAY_SIZE(info_class_attrs); i++) {
+		ret = class_create_file(&info_class, &info_class_attrs[i]);
+		if (ret)
+			goto out_class_create_file_failed;
+	}
+
+	ret = misc_register(&soc_info_device);
+	if (ret != 0) {
+		pr_err("%s: misc_register() failed!(%d)\n", __func__, ret);
+		class_unregister(&info_class);
+		return ret;
+	}
+
+	return ret;
+
+out_class_create_file_failed:
+	class_unregister(&info_class);
+
+	return ret;
+}
+
+static int sunxi_info_remove(struct platform_device *pdev)
+{
+	misc_deregister(&soc_info_device);
+	class_unregister(&info_class);
+
+	return 0;
+}
+
+static struct platform_driver sunxi_info_driver = {
+        .probe  = sunxi_info_probe,
+        .remove = sunxi_info_remove,
+        .driver = {
+                .name   = "sunxi_info",
+                .owner  = THIS_MODULE,
+                .of_match_table = sunxi_info_match,
+        },
+};
+module_platform_driver(sunxi_info_driver);
+
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("xiafeng<xiafeng@allwinnertech.com>");
+MODULE_DESCRIPTION("sunxi sys info.");
diff -Nuar -r --no-dereference linux-5.15.139/drivers/char/sunxi-sysinfo/Makefile linux/drivers/char/sunxi-sysinfo/Makefile
--- linux-5.15.139/drivers/char/sunxi-sysinfo/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ linux/drivers/char/sunxi-sysinfo/Makefile	2024-01-03 16:06:25.935131000 +0800
@@ -0,0 +1,5 @@
+#
+# Makefile for sunxi system information driver
+#
+
+obj-$(CONFIG_SUNXI_SYS_INFO) += sunxi-sysinfo.o
diff -Nuar -r --no-dereference linux-5.15.139/drivers/char/sunxi-sysinfo/Kconfig linux/drivers/char/sunxi-sysinfo/Kconfig
--- linux-5.15.139/drivers/char/sunxi-sysinfo/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ linux/drivers/char/sunxi-sysinfo/Kconfig	2024-01-03 16:06:25.935131000 +0800
@@ -0,0 +1,10 @@
+#
+# sunxi system information driver.
+#
+
+config SUNXI_SYS_INFO
+	tristate "sunxi system info driver"
+	default y
+	help
+	  This driver is used for query system information.
+	  If you don't know whether need it, please select y.
diff -Nuar -r --no-dereference linux-5.15.139/drivers/char/dump_reg/dump_reg.c linux/drivers/char/dump_reg/dump_reg.c
--- linux-5.15.139/drivers/char/dump_reg/dump_reg.c	1970-01-01 08:00:00.000000000 +0800
+++ linux/drivers/char/dump_reg/dump_reg.c	2024-01-03 16:06:25.935131000 +0800
@@ -0,0 +1,888 @@
+/*
+ * dump registers sysfs driver
+ *
+ * Copyright(c) 2015-2018 Allwinnertech Co., Ltd.
+ *      http://www.allwinnertech.com
+ *
+ * Author: Liugang <liugang@allwinnertech.com>
+ *         Xiafeng <xiafeng@allwinnertech.com>
+ *         Martin <wuyan@allwinnertech.com>
+ *         Lewis  <liuyu@allwinnertech.com>
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/kdev_t.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/miscdevice.h>
+#include <linux/seq_file.h>
+#include <linux/platform_device.h>
+#include <linux/sysfs.h>
+#include <linux/mod_devicetable.h>
+#include "dump_reg.h"
+
+/* the register and vaule to be test by dump_reg */
+static u32 test_addr;
+static u32 test_size;
+static struct class *dump_class;
+
+/* Access in byte mode ? 1: byte-mode, 0: word-mode */
+static unsigned int rw_byte_mode;
+
+/* for dump_reg class */
+static struct dump_addr dump_para;
+static struct write_group *wt_group;
+static struct compare_group *cmp_group;
+
+static u32 _read(void __iomem *vaddr)
+{
+	if (rw_byte_mode)
+		return (u32)readb(vaddr);
+	else
+		return readl(vaddr);
+}
+
+static void _write(u32 val, void __iomem *vaddr)
+{
+	if (rw_byte_mode)
+		writeb((u8)val, vaddr);
+	else
+		writel(val, vaddr);
+}
+
+static void __iomem *_io_remap(unsigned long paddr, size_t size)
+{
+	return ioremap(paddr, size);
+}
+
+static void _io_unmap(void __iomem *vaddr)
+{
+	iounmap(vaddr);
+}
+
+static void __iomem *_mem_remap(unsigned long paddr, size_t size)
+{
+	return (void __iomem *)phys_to_virt(paddr);
+}
+
+/*
+ * Convert a physical address (which is already mapped) to virtual address
+ */
+static void __iomem *_get_vaddr(struct dump_addr *dump_addr, unsigned long uaddr)
+{
+	unsigned long offset = uaddr - dump_addr->uaddr_start;
+	return (void __iomem *)(dump_addr->vaddr_start + offset);
+}
+
+const struct dump_struct dump_table[] = {
+	{
+		.addr_start = SUNXI_IO_PHYS_START,
+		.addr_end   = SUNXI_IO_PHYS_END,
+		.remap = _io_remap,
+		.unmap = _io_unmap,
+		.get_vaddr = _get_vaddr,
+		.read  = _read,
+		.write = _write,
+	},
+	{
+		.addr_start = SUNXI_PLAT_PHYS_START,
+		.addr_end   = SUNXI_PLAT_PHYS_END,
+		.remap = _mem_remap,
+		.unmap = NULL,
+		.get_vaddr = _get_vaddr,
+		.read  = _read,
+		.write = _write,
+	},
+#if defined(SUNXI_IOMEM_START)
+	{
+		.addr_start = SUNXI_IOMEM_START,
+		.addr_end   = SUNXI_IOMEM_END,
+		.remap = NULL,  /* .remap = NULL: uaddr is a virtual address */
+		.unmap = NULL,
+		.get_vaddr = _get_vaddr,
+		.read  = _read,
+		.write = _write,
+	},
+#endif
+	{
+		.addr_start = SUNXI_MEM_PHYS_START,
+		.addr_end   = SUNXI_MEM_PHYS_END,
+		.remap = NULL,  /* .remap = NULL: uaddr is a virtual address */
+		.unmap = NULL,
+		.get_vaddr = _get_vaddr,
+		.read  = _read,
+		.write = _write,
+	},
+};
+EXPORT_SYMBOL(dump_table);
+
+/**
+ * __addr_valid - check if @uaddr is valid.
+ * @uaddr: addr to judge.
+ *
+ * return index if @addr is valid, -ENXIO if not.
+ */
+int __addr_valid(unsigned long uaddr)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(dump_table); i++)
+		if (uaddr >= dump_table[i].addr_start &&
+		    uaddr <= dump_table[i].addr_end)
+			return i;
+	return -ENXIO;
+}
+EXPORT_SYMBOL(__addr_valid);
+
+/**
+ * __dump_regs_ex - dump a range of registers' value, copy to buf.
+ * @dump_addr: start and end address of registers.
+ * @buf: store the dump info.
+ * @buf_size: buf size
+ *
+ * return bytes written to buf, <=0 indicate err
+ */
+ssize_t __dump_regs_ex(struct dump_addr *dump_addr, char *buf, ssize_t buf_size)
+{
+	int index;
+	ssize_t cnt = 0;
+	unsigned long uaddr;
+	unsigned long remap_size;
+	const struct dump_struct *dump;
+
+	/* Make the address 4-bytes aligned */
+	dump_addr->uaddr_start &= (~0x3UL);
+	dump_addr->uaddr_end &= (~0x3UL);
+	remap_size = dump_addr->uaddr_end - dump_addr->uaddr_start + 4;
+
+	index = __addr_valid(dump_addr->uaddr_start);
+	if ((index < 0) || (index != __addr_valid(dump_addr->uaddr_end)) ||
+	    (buf == NULL)) {
+		pr_err("%s(): Invalid para: index=%d, start=0x%lx, end=0x%lx, buf=0x%p\n",
+		       __func__, index, dump_addr->uaddr_start, dump_addr->uaddr_end, buf);
+		return -EIO;
+	}
+
+	dump = &dump_table[index];
+	if (dump->remap) {
+		dump_addr->vaddr_start = dump->remap(dump_addr->uaddr_start, remap_size);
+		if (!dump_addr->vaddr_start) {
+			pr_err("%s(): remap failed\n", __func__);
+			return -EIO;
+		}
+	} else  /* if (dump->remap = NULL), then treat uaddr as a virtual address */
+		dump_addr->vaddr_start = (void __iomem *)dump_addr->uaddr_start;
+
+	if (dump_addr->uaddr_start == dump_addr->uaddr_end) {
+		cnt = sprintf(buf, "0x%08x\n", dump->read(dump_addr->vaddr_start));
+		goto out;
+	}
+
+	for (uaddr = (dump_addr->uaddr_start & ~0x0F); uaddr <= dump_addr->uaddr_end;
+	     uaddr += 4) {
+		if (!(uaddr & 0x0F))
+			cnt += snprintf(buf + cnt, buf_size - cnt,
+				     "\n" PRINT_ADDR_FMT ":", uaddr);
+
+		if (cnt >= buf_size) {
+			pr_warn("Range too large, strings buffer overflow\n");
+			cnt = buf_size;
+			goto out;
+		}
+
+		if (uaddr < dump_addr->uaddr_start)  /* Don't show unused uaddr */
+			/* "0x12345678 ", 11 space */
+			cnt += snprintf(buf + cnt, buf_size - cnt, "           ");
+		else
+			cnt += snprintf(buf + cnt, buf_size - cnt, " 0x%08x",
+				dump->read(dump->get_vaddr(dump_addr, uaddr)));
+	}
+	cnt += snprintf(buf + cnt, buf_size - cnt, "\n");
+
+	pr_debug("%s(): start=0x%lx, end=0x%lx, return=%zd\n", __func__,
+		 dump_addr->uaddr_start, dump_addr->uaddr_end, cnt);
+
+out:
+	if (dump->unmap)
+		dump->unmap(dump_addr->vaddr_start);
+
+	return cnt;
+}
+EXPORT_SYMBOL(__dump_regs_ex);
+
+/**
+ * __parse_dump_str - parse the input string for dump attri.
+ * @buf: the input string, eg: "0x01c20000,0x01c20300".
+ * @size: buf size.
+ * @start: store the start reg's addr parsed from buf, eg 0x01c20000.
+ * @end: store the end reg's addr parsed from buf, eg 0x01c20300.
+ *
+ * return 0 if success, otherwise failed.
+ */
+int __parse_dump_str(const char *buf, size_t size,
+			    unsigned long *start, unsigned long *end)
+{
+	char *ptr = NULL;
+	char *ptr2 = (char *)buf;
+	int ret = 0, times = 0;
+
+	/* Support single address mode, some time it haven't ',' */
+next:
+	/*
+	 * Default dump only one register(*start =*end).
+	 * If ptr is not NULL, we will cover the default value of end.
+	 */
+	if (times == 1)
+		*start = *end;
+
+	if (!ptr2 || (ptr2 - buf) >= size)
+		goto out;
+
+	ptr = ptr2;
+	ptr2 = strnchr(ptr, size - (ptr - buf), ',');
+	if (ptr2) {
+		*ptr2 = '\0';
+		ptr2++;
+	}
+
+	ptr = strim(ptr);
+	if (!strlen(ptr))
+		goto next;
+
+	ret = kstrtoul(ptr, 16, end);
+	if (!ret) {
+		times++;
+		goto next;
+	} else
+		pr_warn("String syntax errors: \"%s\"\n", ptr);
+
+out:
+	return ret;
+}
+EXPORT_SYMBOL(__parse_dump_str);
+
+/**
+ * __write_show - dump a register's value, copy to buf.
+ * @pgroup: the addresses to read.
+ * @buf: store the dump info.
+ *
+ * return bytes written to buf, <=0 indicate err.
+ */
+ssize_t __write_show(struct write_group *pgroup, char *buf, ssize_t len)
+{
+#define WR_DATA_FMT PRINT_ADDR_FMT"  0x%08x  %s"
+
+	int i = 0;
+	ssize_t cnt = 0;
+	unsigned long reg = 0;
+	u32 val;
+	u8 rval_buf[16];
+	struct dump_addr dump_addr;
+
+	if (!pgroup) {
+		pr_err("%s,%d err, pgroup is NULL!\n", __func__, __LINE__);
+		goto end;
+	}
+
+	cnt += snprintf(buf, len - cnt, WR_PRINT_FMT);
+	if (cnt > len) {
+		cnt = -EINVAL;
+		goto end;
+	}
+
+	for (i = 0; i < pgroup->num; i++) {
+		reg = pgroup->pitem[i].reg_addr;
+		val = pgroup->pitem[i].val;
+		dump_addr.uaddr_start = reg;
+		dump_addr.uaddr_end = reg;
+		if (__dump_regs_ex(&dump_addr, rval_buf, sizeof(rval_buf)) < 0)
+			return -EINVAL;
+
+		cnt +=
+		    snprintf(buf + cnt, len - cnt, WR_DATA_FMT, reg, val,
+			     rval_buf);
+		if (cnt > len) {
+			cnt = len;
+			goto end;
+		}
+	}
+
+end:
+	return cnt;
+}
+EXPORT_SYMBOL(__write_show);
+
+/**
+ * __parse_write_str - parse the input string for write attri.
+ * @str: string to be parsed, eg: "0x01c20818 0x55555555".
+ * @reg_addr: store the reg address. eg: 0x01c20818.
+ * @val: store the expect value. eg: 0x55555555.
+ *
+ * return 0 if success, otherwise failed.
+ */
+static int __parse_write_str(char *str, unsigned long *reg_addr, u32 *val)
+{
+	char *ptr = str;
+	char *tstr = NULL;
+	int ret = 0;
+
+	/*
+	 * Skip the leading whitespace, find the true split symbol.
+	 * And it must be 'address value'.
+	 */
+	tstr = strim(str);
+	ptr = strchr(tstr, ' ');
+	if (!ptr)
+		return -EINVAL;
+
+	/*
+	 * Replaced split symbol with a %NUL-terminator temporary.
+	 * Will be fixed at end.
+	 */
+	*ptr = '\0';
+	ret = kstrtoul(tstr, 16, reg_addr);
+	if (ret)
+		goto out;
+
+	ret = kstrtou32(skip_spaces(ptr + 1), 16, val);
+
+out:
+	return ret;
+}
+
+/**
+ * __write_item_init - init for write attri. parse input string,
+ *                     and construct write struct.
+ * @ppgroup: store the struct allocated, the struct contains items parsed from
+ *           input buf.
+ * @buf: input string, eg: "0x01c20800 0x00000031,0x01c20818 0x55555555,...".
+ * @size: buf size.
+ *
+ * return 0 if success, otherwise failed.
+ */
+int __write_item_init(struct write_group **ppgroup, const char *buf,
+			     size_t size)
+{
+	char *ptr, *ptr2;
+	unsigned long addr = 0;
+	u32 val;
+	struct write_group *pgroup;
+
+	/* alloc item buffer */
+	pgroup = kmalloc(sizeof(struct write_group), GFP_KERNEL);
+	if (!pgroup)
+		return -ENOMEM;
+
+	pgroup->pitem = kmalloc(sizeof(struct write_item) * MAX_WRITE_ITEM,
+				GFP_KERNEL);
+	if (!pgroup->pitem) {
+		kfree(pgroup);
+		return -ENOMEM;
+	}
+
+	pgroup->num = 0;
+	ptr = (char *)buf;
+	do {
+		ptr2 = strchr(ptr, ',');
+		if (ptr2)
+			*ptr2 = '\0';
+
+		if (!__parse_write_str(ptr, &addr, &val)) {
+			pgroup->pitem[pgroup->num].reg_addr = addr;
+			pgroup->pitem[pgroup->num].val = val;
+			pgroup->num++;
+		} else
+			pr_err("%s: Failed to parse string: %s\n", __func__,
+			       ptr);
+
+		if (!ptr2)
+			break;
+
+		ptr = ptr2 + 1;
+		*ptr2 = ',';
+
+	} while (pgroup->num <= MAX_WRITE_ITEM);
+
+	/* free buffer if no valid item */
+	if (pgroup->num == 0) {
+		kfree(pgroup->pitem);
+		kfree(pgroup);
+		return -EINVAL;
+	}
+
+	*ppgroup = pgroup;
+	return 0;
+}
+EXPORT_SYMBOL(__write_item_init);
+
+/**
+ * __write_item_deinit - reled_addrse memory that cred_addrted by
+ *                       __write_item_init.
+ * @pgroup: the write struct allocated in __write_item_init.
+ */
+void __write_item_deinit(struct write_group *pgroup)
+{
+	if (pgroup != NULL) {
+		if (pgroup->pitem != NULL)
+			kfree(pgroup->pitem);
+		kfree(pgroup);
+	}
+}
+EXPORT_SYMBOL(__write_item_deinit);
+
+/**
+ * __compare_regs_ex - dump a range of registers' value, copy to buf.
+ * @pgroup: addresses of registers.
+ * @buf: store the dump info.
+ *
+ * return bytes written to buf, <= 0 indicate err.
+ */
+ssize_t __compare_regs_ex(struct compare_group *pgroup, char *buf,
+				 ssize_t len)
+{
+#define CMP_DATAO_FMT PRINT_ADDR_FMT"  0x%08x  0x%08x  0x%08x  OK\n"
+#define CMP_DATAE_FMT PRINT_ADDR_FMT"  0x%08x  0x%08x  0x%08x  ERR\n"
+
+	int i;
+	ssize_t cnt = 0;
+	unsigned long reg;
+	u32 expect, actual, mask;
+	u8 actualb[16];
+	struct dump_addr dump_addr;
+
+	if (!pgroup) {
+		pr_err("%s,%d err, pgroup is NULL!\n", __func__, __LINE__);
+		goto end;
+	}
+
+	cnt += snprintf(buf, len - cnt, CMP_PRINT_FMT);
+	if (cnt > len) {
+		cnt = -EINVAL;
+		goto end;
+	}
+
+	for (i = 0; i < pgroup->num; i++) {
+		reg = pgroup->pitem[i].reg_addr;
+		expect = pgroup->pitem[i].val_expect;
+		dump_addr.uaddr_start = reg;
+		dump_addr.uaddr_end = reg;
+		if (__dump_regs_ex(&dump_addr, actualb, sizeof(actualb)) < 0)
+			return -EINVAL;
+
+		if (kstrtou32(actualb, 16, &actual))
+			return -EINVAL;
+
+		mask = pgroup->pitem[i].val_mask;
+		if ((actual & mask) == (expect & mask))
+			cnt +=
+			    snprintf(buf + cnt, len - cnt, CMP_DATAO_FMT, reg,
+				     expect, actual, mask);
+		else
+			cnt +=
+			    snprintf(buf + cnt, len - cnt, CMP_DATAE_FMT, reg,
+				     expect, actual, mask);
+		if (cnt > len) {
+			cnt = -EINVAL;
+			goto end;
+		}
+	}
+
+end:
+	return cnt;
+}
+EXPORT_SYMBOL(__compare_regs_ex);
+
+/**
+ * __parse_compare_str - parse the input string for compare attri.
+ * @str: string to be parsed, eg: "0x01c20000 0x80000011 0x00000011".
+ * @reg_addr: store the reg address. eg: 0x01c20000.
+ * @val_expect: store the expect value. eg: 0x80000011.
+ * @val_mask: store the mask value. eg: 0x00000011.
+ *
+ * return 0 if success, otherwise failed.
+ */
+static int __parse_compare_str(char *str, unsigned long *reg_addr,
+			       u32 *val_expect, u32 *val_mask)
+{
+	unsigned long result_addr[3] = { 0 };
+	char *ptr = str;
+	char *ptr2 = NULL;
+	int i, ret = 0;
+
+	for (i = 0; i < ARRAY_SIZE(result_addr); i++) {
+		ptr = skip_spaces(ptr);
+		ptr2 = strchr(ptr, ' ');
+		if (ptr2)
+			*ptr2 = '\0';
+
+		ret = kstrtoul(ptr, 16, &result_addr[i]);
+		if (!ptr2)
+			break;
+
+		*ptr2 = ' ';
+
+		if (ret)
+			break;
+
+		ptr = ptr2 + 1;
+	}
+
+	*reg_addr = result_addr[0];
+	*val_expect = (u32) result_addr[1];
+	*val_mask = (u32) result_addr[2];
+
+	return ret;
+}
+
+/**
+ * __compare_item_init - init for compare attri. parse input string,
+ *                       and construct compare struct.
+ * @ppgroup: store the struct allocated, the struct contains items parsed from
+ *           input buf.
+ * @buf: input string,
+ *  eg: "0x01c20000 0x80000011 0x00000011,0x01c20004 0x0000c0a4 0x0000c0a0,...".
+ * @size: buf size.
+ *
+ * return 0 if success, otherwise failed.
+ */
+int __compare_item_init(struct compare_group **ppgroup,
+			       const char *buf, size_t size)
+{
+	char *ptr, *ptr2;
+	unsigned long addr = 0;
+	u32 val_expect = 0, val_mask = 0;
+	struct compare_group *pgroup = NULL;
+
+	/* alloc item buffer */
+	pgroup = kmalloc(sizeof(struct compare_group), GFP_KERNEL);
+	if (pgroup == NULL)
+		return -EINVAL;
+
+	pgroup->pitem = kmalloc(sizeof(struct compare_item) * MAX_COMPARE_ITEM,
+				GFP_KERNEL);
+	if (pgroup->pitem == NULL) {
+		kfree(pgroup);
+		return -EINVAL;
+	}
+
+	pgroup->num = 0;
+
+	/* get item from buf */
+	ptr = (char *)buf;
+	do {
+		ptr2 = strchr(ptr, ',');
+		if (ptr2)
+			*ptr2 = '\0';
+
+		if (!__parse_compare_str(ptr, &addr, &val_expect, &val_mask)) {
+			pgroup->pitem[pgroup->num].reg_addr = addr;
+			pgroup->pitem[pgroup->num].val_expect = val_expect;
+			pgroup->pitem[pgroup->num].val_mask = val_mask;
+			pgroup->num++;
+		} else
+			pr_err("%s: Failed to parse string: %s\n", __func__,
+			       ptr);
+
+		if (!ptr2)
+			break;
+
+		*ptr2 = ',';
+		ptr = ptr2 + 1;
+
+	} while (pgroup->num <= MAX_COMPARE_ITEM);
+
+	/* free buffer if no valid item */
+	if (pgroup->num == 0) {
+		kfree(pgroup->pitem);
+		kfree(pgroup);
+		return -EINVAL;
+	}
+	*ppgroup = pgroup;
+
+	return 0;
+}
+EXPORT_SYMBOL(__compare_item_init);
+
+/**
+ * __compare_item_deinit - reled_addrse memory that cred_addrted by
+ *                         __compare_item_init.
+ * @pgroup: the compare struct allocated in __compare_item_init.
+ */
+void __compare_item_deinit(struct compare_group *pgroup)
+{
+	if (pgroup) {
+		kfree(pgroup->pitem);
+		kfree(pgroup);
+	}
+}
+EXPORT_SYMBOL(__compare_item_deinit);
+
+/**
+ * dump_show - show func of dump attribute.
+ * @dev: class ptr.
+ * @attr: attribute ptr.
+ * @buf: the input buf which contain the start and end reg.
+ *       eg: "0x01c20000,0x01c20100\n".
+ *
+ * return size written to the buf, otherwise failed.
+ */
+static ssize_t
+dump_show(struct class *class, struct class_attribute *attr, char *buf)
+{
+	return __dump_regs_ex(&dump_para, buf, PAGE_SIZE);
+}
+
+static ssize_t
+dump_store(struct class *class, struct class_attribute *attr,
+	   const char *buf, size_t count)
+{
+	int index;
+	unsigned long start_reg = 0;
+	unsigned long end_reg = 0;
+
+	if (__parse_dump_str(buf, count, &start_reg, &end_reg)) {
+		pr_err("%s,%d err, invalid para!\n", __func__, __LINE__);
+		goto err;
+	}
+
+	index = __addr_valid(start_reg);
+	if ((index < 0) || (index != __addr_valid(end_reg))) {
+		pr_err("%s,%d err, invalid para!\n", __func__, __LINE__);
+		goto err;
+	}
+
+	dump_para.uaddr_start = start_reg;
+	dump_para.uaddr_end = end_reg;
+	pr_debug("%s,%d, start_reg:" PRINT_ADDR_FMT ", end_reg:" PRINT_ADDR_FMT
+		 "\n", __func__, __LINE__, start_reg, end_reg);
+
+	return count;
+
+err:
+	dump_para.uaddr_start = 0;
+	dump_para.uaddr_end = 0;
+
+	return -EINVAL;
+}
+
+static ssize_t
+write_show(struct class *class, struct class_attribute *attr, char *buf)
+{
+	/* display write result */
+	return __write_show(wt_group, buf, PAGE_SIZE);
+}
+
+static ssize_t
+write_store(struct class *class, struct class_attribute *attr,
+	    const char *buf, size_t count)
+{
+	int i;
+	int index;
+	unsigned long reg;
+	u32 val;
+	const struct dump_struct *dump;
+	struct dump_addr dump_addr;
+
+	/* free if not NULL */
+	if (wt_group) {
+		__write_item_deinit(wt_group);
+		wt_group = NULL;
+	}
+
+	/* parse input buf for items that will be dumped */
+	if (__write_item_init(&wt_group, buf, count) < 0)
+		return -EINVAL;
+
+	/**
+	 * write reg
+	 * it is better if the regs been remaped and unmaped only once,
+	 * but we map everytime for the range between min and max address
+	 * maybe too large.
+	 */
+	for (i = 0; i < wt_group->num; i++) {
+		reg = wt_group->pitem[i].reg_addr;
+		dump_addr.uaddr_start = reg;
+		val = wt_group->pitem[i].val;
+		index = __addr_valid(reg);
+		dump = &dump_table[index];
+		if (dump->remap)
+			dump_addr.vaddr_start = dump->remap(reg, 4);
+		else
+			dump_addr.vaddr_start = (void __iomem *)reg;
+		dump->write(val, dump->get_vaddr(&dump_addr, reg));
+		if (dump->unmap)
+			dump->unmap(dump_addr.vaddr_start);
+	}
+
+	return count;
+}
+
+static ssize_t
+compare_show(struct class *class, struct class_attribute *attr, char *buf)
+{
+	/* dump the items */
+	return __compare_regs_ex(cmp_group, buf, PAGE_SIZE);
+}
+
+static ssize_t
+compare_store(struct class *class, struct class_attribute *attr,
+	      const char *buf, size_t count)
+{
+	/* free if struct not null */
+	if (cmp_group) {
+		__compare_item_deinit(cmp_group);
+		cmp_group = NULL;
+	}
+
+	/* parse input buf for items that will be dumped */
+	if (__compare_item_init(&cmp_group, buf, count) < 0)
+		return -EINVAL;
+
+	return count;
+}
+
+static ssize_t
+rw_byte_show(struct class *class, struct class_attribute *attr, char *buf)
+{
+	return sprintf(buf, "read/write mode: %u(%s)\n", rw_byte_mode,
+		       rw_byte_mode ? "byte" : "word");
+}
+
+static ssize_t
+rw_byte_store(struct class *class, struct class_attribute *attr,
+	      const char *buf, size_t count)
+{
+	unsigned long value;
+	int ret;
+
+	ret = kstrtoul(buf, 10, &value);
+	if (!ret && (value > 1)) {
+		pr_err("%s,%d err, invalid para!\n", __func__, __LINE__);
+		goto out;
+	}
+	rw_byte_mode = value;
+out:
+	return count;
+}
+
+static ssize_t
+test_show(struct class *class, struct class_attribute *attr, char *buf)
+{
+	return sprintf(buf, "addr:0x%08x\nsize:0x%08x\n", test_addr, test_size);
+}
+
+static ssize_t
+help_show(struct class *class, struct class_attribute *attr, char *buf)
+{
+	const char *info =
+		"dump single register:          echo {addr} > dump; cat dump\n"
+		"dump multi  registers:         echo {start-addr},{end-addr} > dump; cat dump\n"
+		"write single register:         echo {addr} {val} > write; cat write\n"
+		"write multi  registers:        echo {addr1} {val1},{addr2} {val2},... > write; cat write\n"
+		"compare single register:       echo {addr} {expect-val} {mask} > compare; cat compare\n"
+		"compare multi  registers:      echo {addr1} {expect-val1} {mask1},{addr2} {expect-val2} {mask2},... > compare; cat compare\n"
+		"byte-access mode:              echo 1 > rw_byte\n"
+		"word-access mode (default):    echo 0 > rw_byte\n"
+		"show test address info:        cat test\n";
+	return sprintf(buf, info);
+}
+
+static struct class_attribute dump_class_attrs[] = {
+	__ATTR(dump,     S_IWUSR | S_IRUGO, dump_show,     dump_store),
+	__ATTR(write,    S_IWUSR | S_IRUGO, write_show,    write_store),
+	__ATTR(compare,  S_IWUSR | S_IRUGO, compare_show,  compare_store),
+	__ATTR(rw_byte,  S_IWUSR | S_IRUGO, rw_byte_show,  rw_byte_store),
+	__ATTR(test,     S_IRUGO,           test_show, NULL),
+	__ATTR(help,     S_IRUGO,           help_show, NULL),
+};
+
+static const struct of_device_id sunxi_dump_reg_match[] = {
+	{.compatible = "allwinner,sunxi-dump-reg", },
+	{}
+};
+MODULE_DEVICE_TABLE(of, sunxi_dump_reg_match);
+
+static int sunxi_dump_reg_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	struct device *dev = &pdev->dev;
+
+	int err;
+	int i;
+
+	/* sys/class/sunxi_dump */
+	dump_class = class_create(THIS_MODULE, "sunxi_dump");
+	if (IS_ERR(dump_class)) {
+		pr_err("%s:%u class_create() failed\n", __func__, __LINE__);
+		return PTR_ERR(dump_class);
+	}
+
+	/* sys/class/sunxi_dump/xxx */
+	for (i = 0; i < ARRAY_SIZE(dump_class_attrs); i++) {
+		err = class_create_file(dump_class, &dump_class_attrs[i]);
+		if (err) {
+			pr_err("%s:%u class_create_file() failed. err=%d\n", __func__, __LINE__, err);
+			while (i--) {
+				class_remove_file(dump_class, &dump_class_attrs[i]);
+			}
+			class_destroy(dump_class);
+			dump_class = NULL;
+			return err;
+		}
+	}
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!res) {
+		dev_err(dev, "Fail to get IORESOURCE_MEM \n");
+		goto error;
+	}
+
+	test_addr = res->start;
+	test_size = resource_size(res);
+
+	return 0;
+error:
+	dev_err(dev, "sunxi_dump_reg probe error\n");
+	return -1;
+}
+
+static int sunxi_dump_reg_remove(struct platform_device *pdev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(dump_class_attrs); i++) {
+		class_remove_file(dump_class, &dump_class_attrs[i]);
+	}
+
+	class_destroy(dump_class);
+	return 0;
+}
+
+static struct platform_driver sunxi_dump_reg_driver = {
+	.probe  = sunxi_dump_reg_probe,
+	.remove = sunxi_dump_reg_remove,
+	.driver = {
+		.name   = "dump_reg",
+		.owner  = THIS_MODULE,
+		.of_match_table = sunxi_dump_reg_match,
+	},
+};
+
+module_platform_driver(sunxi_dump_reg_driver);
+
+MODULE_ALIAS("dump reg driver");
+MODULE_ALIAS("platform:dump reg");
+MODULE_LICENSE("GPL v2");
+MODULE_VERSION("1.0.3");
+MODULE_AUTHOR("xiafeng <xiafeng@allwinnertech.com>");
+MODULE_AUTHOR("Martin <wuyan@allwinnertech.com>");
+MODULE_AUTHOR("liuyu <SWCliuyus@allwinnertech.com>");
+MODULE_DESCRIPTION("dump registers driver");
diff -Nuar -r --no-dereference linux-5.15.139/drivers/char/dump_reg/dump_reg_misc.c linux/drivers/char/dump_reg/dump_reg_misc.c
--- linux-5.15.139/drivers/char/dump_reg/dump_reg_misc.c	1970-01-01 08:00:00.000000000 +0800
+++ linux/drivers/char/dump_reg/dump_reg_misc.c	2024-01-03 16:06:25.935131000 +0800
@@ -0,0 +1,209 @@
+/*
+ * misc dump registers driver -
+ * User space application could use dump-reg functions through file operations
+ * (open/read/write/close) to the sysfs node created by this driver.
+ *
+ * Copyright(c) 2015-2018 Allwinnertech Co., Ltd.
+ *      http://www.allwinnertech.com
+ *
+ * Author: Liugang <liugang@allwinnertech.com>
+ *         Xiafeng <xiafeng@allwinnertech.com>
+ *         Martin  <wuyan@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/kdev_t.h>
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/slab.h>
+#include <linux/miscdevice.h>
+#include <linux/seq_file.h>
+#include "dump_reg.h"
+
+/* for dump_reg misc driver */
+static struct dump_addr misc_dump_para;
+static struct write_group *misc_wt_group;
+static struct compare_group *misc_cmp_group;
+
+static ssize_t
+misc_dump_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	return __dump_regs_ex(&misc_dump_para, buf, PAGE_SIZE);
+}
+
+static ssize_t
+misc_dump_store(struct device *dev, struct device_attribute *attr,
+		const char *buf, size_t size)
+{
+	int index;
+	unsigned long start_reg = 0;
+	unsigned long end_reg = 0;
+
+	if (__parse_dump_str(buf, size, &start_reg, &end_reg)) {
+		pr_err("%s,%d err, invalid para!\n", __func__, __LINE__);
+		goto err;
+	}
+
+	index = __addr_valid(start_reg);
+	if ((index < 0) || (index != __addr_valid(end_reg))) {
+		pr_err("%s,%d err, invalid para!\n", __func__, __LINE__);
+		goto err;
+	}
+
+	misc_dump_para.uaddr_start = start_reg;
+	misc_dump_para.uaddr_end = end_reg;
+	pr_debug("%s,%d, start_reg:" PRINT_ADDR_FMT ", end_reg:" PRINT_ADDR_FMT
+		 "\n", __func__, __LINE__, start_reg, end_reg);
+
+	return size;
+
+err:
+	misc_dump_para.uaddr_start = 0;
+	misc_dump_para.uaddr_end = 0;
+
+	return -EINVAL;
+}
+
+static ssize_t
+misc_write_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	/* display write result */
+	return __write_show(misc_wt_group, buf, PAGE_SIZE);
+}
+
+static ssize_t
+misc_write_store(struct device *dev, struct device_attribute *attr,
+		 const char *buf, size_t size)
+{
+	int i;
+	int index;
+	unsigned long reg;
+	u32 val;
+	const struct dump_struct *dump;
+	struct dump_addr dump_addr;
+
+	/* free if not NULL */
+	if (misc_wt_group) {
+		__write_item_deinit(misc_wt_group);
+		misc_wt_group = NULL;
+	}
+
+	/* parse input buf for items that will be dumped */
+	if (__write_item_init(&misc_wt_group, buf, size) < 0)
+		return -EINVAL;
+
+	/**
+	 * write reg
+	 * it is better if the regs been remaped and unmaped only once,
+	 * but we map everytime for the range between min and max address
+	 * maybe too large.
+	 */
+	for (i = 0; i < misc_wt_group->num; i++) {
+		reg = misc_wt_group->pitem[i].reg_addr;
+		dump_addr.uaddr_start = reg;
+		val = misc_wt_group->pitem[i].val;
+		index = __addr_valid(reg);
+		dump = &dump_table[index];
+		if (dump->remap)
+			dump_addr.vaddr_start = dump->remap(reg, 4);
+		else
+			dump_addr.vaddr_start = (void __iomem *)reg;
+		dump->write(val, dump->get_vaddr(&dump_addr, reg));
+		if (dump->unmap)
+			dump->unmap(dump_addr.vaddr_start);
+	}
+
+	return size;
+}
+
+static ssize_t
+misc_compare_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	/* dump the items */
+	return __compare_regs_ex(misc_cmp_group, buf, PAGE_SIZE);
+}
+
+static ssize_t
+misc_compare_store(struct device *dev, struct device_attribute *attr,
+		   const char *buf, size_t size)
+{
+	/* free if struct not null */
+	if (misc_cmp_group) {
+		__compare_item_deinit(misc_cmp_group);
+		misc_cmp_group = NULL;
+	}
+
+	/* parse input buf for items that will be dumped */
+	if (__compare_item_init(&misc_cmp_group, buf, size) < 0)
+		return -EINVAL;
+
+	return size;
+}
+
+static DEVICE_ATTR(dump, S_IWUSR | S_IRUGO, misc_dump_show, misc_dump_store);
+static DEVICE_ATTR(write, S_IWUSR | S_IRUGO, misc_write_show, misc_write_store);
+static DEVICE_ATTR(compare, S_IWUSR | S_IRUGO, misc_compare_show,
+		   misc_compare_store);
+
+static struct attribute *misc_attributes[] = {  /* files under '/sys/devices/virtual/misc/sunxi-reg/rw/' */
+	&dev_attr_dump.attr,
+	&dev_attr_write.attr,
+	&dev_attr_compare.attr,
+	NULL,
+};
+
+static struct attribute_group misc_attribute_group = {
+	.name = "rw",  /* directory: '/sys/devices/virtual/misc/sunxi-reg/rw/' */
+	.attrs = misc_attributes,
+};
+
+static struct miscdevice dump_reg_dev = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "sunxi-reg",  /* device node: '/dev/sunxi-reg' */
+};
+
+static int __init misc_dump_reg_init(void)
+{
+	int err;
+
+	pr_info("misc dump reg init\n");
+	err = misc_register(&dump_reg_dev);
+	if (err) {
+		pr_err("dump register driver as misc device error!\n");
+		goto exit;
+	}
+
+	err = sysfs_create_group(&dump_reg_dev.this_device->kobj,
+				 &misc_attribute_group);
+	if (err)
+		pr_err("dump register sysfs create group failed!\n");
+
+exit:
+	return err;
+}
+
+static void __exit misc_dump_reg_exit(void)
+{
+	pr_info("misc dump reg exit\n");
+
+	sysfs_remove_group(&(dump_reg_dev.this_device->kobj),
+			   &misc_attribute_group);
+	misc_deregister(&dump_reg_dev);
+}
+
+module_init(misc_dump_reg_init);
+module_exit(misc_dump_reg_exit);
+
+MODULE_ALIAS("misc dump reg driver");
+MODULE_LICENSE("GPL v2");
+MODULE_VERSION("1.0.1");
+MODULE_AUTHOR("xiafeng <xiafeng@allwinnertech.com>");
+MODULE_DESCRIPTION("misc dump registers driver");
diff -Nuar -r --no-dereference linux-5.15.139/drivers/char/dump_reg/Makefile linux/drivers/char/dump_reg/Makefile
--- linux-5.15.139/drivers/char/dump_reg/Makefile	1970-01-01 08:00:00.000000000 +0800
+++ linux/drivers/char/dump_reg/Makefile	2024-01-03 16:06:25.935131000 +0800
@@ -0,0 +1,2 @@
+obj-$(CONFIG_DUMP_REG) += dump_reg.o
+obj-$(CONFIG_DUMP_REG_MISC) += dump_reg_misc.o
diff -Nuar -r --no-dereference linux-5.15.139/drivers/char/dump_reg/Kconfig linux/drivers/char/dump_reg/Kconfig
--- linux-5.15.139/drivers/char/dump_reg/Kconfig	1970-01-01 08:00:00.000000000 +0800
+++ linux/drivers/char/dump_reg/Kconfig	2024-01-03 16:06:25.935131000 +0800
@@ -0,0 +1,21 @@
+#
+# dump reg config.
+#
+
+config DUMP_REG
+	tristate "dump reg driver for sunxi platform"
+	default y
+	help
+	  Say y here if you want to support dump regs module.
+	  The dump regs module is used to dump regs of any devices
+	  if you want it, When in doubt, say "Y".
+
+config DUMP_REG_MISC
+	tristate "dump reg misc driver"
+	depends on DUMP_REG
+	default y
+	help
+	  Add misc driver support, you can use dump regs function
+	  via ("/sys/class/...") sysfs interface.
+	  When in doubt, say "Y".
+
diff -Nuar -r --no-dereference linux-5.15.139/drivers/char/dump_reg/dump_reg.h linux/drivers/char/dump_reg/dump_reg.h
--- linux-5.15.139/drivers/char/dump_reg/dump_reg.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/drivers/char/dump_reg/dump_reg.h	2024-01-03 16:06:25.935131000 +0800
@@ -0,0 +1,132 @@
+/*
+ * dump registers head file
+ *
+ * (C) Copyright 2015-2018
+ * Reuuimlla Technology Co., Ltd. <www.reuuimllatech.com>
+ * Liugang <liugang@reuuimllatech.com>
+ * Xiafeng <xiafeng@allwinnertech.com>
+ * Martin  <wuyan@allwinnertech.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ */
+#ifndef _DUMP_REG_H_
+#define _DUMP_REG_H_
+
+/* BROM/SRAM/peripheral-registers space */
+#define SUNXI_IO_PHYS_START		(0x01000000UL)
+#define SUNXI_IO_PHYS_END		(SUNXI_IO_PHYS_START + SZ_128M + SZ_16M -1)
+
+/* DRAM space (Only map the first 1GB) */
+#define SUNXI_PLAT_PHYS_START		(0x40000000UL)
+#define SUNXI_PLAT_PHYS_END		(SUNXI_PLAT_PHYS_START + SZ_1G - 1)
+
+#if IS_ENABLED(CONFIG_ARM64)
+/* Virtual address space 1 */
+#define SUNXI_IOMEM_START		(0xffffff8000000000UL)
+#define SUNXI_IOMEM_END			(SUNXI_IOMEM_START + SZ_2G)
+/* Virtual address space 2 */
+#define SUNXI_MEM_PHYS_START		(0xffffffc000000000UL)
+#define SUNXI_MEM_PHYS_END		(SUNXI_MEM_PHYS_START + SZ_2G)
+/* Print format */
+#define PRINT_ADDR_FMT			"0x%016lx"
+#define CMP_PRINT_FMT                   "reg                 expect      actual      mask        result\n"
+#define WR_PRINT_FMT                    "reg                 to_write    after_write\n"
+#else
+/* Virtual address space 2 */
+#define SUNXI_MEM_PHYS_START		PAGE_OFFSET
+#define SUNXI_MEM_PHYS_END		(SUNXI_MEM_PHYS_START + SZ_1G - 1)
+/* Print format */
+#define PRINT_ADDR_FMT			"0x%08lx"
+#define CMP_PRINT_FMT                   "reg         expect      actual      mask        result\n"
+#define WR_PRINT_FMT                    "reg         to_write    after_write\n"
+#endif
+
+/* Item count */
+#define MAX_COMPARE_ITEM		64
+#define MAX_WRITE_ITEM			64
+
+struct dump_addr {
+	/* User specified address. Maybe physical or virtual address */
+	unsigned long uaddr_start;
+	unsigned long uaddr_end;
+	/* Virtual address */
+	void __iomem *vaddr_start;
+};
+
+struct dump_struct {
+	unsigned long addr_start;
+	unsigned long addr_end;
+	/* some registers' operate method maybe different */
+	void __iomem *(*remap)(unsigned long paddr, size_t size);
+	void (*unmap)(void __iomem *vaddr);
+	void __iomem *(*get_vaddr)(struct dump_addr *dump_addr, unsigned long uaddr);
+	 u32 (*read)(void __iomem *vaddr);
+	void (*write)(u32 val, void __iomem *vaddr);
+};
+
+/**
+ * compare_item - reg compare item struct
+ * @reg_addr:	reg address.
+ * @val_expect: expected value, provided by caller.
+ * @val_mask:   mask value, provided by caller. only mask bits will be compared.
+ */
+struct compare_item {
+	unsigned long reg_addr;
+	u32	val_expect;
+	u32	val_mask;
+};
+
+/**
+ * compare_group - reg compare group struct
+ * @num:	pitem element count. cannot exceed MAX_COMPARE_ITEM.
+ * @pitem:	items that will be compared, provided by caller.
+ */
+struct compare_group {
+	u32	num;
+	u32	reserve;
+	struct compare_item *pitem;
+};
+
+/**
+ * write_item - reg write item struct
+ * @reg_addr:	reg address.
+ * @val:	value to write
+ */
+struct write_item {
+	unsigned long reg_addr;
+	u32	val;
+	u32	reserve;
+};
+
+/**
+ * write_group - reg write group struct
+ * @num:	pitem element count. cannot exceed MAX_WRITE_ITEM.
+ * @pitem:	items that will be write, provided by caller.
+ */
+struct write_group {
+	u32	num;
+	u32	reserve;
+	struct write_item *pitem;
+};
+
+extern const struct dump_struct dump_table[4];
+
+int __addr_valid(unsigned long addr);
+ssize_t __dump_regs_ex(struct dump_addr *reg, char *buf, ssize_t len);
+int __parse_dump_str(const char *buf, size_t size,
+						unsigned long *start, unsigned long *end);
+ssize_t __write_show(struct write_group *pgroup, char *buf, ssize_t len);
+int  __write_item_init(struct write_group **ppgroup, const char *buf,
+						size_t size);
+void __write_item_deinit(struct write_group *pgroup);
+ssize_t __compare_regs_ex(struct compare_group *pgroup, char *buf,
+							ssize_t len);
+int  __compare_item_init(struct compare_group **ppgroup,
+						const char *buf, size_t size);
+void __compare_item_deinit(struct compare_group *pgroup);
+
+#endif /* _DUMP_REG_H_ */
diff -Nuar -r --no-dereference linux-5.15.139/drivers/phy/allwinner/phy-sun4i-usb.c linux/drivers/phy/allwinner/phy-sun4i-usb.c
--- linux-5.15.139/drivers/phy/allwinner/phy-sun4i-usb.c	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/phy/allwinner/phy-sun4i-usb.c	2024-01-03 16:06:25.935131000 +0800
@@ -34,6 +34,7 @@
 #include <linux/reset.h>
 #include <linux/spinlock.h>
 #include <linux/usb/of.h>
+#include <linux/usb/role.h>
 #include <linux/workqueue.h>
 
 #define REG_ISCR			0x00
@@ -43,7 +44,7 @@
 #define REG_PHYCTL_A33			0x10
 #define REG_PHY_OTGCTL			0x20
 
-#define REG_PMU_UNK1			0x10
+#define REG_HCI_PHY_CTL			0x10
 
 #define PHYCTL_DATA			BIT(7)
 
@@ -82,6 +83,7 @@
 /* A83T specific control bits for PHY0 */
 #define PHY_CTL_VBUSVLDEXT		BIT(5)
 #define PHY_CTL_SIDDQ			BIT(3)
+#define PHY_CTL_H3_SIDDQ		BIT(1)
 
 /* A83T specific control bits for PHY2 HSIC */
 #define SUNXI_EHCI_HS_FORCE		BIT(20)
@@ -115,10 +117,11 @@
 	int hsic_index;
 	enum sun4i_usb_phy_type type;
 	u32 disc_thresh;
+	u32 hci_phy_ctl_clear;
 	u8 phyctl_offset;
 	bool dedicated_clocks;
-	bool enable_pmu_unk1;
 	bool phy0_dual_route;
+	bool needs_phy2_siddq;
 	int missing_phys;
 };
 
@@ -151,6 +154,9 @@
 	int id_det;
 	int vbus_det;
 	struct delayed_work detect;
+	struct usb_role_switch_desc switch_desc;
+	struct usb_role_switch *role_switch;
+	int usb_role;
 };
 
 #define to_sun4i_usb_phy_data(phy) \
@@ -288,6 +294,12 @@
 		return ret;
 	}
 
+	if (phy->pmu && data->cfg->hci_phy_ctl_clear) {
+		val = readl(phy->pmu + REG_HCI_PHY_CTL);
+		val &= ~data->cfg->hci_phy_ctl_clear;
+		writel(val, phy->pmu + REG_HCI_PHY_CTL);
+	}
+
 	if (data->cfg->type == sun8i_a83t_phy ||
 	    data->cfg->type == sun50i_h6_phy) {
 		if (phy->index == 0) {
@@ -297,11 +309,6 @@
 			writel(val, data->base + data->cfg->phyctl_offset);
 		}
 	} else {
-		if (phy->pmu && data->cfg->enable_pmu_unk1) {
-			val = readl(phy->pmu + REG_PMU_UNK1);
-			writel(val & ~2, phy->pmu + REG_PMU_UNK1);
-		}
-
 		/* Enable USB 45 Ohm resistor calibration */
 		if (phy->index == 0)
 			sun4i_usb_phy_write(phy, PHY_RES45_CAL_EN, 0x01, 1);
@@ -329,6 +336,27 @@
 		queue_delayed_work(system_wq, &data->detect, 0);
 	}
 
+	/* Some PHYs on some SoCs need the help of PHY2 to work. */
+	if (data->cfg->needs_phy2_siddq && phy->index != 2) {
+		struct sun4i_usb_phy *phy2 = &data->phys[2];
+
+		/*
+		 * This extra clock is just needed to access the
+		 * REG_HCI_PHY_CTL PMU register for PHY2.
+		 */
+		ret = clk_prepare_enable(phy2->clk2);
+		if (ret)
+			return ret;
+
+		if (phy2->pmu && data->cfg->hci_phy_ctl_clear) {
+			val = readl(phy2->pmu + REG_HCI_PHY_CTL);
+			val &= ~data->cfg->hci_phy_ctl_clear;
+			writel(val, phy2->pmu + REG_HCI_PHY_CTL);
+		}
+
+		clk_disable_unprepare(phy->clk2);
+	}
+
 	return 0;
 }
 
@@ -362,6 +390,9 @@
 
 static int sun4i_usb_phy0_get_id_det(struct sun4i_usb_phy_data *data)
 {
+	if (data->usb_role >= 0)
+		return data->usb_role == USB_ROLE_HOST ? 0 : 1;
+
 	switch (data->dr_mode) {
 	case USB_DR_MODE_OTG:
 		if (data->id_det_gpio)
@@ -378,6 +409,9 @@
 
 static int sun4i_usb_phy0_get_vbus_det(struct sun4i_usb_phy_data *data)
 {
+	if (data->usb_role >= 0)
+		return data->usb_role == USB_ROLE_NONE ? 0 : 1;
+
 	if (data->vbus_det_gpio)
 		return gpiod_get_value_cansleep(data->vbus_det_gpio);
 
@@ -397,7 +431,7 @@
 
 static bool sun4i_usb_phy0_have_vbus_det(struct sun4i_usb_phy_data *data)
 {
-	return data->vbus_det_gpio || data->vbus_power_supply;
+	return data->usb_role >= 0 || data->vbus_det_gpio || data->vbus_power_supply;
 }
 
 static bool sun4i_usb_phy0_poll(struct sun4i_usb_phy_data *data)
@@ -657,6 +691,24 @@
 	return data->phys[args->args[0]].phy;
 }
 
+static int sun4i_usb_role_set(struct usb_role_switch *sw, enum usb_role role)
+{
+	struct sun4i_usb_phy_data *data = usb_role_switch_get_drvdata(sw);
+
+	data->usb_role = role;
+	queue_delayed_work(system_wq, &data->detect, 0);
+
+	return 0;
+}
+
+static enum usb_role sun4i_usb_role_get(struct usb_role_switch *sw)
+{
+	struct sun4i_usb_phy_data *data = usb_role_switch_get_drvdata(sw);
+	int role = sun4i_usb_phy0_get_id_det(data) ? USB_ROLE_DEVICE : USB_ROLE_HOST;
+
+	return data->usb_role >= 0 ? data->usb_role : role;
+}
+
 static int sun4i_usb_phy_remove(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
@@ -671,6 +723,8 @@
 
 	cancel_delayed_work_sync(&data->detect);
 
+	usb_role_switch_unregister(data->role_switch);
+
 	return 0;
 }
 
@@ -699,6 +753,8 @@
 	if (!data->cfg)
 		return -EINVAL;
 
+	data->usb_role = -1;
+
 	data->base = devm_platform_ioremap_resource_byname(pdev, "phy_ctrl");
 	if (IS_ERR(data->base))
 		return PTR_ERR(data->base);
@@ -706,14 +762,16 @@
 	data->id_det_gpio = devm_gpiod_get_optional(dev, "usb0_id_det",
 						    GPIOD_IN);
 	if (IS_ERR(data->id_det_gpio)) {
-		dev_err(dev, "Couldn't request ID GPIO\n");
+		dev_err_probe(dev, PTR_ERR(data->id_det_gpio),
+			      "Couldn't request ID GPIO\n");
 		return PTR_ERR(data->id_det_gpio);
 	}
 
 	data->vbus_det_gpio = devm_gpiod_get_optional(dev, "usb0_vbus_det",
 						      GPIOD_IN);
 	if (IS_ERR(data->vbus_det_gpio)) {
-		dev_err(dev, "Couldn't request VBUS detect GPIO\n");
+		dev_err_probe(dev, PTR_ERR(data->vbus_det_gpio),
+			      "Couldn't request VBUS detect GPIO\n");
 		return PTR_ERR(data->vbus_det_gpio);
 	}
 
@@ -721,7 +779,8 @@
 		data->vbus_power_supply = devm_power_supply_get_by_phandle(dev,
 						     "usb0_vbus_power-supply");
 		if (IS_ERR(data->vbus_power_supply)) {
-			dev_err(dev, "Couldn't get the VBUS power supply\n");
+			dev_err_probe(dev, PTR_ERR(data->vbus_power_supply),
+				      "Couldn't get the VBUS power supply\n");
 			return PTR_ERR(data->vbus_power_supply);
 		}
 
@@ -754,8 +813,8 @@
 		phy->vbus = devm_regulator_get_optional(dev, name);
 		if (IS_ERR(phy->vbus)) {
 			if (PTR_ERR(phy->vbus) == -EPROBE_DEFER) {
-				dev_err(dev,
-					"Couldn't get regulator %s... Deferring probe\n",
+				dev_err_probe(dev, PTR_ERR(phy->vbus),
+					"Couldn't get regulator %s\n",
 					name);
 				return -EPROBE_DEFER;
 			}
@@ -770,7 +829,8 @@
 
 		phy->clk = devm_clk_get(dev, name);
 		if (IS_ERR(phy->clk)) {
-			dev_err(dev, "failed to get clock %s\n", name);
+			dev_err_probe(dev, PTR_ERR(phy->clk),
+				      "failed to get clock %s\n", name);
 			return PTR_ERR(phy->clk);
 		}
 
@@ -783,10 +843,17 @@
 				dev_err(dev, "failed to get clock %s\n", name);
 				return PTR_ERR(phy->clk2);
 			}
+		} else {
+			snprintf(name, sizeof(name), "pmu%d_clk", i);
+			phy->clk2 = devm_clk_get_optional(dev, name);
+			if (IS_ERR(phy->clk2)) {
+				dev_err(dev, "failed to get clock %s\n", name);
+				return PTR_ERR(phy->clk2);
+			}
 		}
 
 		snprintf(name, sizeof(name), "usb%d_reset", i);
-		phy->reset = devm_reset_control_get(dev, name);
+		phy->reset = devm_reset_control_get_shared(dev, name);
 		if (IS_ERR(phy->reset)) {
 			dev_err(dev, "failed to get reset %s\n", name);
 			return PTR_ERR(phy->reset);
@@ -852,6 +919,23 @@
 		return PTR_ERR(phy_provider);
 	}
 
+	/* setup role switcher */
+	data->switch_desc.name = "usb0";
+	data->switch_desc.fwnode = dev_fwnode(dev);
+	data->switch_desc.set = sun4i_usb_role_set;
+	data->switch_desc.get = sun4i_usb_role_get;
+	data->switch_desc.driver_data = data;
+
+	/*
+	 * Don't interfere with the default behavior of this driver until
+	 * the consumer of the role switch uses the switch for the first time.
+	 */
+	data->role_switch = usb_role_switch_register(dev, &data->switch_desc);
+	if (IS_ERR(data->role_switch)) {
+		dev_warn(dev, "Unable to register Role Switch\n");
+		data->role_switch = NULL;
+	}
+
 	dev_dbg(dev, "successfully loaded\n");
 
 	return 0;
@@ -863,7 +947,6 @@
 	.disc_thresh = 3,
 	.phyctl_offset = REG_PHYCTL_A10,
 	.dedicated_clocks = false,
-	.enable_pmu_unk1 = false,
 };
 
 static const struct sun4i_usb_phy_cfg sun5i_a13_cfg = {
@@ -872,7 +955,6 @@
 	.disc_thresh = 2,
 	.phyctl_offset = REG_PHYCTL_A10,
 	.dedicated_clocks = false,
-	.enable_pmu_unk1 = false,
 };
 
 static const struct sun4i_usb_phy_cfg sun6i_a31_cfg = {
@@ -881,7 +963,6 @@
 	.disc_thresh = 3,
 	.phyctl_offset = REG_PHYCTL_A10,
 	.dedicated_clocks = true,
-	.enable_pmu_unk1 = false,
 };
 
 static const struct sun4i_usb_phy_cfg sun7i_a20_cfg = {
@@ -890,7 +971,6 @@
 	.disc_thresh = 2,
 	.phyctl_offset = REG_PHYCTL_A10,
 	.dedicated_clocks = false,
-	.enable_pmu_unk1 = false,
 };
 
 static const struct sun4i_usb_phy_cfg sun8i_a23_cfg = {
@@ -899,7 +979,6 @@
 	.disc_thresh = 3,
 	.phyctl_offset = REG_PHYCTL_A10,
 	.dedicated_clocks = true,
-	.enable_pmu_unk1 = false,
 };
 
 static const struct sun4i_usb_phy_cfg sun8i_a33_cfg = {
@@ -908,7 +987,6 @@
 	.disc_thresh = 3,
 	.phyctl_offset = REG_PHYCTL_A33,
 	.dedicated_clocks = true,
-	.enable_pmu_unk1 = false,
 };
 
 static const struct sun4i_usb_phy_cfg sun8i_a83t_cfg = {
@@ -925,7 +1003,7 @@
 	.disc_thresh = 3,
 	.phyctl_offset = REG_PHYCTL_A33,
 	.dedicated_clocks = true,
-	.enable_pmu_unk1 = true,
+	.hci_phy_ctl_clear = PHY_CTL_H3_SIDDQ,
 	.phy0_dual_route = true,
 };
 
@@ -935,7 +1013,7 @@
 	.disc_thresh = 3,
 	.phyctl_offset = REG_PHYCTL_A33,
 	.dedicated_clocks = true,
-	.enable_pmu_unk1 = true,
+	.hci_phy_ctl_clear = PHY_CTL_H3_SIDDQ,
 	.phy0_dual_route = true,
 };
 
@@ -945,7 +1023,7 @@
 	.disc_thresh = 3,
 	.phyctl_offset = REG_PHYCTL_A33,
 	.dedicated_clocks = true,
-	.enable_pmu_unk1 = true,
+	.hci_phy_ctl_clear = PHY_CTL_H3_SIDDQ,
 	.phy0_dual_route = true,
 };
 
@@ -955,7 +1033,7 @@
 	.disc_thresh = 3,
 	.phyctl_offset = REG_PHYCTL_A33,
 	.dedicated_clocks = true,
-	.enable_pmu_unk1 = true,
+	.hci_phy_ctl_clear = PHY_CTL_H3_SIDDQ,
 	.phy0_dual_route = true,
 };
 
@@ -969,6 +1047,17 @@
 	.missing_phys = BIT(1) | BIT(2),
 };
 
+static const struct sun4i_usb_phy_cfg sun50i_h616_cfg = {
+	.num_phys = 4,
+	.type = sun50i_h6_phy,
+	.disc_thresh = 3,
+	.phyctl_offset = REG_PHYCTL_A33,
+	.dedicated_clocks = true,
+	.phy0_dual_route = true,
+	.hci_phy_ctl_clear = PHY_CTL_SIDDQ,
+	.needs_phy2_siddq = true,
+};
+
 static const struct of_device_id sun4i_usb_phy_of_match[] = {
 	{ .compatible = "allwinner,sun4i-a10-usb-phy", .data = &sun4i_a10_cfg },
 	{ .compatible = "allwinner,sun5i-a13-usb-phy", .data = &sun5i_a13_cfg },
@@ -983,6 +1072,7 @@
 	{ .compatible = "allwinner,sun50i-a64-usb-phy",
 	  .data = &sun50i_a64_cfg},
 	{ .compatible = "allwinner,sun50i-h6-usb-phy", .data = &sun50i_h6_cfg },
+	{ .compatible = "allwinner,sun50i-h616-usb-phy", .data = &sun50i_h616_cfg },
 	{ },
 };
 MODULE_DEVICE_TABLE(of, sun4i_usb_phy_of_match);
diff -Nuar -r --no-dereference linux-5.15.139/drivers/phy/allwinner/phy-sun6i-mipi-dphy.c linux/drivers/phy/allwinner/phy-sun6i-mipi-dphy.c
--- linux-5.15.139/drivers/phy/allwinner/phy-sun6i-mipi-dphy.c	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/phy/allwinner/phy-sun6i-mipi-dphy.c	2024-01-03 16:06:25.935131000 +0800
@@ -92,6 +92,8 @@
 
 	struct phy				*phy;
 	struct phy_configure_opts_mipi_dphy	config;
+	
+	bool hw_preconfigured;
 };
 
 static int sun6i_dphy_init(struct phy *phy)
@@ -124,6 +126,11 @@
 	struct sun6i_dphy *dphy = phy_get_drvdata(phy);
 	u8 lanes_mask = GENMASK(dphy->config.lanes - 1, 0);
 
+	if (dphy->hw_preconfigured) {
+		dphy->hw_preconfigured = false;
+		return 0;
+	}
+
 	regmap_write(dphy->regs, SUN6I_DPHY_TX_CTL_REG,
 		     SUN6I_DPHY_TX_CTL_HS_TX_CLK_CONT);
 
@@ -254,11 +261,19 @@
 	struct phy_provider *phy_provider;
 	struct sun6i_dphy *dphy;
 	void __iomem *regs;
+	u32 fb_start;
+	int ret;
 
 	dphy = devm_kzalloc(&pdev->dev, sizeof(*dphy), GFP_KERNEL);
 	if (!dphy)
 		return -ENOMEM;
 
+	ret = of_property_read_u32_index(of_chosen, "p-boot,framebuffer-start", 0, &fb_start);
+	if (ret == 0) {
+		/* the display pipeline is already initialized by p-boot */
+		dphy->hw_preconfigured = true;
+	}
+
 	regs = devm_platform_ioremap_resource(pdev, 0);
 	if (IS_ERR(regs)) {
 		dev_err(&pdev->dev, "Couldn't map the DPHY encoder registers\n");
@@ -268,13 +283,15 @@
 	dphy->regs = devm_regmap_init_mmio_clk(&pdev->dev, "bus",
 					       regs, &sun6i_dphy_regmap_config);
 	if (IS_ERR(dphy->regs)) {
-		dev_err(&pdev->dev, "Couldn't create the DPHY encoder regmap\n");
+		dev_err_probe(&pdev->dev, PTR_ERR(dphy->regs),
+			      "Couldn't create the DPHY encoder regmap\n");
 		return PTR_ERR(dphy->regs);
 	}
 
 	dphy->reset = devm_reset_control_get_shared(&pdev->dev, NULL);
 	if (IS_ERR(dphy->reset)) {
-		dev_err(&pdev->dev, "Couldn't get our reset line\n");
+		dev_err_probe(&pdev->dev, PTR_ERR(dphy->reset),
+			      "Couldn't get our reset line\n");
 		return PTR_ERR(dphy->reset);
 	}
 
diff -Nuar -r --no-dereference linux-5.15.139/drivers/phy/allwinner/Kconfig linux/drivers/phy/allwinner/Kconfig
--- linux-5.15.139/drivers/phy/allwinner/Kconfig	2023-11-20 18:08:30.000000000 +0800
+++ linux/drivers/phy/allwinner/Kconfig	2024-01-03 16:06:25.935131000 +0800
@@ -12,6 +12,7 @@
 	depends on USB_SUPPORT
 	select GENERIC_PHY
 	select USB_COMMON
+	select USB_ROLE_SWITCH
 	help
 	  Enable this to support the transceiver that is part of Allwinner
 	  sunxi SoCs.
diff -Nuar -r --no-dereference linux-5.15.139/include/dt-bindings/clock/rk3399-cru.h linux/include/dt-bindings/clock/rk3399-cru.h
--- linux-5.15.139/include/dt-bindings/clock/rk3399-cru.h	2023-11-20 18:08:30.000000000 +0800
+++ linux/include/dt-bindings/clock/rk3399-cru.h	2024-01-03 16:06:25.935131000 +0800
@@ -125,6 +125,7 @@
 #define SCLK_DDRC			168
 #define SCLK_TESTCLKOUT1		169
 #define SCLK_TESTCLKOUT2		170
+#define SCLK_CIF_OUT_SRC		171
 
 #define DCLK_VOP0			180
 #define DCLK_VOP1			181
diff -Nuar -r --no-dereference linux-5.15.139/include/dt-bindings/clock/sun8i-h3-ccu.h linux/include/dt-bindings/clock/sun8i-h3-ccu.h
--- linux-5.15.139/include/dt-bindings/clock/sun8i-h3-ccu.h	2023-11-20 18:08:30.000000000 +0800
+++ linux/include/dt-bindings/clock/sun8i-h3-ccu.h	2024-01-03 16:06:25.935131000 +0800
@@ -126,7 +126,7 @@
 #define CLK_USB_OHCI1		93
 #define CLK_USB_OHCI2		94
 #define CLK_USB_OHCI3		95
-
+#define CLK_DRAM		96
 #define CLK_DRAM_VE		97
 #define CLK_DRAM_CSI		98
 #define CLK_DRAM_DEINTERLACE	99
diff -Nuar -r --no-dereference linux-5.15.139/include/dt-bindings/clock/sun8i-a83t-ccu.h linux/include/dt-bindings/clock/sun8i-a83t-ccu.h
--- linux-5.15.139/include/dt-bindings/clock/sun8i-a83t-ccu.h	2023-11-20 18:08:30.000000000 +0800
+++ linux/include/dt-bindings/clock/sun8i-a83t-ccu.h	2024-01-03 16:06:25.935131000 +0800
@@ -116,10 +116,9 @@
 #define CLK_USB_HSIC		79
 #define CLK_USB_HSIC_12M	80
 #define CLK_USB_OHCI0		81
-
+#define CLK_DRAM		82
 #define CLK_DRAM_VE		83
 #define CLK_DRAM_CSI		84
-
 #define CLK_TCON0		85
 #define CLK_TCON1		86
 #define CLK_CSI_MISC		87
@@ -130,7 +129,7 @@
 #define CLK_AVS			92
 #define CLK_HDMI		93
 #define CLK_HDMI_SLOW		94
-
+#define CLK_MBUS		95
 #define CLK_MIPI_DSI0		96
 #define CLK_MIPI_DSI1		97
 #define CLK_GPU_CORE		98
diff -Nuar -r --no-dereference linux-5.15.139/include/dt-bindings/clock/sun50i-a64-ccu.h linux/include/dt-bindings/clock/sun50i-a64-ccu.h
--- linux-5.15.139/include/dt-bindings/clock/sun50i-a64-ccu.h	2023-11-20 18:08:30.000000000 +0800
+++ linux/include/dt-bindings/clock/sun50i-a64-ccu.h	2024-01-03 16:06:25.935131000 +0800
@@ -113,7 +113,7 @@
 #define CLK_USB_OHCI0		91
 
 #define CLK_USB_OHCI1		93
-
+#define CLK_DRAM		94
 #define CLK_DRAM_VE		95
 #define CLK_DRAM_CSI		96
 #define CLK_DRAM_DEINTERLACE	97
diff -Nuar -r --no-dereference linux-5.15.139/include/linux/platform_data/cyttsp4.h linux/include/linux/platform_data/cyttsp4.h
--- linux-5.15.139/include/linux/platform_data/cyttsp4.h	2023-11-20 18:08:30.000000000 +0800
+++ linux/include/linux/platform_data/cyttsp4.h	2024-01-03 16:06:30.497361000 +0800
@@ -1,62 +0,0 @@
-/* SPDX-License-Identifier: GPL-2.0-only */
-/*
- * Header file for:
- * Cypress TrueTouch(TM) Standard Product (TTSP) touchscreen drivers.
- * For use with Cypress Txx3xx parts.
- * Supported parts include:
- * CY8CTST341
- * CY8CTMA340
- *
- * Copyright (C) 2009, 2010, 2011 Cypress Semiconductor, Inc.
- * Copyright (C) 2012 Javier Martinez Canillas <javier@dowhile0.org>
- *
- * Contact Cypress Semiconductor at www.cypress.com (kev@cypress.com)
- */
-#ifndef _CYTTSP4_H_
-#define _CYTTSP4_H_
-
-#define CYTTSP4_MT_NAME "cyttsp4_mt"
-#define CYTTSP4_I2C_NAME "cyttsp4_i2c_adapter"
-#define CYTTSP4_SPI_NAME "cyttsp4_spi_adapter"
-
-#define CY_TOUCH_SETTINGS_MAX 32
-
-struct touch_framework {
-	const uint16_t  *abs;
-	uint8_t         size;
-	uint8_t         enable_vkeys;
-} __packed;
-
-struct cyttsp4_mt_platform_data {
-	struct touch_framework *frmwrk;
-	unsigned short flags;
-	char const *inp_dev_name;
-};
-
-struct touch_settings {
-	const uint8_t *data;
-	uint32_t size;
-	uint8_t tag;
-} __packed;
-
-struct cyttsp4_core_platform_data {
-	int irq_gpio;
-	int rst_gpio;
-	int level_irq_udelay;
-	int (*xres)(struct cyttsp4_core_platform_data *pdata,
-		struct device *dev);
-	int (*init)(struct cyttsp4_core_platform_data *pdata,
-		int on, struct device *dev);
-	int (*power)(struct cyttsp4_core_platform_data *pdata,
-		int on, struct device *dev, atomic_t *ignore_irq);
-	int (*irq_stat)(struct cyttsp4_core_platform_data *pdata,
-		struct device *dev);
-	struct touch_settings *sett[CY_TOUCH_SETTINGS_MAX];
-};
-
-struct cyttsp4_platform_data {
-	struct cyttsp4_core_platform_data *core_pdata;
-	struct cyttsp4_mt_platform_data *mt_pdata;
-};
-
-#endif /* _CYTTSP4_H_ */
diff -Nuar -r --no-dereference linux-5.15.139/include/linux/power_supply.h linux/include/linux/power_supply.h
--- linux-5.15.139/include/linux/power_supply.h	2023-11-20 18:08:30.000000000 +0800
+++ linux/include/linux/power_supply.h	2024-01-03 16:06:25.935131000 +0800
@@ -159,6 +159,8 @@
 	POWER_SUPPLY_PROP_TIME_TO_FULL_NOW,
 	POWER_SUPPLY_PROP_TIME_TO_FULL_AVG,
 	POWER_SUPPLY_PROP_TYPE, /* use power_supply.type instead */
+	POWER_SUPPLY_PROP_USB_BC_ENABLED,
+	POWER_SUPPLY_PROP_USB_DCP_INPUT_CURRENT_LIMIT,
 	POWER_SUPPLY_PROP_USB_TYPE,
 	POWER_SUPPLY_PROP_SCOPE,
 	POWER_SUPPLY_PROP_PRECHARGE_CURRENT,
diff -Nuar -r --no-dereference linux-5.15.139/include/linux/devfreq.h linux/include/linux/devfreq.h
--- linux-5.15.139/include/linux/devfreq.h	2023-11-20 18:08:30.000000000 +0800
+++ linux/include/linux/devfreq.h	2024-01-03 16:06:25.935131000 +0800
@@ -240,6 +240,8 @@
 int update_devfreq(struct devfreq *devfreq);
 
 /* Helper functions for devfreq user device driver with OPP. */
+void devfreq_recommended_freq(struct devfreq *devfreq,
+			      unsigned long *freq, u32 flags);
 struct dev_pm_opp *devfreq_recommended_opp(struct device *dev,
 				unsigned long *freq, u32 flags);
 int devfreq_register_opp_notifier(struct device *dev,
diff -Nuar -r --no-dereference linux-5.15.139/include/linux/mfd/axp20x.h linux/include/linux/mfd/axp20x.h
--- linux-5.15.139/include/linux/mfd/axp20x.h	2023-11-20 18:08:30.000000000 +0800
+++ linux/include/linux/mfd/axp20x.h	2024-01-03 16:06:25.935131000 +0800
@@ -130,6 +130,7 @@
 
 /* Other DCDC regulator control registers are the same as AXP803 */
 #define AXP813_DCDC7_V_OUT		0x26
+#define AXP813_CHRG_CTRL3		0x35
 
 /* Interrupt */
 #define AXP152_IRQ1_EN			0x40
diff -Nuar -r --no-dereference linux-5.15.139/include/linux/mfd/sun4i-gpadc.h linux/include/linux/mfd/sun4i-gpadc.h
--- linux-5.15.139/include/linux/mfd/sun4i-gpadc.h	2023-11-20 18:08:30.000000000 +0800
+++ linux/include/linux/mfd/sun4i-gpadc.h	2024-01-03 16:06:25.935131000 +0800
@@ -14,7 +14,6 @@
 #define SUN4I_GPADC_CTRL0_ADC_CLK_SELECT		BIT(22)
 #define SUN4I_GPADC_CTRL0_ADC_CLK_DIVIDER(x)		((GENMASK(1, 0) & (x)) << 20)
 #define SUN4I_GPADC_CTRL0_FS_DIV(x)			((GENMASK(3, 0) & (x)) << 16)
-#define SUN4I_GPADC_CTRL0_T_ACQ(x)			(GENMASK(15, 0) & (x))
 
 #define SUN4I_GPADC_CTRL1				0x04
 
@@ -35,9 +34,9 @@
 #define SUN6I_GPADC_CTRL1_ADC_CHAN_SELECT(x)		(GENMASK(3, 0) & BIT(x))
 #define SUN6I_GPADC_CTRL1_ADC_CHAN_MASK			GENMASK(3, 0)
 
-/* TP_CTRL1 bits for sun8i SoCs */
-#define SUN8I_GPADC_CTRL1_CHOP_TEMP_EN			BIT(8)
-#define SUN8I_GPADC_CTRL1_GPADC_CALI_EN			BIT(7)
+/* TP_CTRL1 bits for A33 */
+#define SUN8I_A33_GPADC_CTRL1_CHOP_TEMP_EN		BIT(8)
+#define SUN8I_A33_GPADC_CTRL1_GPADC_CALI_EN		BIT(7)
 
 #define SUN4I_GPADC_CTRL2				0x08
 
@@ -48,9 +47,6 @@
 
 #define SUN4I_GPADC_CTRL3				0x0c
 
-#define SUN4I_GPADC_CTRL3_FILTER_EN			BIT(2)
-#define SUN4I_GPADC_CTRL3_FILTER_TYPE(x)		(GENMASK(1, 0) & (x))
-
 #define SUN4I_GPADC_TPR					0x18
 
 #define SUN4I_GPADC_TPR_TEMP_ENABLE			BIT(16)
@@ -81,12 +77,68 @@
 #define SUN4I_GPADC_TEMP_DATA				0x20
 #define SUN4I_GPADC_DATA				0x24
 
-#define SUN4I_GPADC_IRQ_FIFO_DATA			0
-#define SUN4I_GPADC_IRQ_TEMP_DATA			1
+#define SUN4I_GPADC_IRQ_FIFO_DATA			1
+#define SUN4I_GPADC_IRQ_TEMP_DATA			2
 
 /* 10s delay before suspending the IP */
 #define SUN4I_GPADC_AUTOSUSPEND_DELAY			10000
 
+/* SUNXI_THS COMMON REGISTERS + DEFINES */
+#define SUNXI_THS_CTRL0					0x00
+#define SUNXI_THS_CTRL2					0x40
+#define SUNXI_THS_INTC					0x44
+#define SUNXI_THS_STAT					0x48
+#define SUNXI_THS_FILTER				0x70
+#define SUNXI_THS_CDATA_0_1				0x74
+#define SUNXI_THS_CDATA_2_3				0x78
+#define SUNXI_THS_TDATA0				0x80
+#define SUNXI_THS_TDATA1				0x84
+#define SUNXI_THS_TDATA2				0x88
+#define SUNXI_THS_TDATA3				0x8c
+
+#define SUNXI_THS_FILTER_EN				BIT(2)
+#define SUNXI_THS_FILTER_TYPE(x)			(GENMASK(1, 0) & (x))
+#define SUNXI_THS_ACQ0(x)				(GENMASK(15, 0) & (x))
+#define SUNXI_THS_ACQ1(x)				(GENMASK(31, 16) & ((x) << 16))
+
+#define SUNXI_THS_TEMP_SENSE_EN0			BIT(0)
+#define SUNXI_THS_TEMP_SENSE_EN1			BIT(1)
+#define SUNXI_THS_TEMP_SENSE_EN2			BIT(2)
+#define SUNXI_THS_TEMP_SENSE_EN3			BIT(3)
+
+#define SUNXI_THS_TEMP_PERIOD(x)			(GENMASK(31, 12) & ((x) << 12))
+
+#define SUNXI_THS_INTS_ALARM_OFF_2			BIT(14)
+#define SUNXI_THS_INTS_ALARM_OFF_1			BIT(13)
+#define SUNXI_THS_INTS_ALARM_OFF_0			BIT(12)
+#define SUNXI_THS_INTS_TDATA_IRQ_3			BIT(11)
+#define SUNXI_THS_INTS_TDATA_IRQ_2			BIT(10)
+#define SUNXI_THS_INTS_TDATA_IRQ_1			BIT(9)
+#define SUNXI_THS_INTS_TDATA_IRQ_0			BIT(8)
+#define SUNXI_THS_INTS_SHUT_INT_3			BIT(7)
+#define SUNXI_THS_INTS_SHUT_INT_2			BIT(6)
+#define SUNXI_THS_INTS_SHUT_INT_1			BIT(5)
+#define SUNXI_THS_INTS_SHUT_INT_0			BIT(4)
+#define SUNXI_THS_INTS_ALARM_INT_3			BIT(3)
+#define SUNXI_THS_INTS_ALARM_INT_2			BIT(2)
+#define SUNXI_THS_INTS_ALARM_INT_1			BIT(1)
+#define SUNXI_THS_INTS_ALARM_INT_0			BIT(0)
+
+#define SUNXI_THS_INTC_TDATA_IRQ_EN3			BIT(11)
+#define SUNXI_THS_INTC_TDATA_IRQ_EN2			BIT(10)
+#define SUNXI_THS_INTC_TDATA_IRQ_EN1			BIT(9)
+#define SUNXI_THS_INTC_TDATA_IRQ_EN0			BIT(8)
+#define SUNXI_THS_INTC_SHUT_INT_EN3			BIT(7)
+#define SUNXI_THS_INTC_SHUT_INT_EN2			BIT(6)
+#define SUNXI_THS_INTC_SHUT_INT_EN1			BIT(5)
+#define SUNXI_THS_INTC_SHUT_INT_EN0			BIT(4)
+#define SUNXI_THS_INTC_ALARM_INT_EN3			BIT(3)
+#define SUNXI_THS_INTC_ALARM_INT_EN2			BIT(2)
+#define SUNXI_THS_INTC_ALARM_INT_EN1			BIT(1)
+#define SUNXI_THS_INTC_ALARM_INT_EN0			BIT(0)
+
+#define MAX_SENSOR_COUNT				4
+
 struct sun4i_gpadc_dev {
 	struct device			*dev;
 	struct regmap			*regmap;
diff -Nuar -r --no-dereference linux-5.15.139/include/linux/mfd/ac200.h linux/include/linux/mfd/ac200.h
--- linux-5.15.139/include/linux/mfd/ac200.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/include/linux/mfd/ac200.h	2024-01-03 16:06:25.935131000 +0800
@@ -0,0 +1,210 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * AC200 register list
+ *
+ * Copyright (C) 2019 Jernej Skrabec <jernej.skrabec@siol.net>
+ */
+
+#ifndef __LINUX_MFD_AC200_H
+#define __LINUX_MFD_AC200_H
+
+#include <linux/regmap.h>
+#include <linux/clk.h>
+
+/* interface registers (can be accessed from any page) */
+#define AC200_TWI_CHANGE_TO_RSB		0x3E
+#define AC200_TWI_PAD_DELAY		0xC4
+#define AC200_TWI_REG_ADDR_H		0xFE
+
+/* General registers */
+#define AC200_SYS_VERSION		0x0000
+#define AC200_SYS_CONTROL		0x0002
+#define AC200_SYS_IRQ_ENABLE		0x0004
+#define AC200_SYS_IRQ_STATUS		0x0006
+#define AC200_SYS_CLK_CTL		0x0008
+#define AC200_SYS_DLDO_OSC_CTL		0x000A
+#define AC200_SYS_PLL_CTL0		0x000C
+#define AC200_SYS_PLL_CTL1		0x000E
+#define AC200_SYS_AUDIO_CTL0		0x0010
+#define AC200_SYS_AUDIO_CTL1		0x0012
+#define AC200_SYS_EPHY_CTL0		0x0014
+#define AC200_SYS_EPHY_CTL1		0x0016
+#define AC200_SYS_TVE_CTL0		0x0018
+#define AC200_SYS_TVE_CTL1		0x001A
+
+/* Audio Codec registers */
+#define AC200_AC_SYS_CLK_CTL		0x2000
+#define AC200_SYS_MOD_RST		0x2002
+#define AC200_SYS_SAMP_CTL		0x2004
+#define AC200_I2S_CTL			0x2100
+#define AC200_I2S_CLK			0x2102
+#define AC200_I2S_FMT0			0x2104
+#define AC200_I2S_FMT1			0x2108
+#define AC200_I2S_MIX_SRC		0x2114
+#define AC200_I2S_MIX_GAIN		0x2116
+#define AC200_I2S_DACDAT_DVC		0x2118
+#define AC200_I2S_ADCDAT_DVC		0x211A
+#define AC200_AC_DAC_DPC		0x2200
+#define AC200_AC_DAC_MIX_SRC		0x2202
+#define AC200_AC_DAC_MIX_GAIN		0x2204
+#define AC200_DACA_OMIXER_CTRL		0x2220
+#define AC200_OMIXER_SR			0x2222
+#define AC200_LINEOUT_CTRL		0x2224
+#define AC200_AC_ADC_DPC		0x2300
+#define AC200_MBIAS_CTRL		0x2310
+#define AC200_ADC_MIC_CTRL		0x2320
+#define AC200_ADCMIXER_SR		0x2322
+#define AC200_ANALOG_TUNING0		0x232A
+#define AC200_ANALOG_TUNING1		0x232C
+#define AC200_AC_AGC_SEL		0x2480
+#define AC200_ADC_DAPLCTRL		0x2500
+#define AC200_ADC_DAPRCTRL		0x2502
+#define AC200_ADC_DAPLSTA		0x2504
+#define AC200_ADC_DAPRSTA		0x2506
+#define AC200_ADC_DAPLTL		0x2508
+#define AC200_ADC_DAPRTL		0x250A
+#define AC200_ADC_DAPLHAC		0x250C
+#define AC200_ADC_DAPLLAC		0x250E
+#define AC200_ADC_DAPRHAC		0x2510
+#define AC200_ADC_DAPRLAC		0x2512
+#define AC200_ADC_DAPLDT		0x2514
+#define AC200_ADC_DAPLAT		0x2516
+#define AC200_ADC_DAPRDT		0x2518
+#define AC200_ADC_DAPRAT		0x251A
+#define AC200_ADC_DAPNTH		0x251C
+#define AC200_ADC_DAPLHNAC		0x251E
+#define AC200_ADC_DAPLLNAC		0x2520
+#define AC200_ADC_DAPRHNAC		0x2522
+#define AC200_ADC_DAPRLNAC		0x2524
+#define AC200_AC_DAPHHPFC		0x2526
+#define AC200_AC_DAPLHPFC		0x2528
+#define AC200_AC_DAPOPT			0x252A
+#define AC200_AC_DAC_DAPCTRL		0x3000
+#define AC200_AC_DRC_HHPFC		0x3002
+#define AC200_AC_DRC_LHPFC		0x3004
+#define AC200_AC_DRC_CTRL		0x3006
+#define AC200_AC_DRC_LPFHAT		0x3008
+#define AC200_AC_DRC_LPFLAT		0x300A
+#define AC200_AC_DRC_RPFHAT		0x300C
+#define AC200_AC_DRC_RPFLAT		0x300E
+#define AC200_AC_DRC_LPFHRT		0x3010
+#define AC200_AC_DRC_LPFLRT		0x3012
+#define AC200_AC_DRC_RPFHRT		0x3014
+#define AC200_AC_DRC_RPFLRT		0x3016
+#define AC200_AC_DRC_LRMSHAT		0x3018
+#define AC200_AC_DRC_LRMSLAT		0x301A
+#define AC200_AC_DRC_RRMSHAT		0x301C
+#define AC200_AC_DRC_RRMSLAT		0x301E
+#define AC200_AC_DRC_HCT		0x3020
+#define AC200_AC_DRC_LCT		0x3022
+#define AC200_AC_DRC_HKC		0x3024
+#define AC200_AC_DRC_LKC		0x3026
+#define AC200_AC_DRC_HOPC		0x3028
+#define AC200_AC_DRC_LOPC		0x302A
+#define AC200_AC_DRC_HLT		0x302C
+#define AC200_AC_DRC_LLT		0x302E
+#define AC200_AC_DRC_HKI		0x3030
+#define AC200_AC_DRC_LKI		0x3032
+#define AC200_AC_DRC_HOPL		0x3034
+#define AC200_AC_DRC_LOPL		0x3036
+#define AC200_AC_DRC_HET		0x3038
+#define AC200_AC_DRC_LET		0x303A
+#define AC200_AC_DRC_HKE		0x303C
+#define AC200_AC_DRC_LKE		0x303E
+#define AC200_AC_DRC_HOPE		0x3040
+#define AC200_AC_DRC_LOPE		0x3042
+#define AC200_AC_DRC_HKN		0x3044
+#define AC200_AC_DRC_LKN		0x3046
+#define AC200_AC_DRC_SFHAT		0x3048
+#define AC200_AC_DRC_SFLAT		0x304A
+#define AC200_AC_DRC_SFHRT		0x304C
+#define AC200_AC_DRC_SFLRT		0x304E
+#define AC200_AC_DRC_MXGHS		0x3050
+#define AC200_AC_DRC_MXGLS		0x3052
+#define AC200_AC_DRC_MNGHS		0x3054
+#define AC200_AC_DRC_MNGLS		0x3056
+#define AC200_AC_DRC_EPSHC		0x3058
+#define AC200_AC_DRC_EPSLC		0x305A
+#define AC200_AC_DRC_HPFHGAIN		0x305E
+#define AC200_AC_DRC_HPFLGAIN		0x3060
+#define AC200_AC_DRC_BISTCR		0x3100
+#define AC200_AC_DRC_BISTST		0x3102
+
+/* TVE registers */
+#define AC200_TVE_CTL0			0x4000
+#define AC200_TVE_CTL1			0x4002
+#define AC200_TVE_MOD0			0x4004
+#define AC200_TVE_MOD1			0x4006
+#define AC200_TVE_DAC_CFG0		0x4008
+#define AC200_TVE_DAC_CFG1		0x400A
+#define AC200_TVE_YC_DELAY		0x400C
+#define AC200_TVE_YC_FILTER		0x400E
+#define AC200_TVE_BURST_FRQ0		0x4010
+#define AC200_TVE_BURST_FRQ1		0x4012
+#define AC200_TVE_FRONT_PORCH		0x4014
+#define AC200_TVE_BACK_PORCH		0x4016
+#define AC200_TVE_TOTAL_LINE		0x401C
+#define AC200_TVE_FIRST_ACTIVE		0x401E
+#define AC200_TVE_BLACK_LEVEL		0x4020
+#define AC200_TVE_BLANK_LEVEL		0x4022
+#define AC200_TVE_PLUG_EN		0x4030
+#define AC200_TVE_PLUG_IRQ_EN		0x4032
+#define AC200_TVE_PLUG_IRQ_STA		0x4034
+#define AC200_TVE_PLUG_STA		0x4038
+#define AC200_TVE_PLUG_DEBOUNCE		0x4040
+#define AC200_TVE_DAC_TEST		0x4042
+#define AC200_TVE_PLUG_PULSE_LEVEL	0x40F4
+#define AC200_TVE_PLUG_PULSE_START	0x40F8
+#define AC200_TVE_PLUG_PULSE_PERIOD	0x40FA
+#define AC200_TVE_IF_CTL		0x5000
+#define AC200_TVE_IF_TIM0		0x5008
+#define AC200_TVE_IF_TIM1		0x500A
+#define AC200_TVE_IF_TIM2		0x500C
+#define AC200_TVE_IF_TIM3		0x500E
+#define AC200_TVE_IF_SYNC0		0x5010
+#define AC200_TVE_IF_SYNC1		0x5012
+#define AC200_TVE_IF_SYNC2		0x5014
+#define AC200_TVE_IF_TIM4		0x5016
+#define AC200_TVE_IF_STATUS		0x5018
+
+/* EPHY registers */
+#define AC200_EPHY_CTL			0x6000
+#define AC200_EPHY_BIST			0x6002
+
+/* eFuse registers (0x8000 - 0x9FFF, layout unknown) */
+
+/* RTC registers */
+#define AC200_LOSC_CTRL0		0xA000
+#define AC200_LOSC_CTRL1		0xA002
+#define AC200_LOSC_AUTO_SWT_STA		0xA004
+#define AC200_INTOSC_CLK_PRESCAL	0xA008
+#define AC200_RTC_YY_MM_DD0		0xA010
+#define AC200_RTC_YY_MM_DD1		0xA012
+#define AC200_RTC_HH_MM_SS0		0xA014
+#define AC200_RTC_HH_MM_SS1		0xA016
+#define AC200_ALARM0_CUR_VLU0		0xA024
+#define AC200_ALARM0_CUR_VLU1		0xA026
+#define AC200_ALARM0_ENABLE		0xA028
+#define AC200_ALARM0_IRQ_EN		0xA02C
+#define AC200_ALARM0_IRQ_STA		0xA030
+#define AC200_ALARM1_WK_HH_MM_SS0	0xA040
+#define AC200_ALARM1_WK_HH_MM_SS1	0xA042
+#define AC200_ALARM1_ENABLE		0xA044
+#define AC200_ALARM1_IRQ_EN		0xA048
+#define AC200_ALARM1_IRQ_STA		0xA04C
+#define AC200_ALARM_CONFIG		0xA050
+#define AC200_LOSC_OUT_GATING		0xA060
+#define AC200_GP_DATA(x)		(0xA100 + (x) * 2)
+#define AC200_RTC_DEB			0xA170
+#define AC200_GPL_HOLD_OUTPUT		0xA180
+#define AC200_VDD_RTC			0xA190
+#define AC200_IC_CHARA0			0xA1F0
+#define AC200_IC_CHARA1			0xA1F2
+
+struct ac200_dev {
+	struct clk                    *clk;
+	struct regmap			*regmap;
+	struct regmap_irq_chip_data	*regmap_irqc;
+};
+
+#endif /* __LINUX_MFD_AC200_H */
diff -Nuar -r --no-dereference linux-5.15.139/include/linux/mfd/ac100.h linux/include/linux/mfd/ac100.h
--- linux-5.15.139/include/linux/mfd/ac100.h	2023-11-20 18:08:30.000000000 +0800
+++ linux/include/linux/mfd/ac100.h	2024-01-03 16:06:25.935131000 +0800
@@ -80,6 +80,7 @@
 #define AC100_ERPOUT_CTRL		0x57
 #define AC100_SPKOUT_CTRL		0x58
 #define AC100_LINEOUT_CTRL		0x59
+#define AC100_ADDA_TUNE1 		0x5a
 
 /* ADC digital audio processing (high pass filter & auto gain control */
 #define AC100_ADC_DAP_L_STA		0x80
diff -Nuar -r --no-dereference linux-5.15.139/include/linux/mfd/rk808.h linux/include/linux/mfd/rk808.h
--- linux-5.15.139/include/linux/mfd/rk808.h	2023-11-20 18:08:30.000000000 +0800
+++ linux/include/linux/mfd/rk808.h	2024-01-03 16:06:25.935131000 +0800
@@ -138,6 +138,8 @@
 	RK818_ID_OTG_SWITCH,
 };
 
+#define RK818_VB_MON_REG		0x21
+#define RK818_THERMAL_REG		0x22
 #define RK818_DCDC_EN_REG		0x23
 #define RK818_LDO_EN_REG		0x24
 #define RK818_SLEEP_SET_OFF_REG1	0x25
@@ -184,13 +186,90 @@
 #define RK818_INT_STS_REG2		0x4e
 #define RK818_INT_STS_MSK_REG2		0x4f
 #define RK818_IO_POL_REG		0x50
+#define RK818_OTP_VDD_EN_REG		0x51
 #define RK818_H5V_EN_REG		0x52
 #define RK818_SLEEP_SET_OFF_REG3	0x53
 #define RK818_BOOST_LDO9_ON_VSEL_REG	0x54
 #define RK818_BOOST_LDO9_SLP_VSEL_REG	0x55
 #define RK818_BOOST_CTRL_REG		0x56
-#define RK818_DCDC_ILMAX		0x90
+#define RK818_DCDC_ILMAX_REG		0x90
+#define RK818_CHRG_COMP_REG		0x9a
+#define RK818_SUP_STS_REG		0xa0
 #define RK818_USB_CTRL_REG		0xa1
+#define RK818_CHRG_CTRL_REG1		0xa3
+#define RK818_CHRG_CTRL_REG2		0xa4
+#define RK818_CHRG_CTRL_REG3		0xa5
+#define RK818_BAT_CTRL_REG		0xa6
+#define RK818_BAT_HTS_TS1_REG		0xa8
+#define RK818_BAT_LTS_TS1_REG		0xa9
+#define RK818_BAT_HTS_TS2_REG		0xaa
+#define RK818_BAT_LTS_TS2_REG		0xab
+#define RK818_TS_CTRL_REG		0xac
+#define RK818_ADC_CTRL_REG		0xad
+#define RK818_ON_SOURCE_REG		0xae
+#define RK818_OFF_SOURCE_REG		0xaf
+#define RK818_GGCON_REG			0xb0
+#define RK818_GGSTS_REG			0xb1
+#define RK818_FRAME_SMP_INTERV_REG	0xb2
+#define RK818_AUTO_SLP_CUR_THR_REG	0xb3
+#define RK818_GASCNT_CAL_REG3		0xb4
+#define RK818_GASCNT_CAL_REG2		0xb5
+#define RK818_GASCNT_CAL_REG1		0xb6
+#define RK818_GASCNT_CAL_REG0		0xb7
+#define RK818_GASCNT3_REG		0xb8
+#define RK818_GASCNT2_REG		0xb9
+#define RK818_GASCNT1_REG		0xba
+#define RK818_GASCNT0_REG		0xbb
+#define RK818_BAT_CUR_AVG_REGH		0xbc
+#define RK818_BAT_CUR_AVG_REGL		0xbd
+#define RK818_TS1_ADC_REGH		0xbe
+#define RK818_TS1_ADC_REGL		0xbf
+#define RK818_TS2_ADC_REGH		0xc0
+#define RK818_TS2_ADC_REGL		0xc1
+#define RK818_BAT_OCV_REGH		0xc2
+#define RK818_BAT_OCV_REGL		0xc3
+#define RK818_BAT_VOL_REGH		0xc4
+#define RK818_BAT_VOL_REGL		0xc5
+#define RK818_RELAX_ENTRY_THRES_REGH	0xc6
+#define RK818_RELAX_ENTRY_THRES_REGL	0xc7
+#define RK818_RELAX_EXIT_THRES_REGH	0xc8
+#define RK818_RELAX_EXIT_THRES_REGL	0xc9
+#define RK818_RELAX_VOL1_REGH		0xca
+#define RK818_RELAX_VOL1_REGL		0xcb
+#define RK818_RELAX_VOL2_REGH		0xcc
+#define RK818_RELAX_VOL2_REGL		0xcd
+#define RK818_BAT_CUR_R_CALC_REGH	0xce
+#define RK818_BAT_CUR_R_CALC_REGL	0xcf
+#define RK818_BAT_VOL_R_CALC_REGH	0xd0
+#define RK818_BAT_VOL_R_CALC_REGL	0xd1
+#define RK818_CAL_OFFSET_REGH		0xd2
+#define RK818_CAL_OFFSET_REGL		0xd3
+#define RK818_NON_ACT_TIMER_CNT_REG	0xd4
+#define RK818_VCALIB0_REGH		0xd5
+#define RK818_VCALIB0_REGL		0xd6
+#define RK818_VCALIB1_REGH		0xd7
+#define RK818_VCALIB1_REGL		0xd8
+#define RK818_IOFFSET_REGH		0xdd
+#define RK818_IOFFSET_REGL		0xde
+#define RK818_SOC_REG			0xe0
+#define RK818_REMAIN_CAP_REG3		0xe1
+#define RK818_REMAIN_CAP_REG2		0xe2
+#define RK818_REMAIN_CAP_REG1		0xe3
+#define RK818_REMAIN_CAP_REG0		0xe4
+#define RK818_UPDAT_LEVE_REG		0xe5
+#define RK818_NEW_FCC_REG3		0xe6
+#define RK818_NEW_FCC_REG2		0xe7
+#define RK818_NEW_FCC_REG1		0xe8
+#define RK818_NEW_FCC_REG0		0xe9
+#define RK818_NON_ACT_TIMER_CNT_SAVE_REG 0xea
+#define RK818_OCV_VOL_VALID_REG		0xeb
+#define RK818_REBOOT_CNT_REG		0xec
+#define RK818_POFFSET_REG		0xed
+#define RK818_MISC_MARK_REG		0xee
+#define RK818_HALT_CNT_REG		0xef
+#define RK818_CALC_REST_REGH		0xf0
+#define RK818_CALC_REST_REGL		0xf1
+#define RK818_SAVE_DATA19		0xf2
 
 #define RK818_H5V_EN			BIT(0)
 #define RK818_REF_RDY_CTRL		BIT(1)
@@ -373,6 +452,7 @@
 #define SWITCH2_EN	BIT(6)
 #define SWITCH1_EN	BIT(5)
 #define DEV_OFF_RST	BIT(3)
+#define DEV_RST		BIT(2)
 #define DEV_OFF		BIT(0)
 #define RTC_STOP	BIT(0)
 
@@ -381,6 +461,8 @@
 
 #define VOUT_LO_INT	BIT(0)
 #define CLK32KOUT2_EN	BIT(0)
+#define CLK32KOUT2_FUNC		(0 << 1)
+#define CLK32KOUT2_FUNC_MASK	BIT(1)
 
 #define TEMP115C			0x0c
 #define TEMP_HOTDIE_MSK			0x0c
@@ -701,5 +783,6 @@
 	long				variant;
 	const struct regmap_config	*regmap_cfg;
 	const struct regmap_irq_chip	*regmap_irq_chip;
+	struct notifier_block		*nb;
 };
 #endif /* __LINUX_REGULATOR_RK808_H */
diff -Nuar -r --no-dereference linux-5.15.139/include/linux/motorcomm_phy.h linux/include/linux/motorcomm_phy.h
--- linux-5.15.139/include/linux/motorcomm_phy.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/include/linux/motorcomm_phy.h	2024-01-03 16:06:25.935131000 +0800
@@ -0,0 +1,119 @@
+/*
+ * include/linux/motorcomm_phy.h
+ *
+ * Motorcomm PHY IDs
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+#ifndef _MOTORCOMM_PHY_H
+#define _MOTORCOMM_PHY_H
+
+#define MOTORCOMM_PHY_ID_MASK	0x00000fff
+#define MOTORCOMM_PHY_ID_8531_MASK	0xffffffff
+#define MOTORCOMM_MPHY_ID_MASK	0x0000ffff
+
+#define PHY_ID_YT8010		0x00000309
+#define PHY_ID_YT8510		0x00000109
+#define PHY_ID_YT8511		0x0000010a
+#define PHY_ID_YT8512		0x00000118
+#define PHY_ID_YT8512B		0x00000128
+#define PHY_ID_YT8521		0x0000011a
+#define PHY_ID_YT8531S		0x4f51e91a
+#define PHY_ID_YT8531		0x4f51e91b
+//#define PHY_ID_YT8614		0x0000e899
+#define PHY_ID_YT8618		0x0000e889
+
+#define REG_PHY_SPEC_STATUS		0x11
+#define REG_DEBUG_ADDR_OFFSET		0x1e
+#define REG_DEBUG_DATA			0x1f
+
+#define YT8512_EXTREG_AFE_PLL		0x50
+#define YT8512_EXTREG_EXTEND_COMBO	0x4000
+#define YT8512_EXTREG_LED0		0x40c0
+#define YT8512_EXTREG_LED1		0x40c3
+
+#define YT8512_EXTREG_SLEEP_CONTROL1	0x2027
+
+#define YT_SOFTWARE_RESET		0x8000
+
+#define YT8512_CONFIG_PLL_REFCLK_SEL_EN	0x0040
+#define YT8512_CONTROL1_RMII_EN		0x0001
+#define YT8512_LED0_ACT_BLK_IND		0x1000
+#define YT8512_LED0_DIS_LED_AN_TRY	0x0001
+#define YT8512_LED0_BT_BLK_EN		0x0002
+#define YT8512_LED0_HT_BLK_EN		0x0004
+#define YT8512_LED0_COL_BLK_EN		0x0008
+#define YT8512_LED0_BT_ON_EN		0x0010
+#define YT8512_LED1_BT_ON_EN		0x0010
+#define YT8512_LED1_TXACT_BLK_EN	0x0100
+#define YT8512_LED1_RXACT_BLK_EN	0x0200
+#define YT8512_SPEED_MODE		0xc000
+#define YT8512_DUPLEX			0x2000
+
+#define YT8512_SPEED_MODE_BIT		14
+#define YT8512_DUPLEX_BIT		13
+#define YT8512_EN_SLEEP_SW_BIT		15
+
+#define YT8521_EXTREG_SLEEP_CONTROL1	0x27
+#define YT8521_EN_SLEEP_SW_BIT		15
+
+#define YT8521_SPEED_MODE		0xc000
+#define YT8521_DUPLEX			0x2000
+#define YT8521_SPEED_MODE_BIT		14
+#define YT8521_DUPLEX_BIT		13
+#define YT8521_LINK_STATUS_BIT		10
+
+/* based on yt8521 wol config register */
+#define YTPHY_UTP_INTR_REG             0x12
+/* WOL Event Interrupt Enable */
+#define YTPHY_WOL_INTR            BIT(6)
+
+/* Magic Packet MAC address registers */
+#define YTPHY_MAGIC_PACKET_MAC_ADDR2                 0xa007
+#define YTPHY_MAGIC_PACKET_MAC_ADDR1                 0xa008
+#define YTPHY_MAGIC_PACKET_MAC_ADDR0                 0xa009
+
+#define YTPHY_WOL_CFG_REG		0xa00a
+#define YTPHY_WOL_CFG_TYPE		BIT(0)	/* WOL TYPE */
+#define YTPHY_WOL_CFG_EN		BIT(3)	/* WOL Enable */
+#define YTPHY_WOL_CFG_INTR_SEL	BIT(6)	/* WOL Event Interrupt Enable */
+#define YTPHY_WOL_CFG_WIDTH1	BIT(1)	/* WOL Pulse Width */
+#define YTPHY_WOL_CFG_WIDTH2	BIT(2)
+
+#define YTPHY_REG_SPACE_UTP             0
+#define YTPHY_REG_SPACE_FIBER           2
+
+enum ytphy_wol_type_e
+{
+    YTPHY_WOL_TYPE_LEVEL,
+    YTPHY_WOL_TYPE_PULSE,
+    YTPHY_WOL_TYPE_MAX
+};
+typedef enum ytphy_wol_type_e ytphy_wol_type_t;
+
+enum ytphy_wol_width_e
+{
+    YTPHY_WOL_WIDTH_84MS,
+    YTPHY_WOL_WIDTH_168MS,
+    YTPHY_WOL_WIDTH_336MS,
+    YTPHY_WOL_WIDTH_672MS,
+    YTPHY_WOL_WIDTH_MAX
+};
+typedef enum ytphy_wol_width_e ytphy_wol_width_t;
+
+struct ytphy_wol_cfg_s
+{
+    int enable;
+    int type;
+    int width;
+};
+typedef struct ytphy_wol_cfg_s ytphy_wol_cfg_t;
+
+#endif /* _MOTORCOMM_PHY_H */
+
+
diff -Nuar -r --no-dereference linux-5.15.139/include/linux/scpi_protocol.h linux/include/linux/scpi_protocol.h
--- linux-5.15.139/include/linux/scpi_protocol.h	2023-11-20 18:08:30.000000000 +0800
+++ linux/include/linux/scpi_protocol.h	2024-01-03 16:06:25.935131000 +0800
@@ -76,6 +76,7 @@
 	int (*sensor_get_value)(u16, u64 *);
 	int (*device_get_power_state)(u16);
 	int (*device_set_power_state)(u16, u8);
+	int (*sys_set_power_state)(u8);
 };
 
 #if IS_REACHABLE(CONFIG_ARM_SCPI_PROTOCOL)
diff -Nuar -r --no-dereference linux-5.15.139/include/linux/fb.h linux/include/linux/fb.h
--- linux-5.15.139/include/linux/fb.h	2023-11-20 18:08:30.000000000 +0800
+++ linux/include/linux/fb.h	2024-01-03 16:06:25.935131000 +0800
@@ -137,6 +137,11 @@
 /*      A display blank is requested       */
 #define FB_EVENT_BLANK                  0x09
 
+/*      A hardware display blank early change occured */
+#define FB_EARLY_EVENT_BLANK		0x10
+/*      A hardware display blank revert early change occured */
+#define FB_R_EARLY_EVENT_BLANK		0x11
+
 struct fb_event {
 	struct fb_info *info;
 	void *data;
diff -Nuar -r --no-dereference linux-5.15.139/include/generated/compile.h linux/include/generated/compile.h
--- linux-5.15.139/include/generated/compile.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/include/generated/compile.h	2024-01-03 16:16:45.691007000 +0800
@@ -0,0 +1,7 @@
+/* This file is auto generated, version 3 */
+/* SMP */
+#define UTS_MACHINE "aarch64"
+#define UTS_VERSION "#3 SMP Mon Nov 20 18:08:30 CST 2023"
+#define LINUX_COMPILE_BY "armbian"
+#define LINUX_COMPILE_HOST "next"
+#define LINUX_COMPILER "aarch64-linux-gnu-gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0, GNU ld (GNU Binutils for Ubuntu) 2.38"
diff -Nuar -r --no-dereference linux-5.15.139/include/generated/uapi/linux/version.h linux/include/generated/uapi/linux/version.h
--- linux-5.15.139/include/generated/uapi/linux/version.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/include/generated/uapi/linux/version.h	2024-01-03 15:02:55.659847000 +0800
@@ -0,0 +1,5 @@
+#define LINUX_VERSION_CODE 331659
+#define KERNEL_VERSION(a,b,c) (((a) << 16) + ((b) << 8) + ((c) > 255 ? 255 : (c)))
+#define LINUX_VERSION_MAJOR 5
+#define LINUX_VERSION_PATCHLEVEL 15
+#define LINUX_VERSION_SUBLEVEL 139
diff -Nuar -r --no-dereference linux-5.15.139/include/generated/asm-offsets.h linux/include/generated/asm-offsets.h
--- linux-5.15.139/include/generated/asm-offsets.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/include/generated/asm-offsets.h	2024-01-03 15:48:41.454788000 +0800
@@ -0,0 +1,102 @@
+#ifndef __ASM_OFFSETS_H__
+#define __ASM_OFFSETS_H__
+/*
+ * DO NOT MODIFY.
+ *
+ * This file was generated by Kbuild
+ */
+
+#define TSK_ACTIVE_MM 904 /* offsetof(struct task_struct, active_mm) */
+#define TSK_CPU 64 /* offsetof(struct task_struct, cpu) */
+
+#define TSK_TI_FLAGS 0 /* offsetof(struct task_struct, thread_info.flags) */
+#define TSK_TI_PREEMPT 8 /* offsetof(struct task_struct, thread_info.preempt_count) */
+#define TSK_STACK 24 /* offsetof(struct task_struct, stack) */
+#define TSK_STACK_CANARY 1088 /* offsetof(struct task_struct, stack_canary) */
+
+#define THREAD_CPU_CONTEXT 2416 /* offsetof(struct task_struct, thread.cpu_context) */
+#define THREAD_SCTLR_USER 3488 /* offsetof(struct task_struct, thread.sctlr_user) */
+#define THREAD_KEYS_USER 3384 /* offsetof(struct task_struct, thread.keys_user) */
+#define THREAD_KEYS_KERNEL 3464 /* offsetof(struct task_struct, thread.keys_kernel) */
+#define THREAD_MTE_CTRL 3480 /* offsetof(struct task_struct, thread.mte_ctrl) */
+
+#define S_X0 0 /* offsetof(struct pt_regs, regs[0]) */
+#define S_X2 16 /* offsetof(struct pt_regs, regs[2]) */
+#define S_X4 32 /* offsetof(struct pt_regs, regs[4]) */
+#define S_X6 48 /* offsetof(struct pt_regs, regs[6]) */
+#define S_X8 64 /* offsetof(struct pt_regs, regs[8]) */
+#define S_X10 80 /* offsetof(struct pt_regs, regs[10]) */
+#define S_X12 96 /* offsetof(struct pt_regs, regs[12]) */
+#define S_X14 112 /* offsetof(struct pt_regs, regs[14]) */
+#define S_X16 128 /* offsetof(struct pt_regs, regs[16]) */
+#define S_X18 144 /* offsetof(struct pt_regs, regs[18]) */
+#define S_X20 160 /* offsetof(struct pt_regs, regs[20]) */
+#define S_X22 176 /* offsetof(struct pt_regs, regs[22]) */
+#define S_X24 192 /* offsetof(struct pt_regs, regs[24]) */
+#define S_X26 208 /* offsetof(struct pt_regs, regs[26]) */
+#define S_X28 224 /* offsetof(struct pt_regs, regs[28]) */
+#define S_FP 232 /* offsetof(struct pt_regs, regs[29]) */
+#define S_LR 240 /* offsetof(struct pt_regs, regs[30]) */
+#define S_SP 248 /* offsetof(struct pt_regs, sp) */
+#define S_PSTATE 264 /* offsetof(struct pt_regs, pstate) */
+#define S_PC 256 /* offsetof(struct pt_regs, pc) */
+#define S_SYSCALLNO 280 /* offsetof(struct pt_regs, syscallno) */
+#define S_SDEI_TTBR1 288 /* offsetof(struct pt_regs, sdei_ttbr1) */
+#define S_PMR_SAVE 296 /* offsetof(struct pt_regs, pmr_save) */
+#define S_STACKFRAME 304 /* offsetof(struct pt_regs, stackframe) */
+#define PT_REGS_SIZE 336 /* sizeof(struct pt_regs) */
+
+#define COMPAT_SIGFRAME_REGS_OFFSET 32 /* offsetof(struct compat_sigframe, uc.uc_mcontext.arm_r0) */
+#define COMPAT_RT_SIGFRAME_REGS_OFFSET 160 /* offsetof(struct compat_rt_sigframe, sig.uc.uc_mcontext.arm_r0) */
+
+#define MM_CONTEXT_ID 736 /* offsetof(struct mm_struct, context.id.counter) */
+
+#define VMA_VM_MM 64 /* offsetof(struct vm_area_struct, vm_mm) */
+#define VMA_VM_FLAGS 80 /* offsetof(struct vm_area_struct, vm_flags) */
+
+#define VM_EXEC 4 /* VM_EXEC */
+
+#define PAGE_SZ 4096 /* PAGE_SIZE */
+
+#define DMA_TO_DEVICE 1 /* DMA_TO_DEVICE */
+#define DMA_FROM_DEVICE 2 /* DMA_FROM_DEVICE */
+
+#define PREEMPT_DISABLE_OFFSET 0 /* PREEMPT_DISABLE_OFFSET */
+#define SOFTIRQ_SHIFT 8 /* SOFTIRQ_SHIFT */
+#define IRQ_CPUSTAT_SOFTIRQ_PENDING 0 /* offsetof(irq_cpustat_t, __softirq_pending) */
+
+#define CPU_BOOT_TASK 0 /* offsetof(struct secondary_data, task) */
+
+#define FTR_OVR_VAL_OFFSET 0 /* offsetof(struct arm64_ftr_override, val) */
+#define FTR_OVR_MASK_OFFSET 8 /* offsetof(struct arm64_ftr_override, mask) */
+
+#define CPU_CTX_SP 104 /* offsetof(struct cpu_suspend_ctx, sp) */
+#define MPIDR_HASH_MASK 0 /* offsetof(struct mpidr_hash, mask) */
+#define MPIDR_HASH_SHIFTS 8 /* offsetof(struct mpidr_hash, shift_aff) */
+#define SLEEP_STACK_DATA_SYSTEM_REGS 0 /* offsetof(struct sleep_stack_data, system_regs) */
+#define SLEEP_STACK_DATA_CALLEE_REGS 112 /* offsetof(struct sleep_stack_data, callee_saved_regs) */
+#define ARM_SMCCC_RES_X0_OFFS 0 /* offsetof(struct arm_smccc_res, a0) */
+#define ARM_SMCCC_RES_X2_OFFS 16 /* offsetof(struct arm_smccc_res, a2) */
+#define ARM_SMCCC_QUIRK_ID_OFFS 0 /* offsetof(struct arm_smccc_quirk, id) */
+#define ARM_SMCCC_QUIRK_STATE_OFFS 8 /* offsetof(struct arm_smccc_quirk, state) */
+#define ARM_SMCCC_1_2_REGS_X0_OFFS 0 /* offsetof(struct arm_smccc_1_2_regs, a0) */
+#define ARM_SMCCC_1_2_REGS_X2_OFFS 16 /* offsetof(struct arm_smccc_1_2_regs, a2) */
+#define ARM_SMCCC_1_2_REGS_X4_OFFS 32 /* offsetof(struct arm_smccc_1_2_regs, a4) */
+#define ARM_SMCCC_1_2_REGS_X6_OFFS 48 /* offsetof(struct arm_smccc_1_2_regs, a6) */
+#define ARM_SMCCC_1_2_REGS_X8_OFFS 64 /* offsetof(struct arm_smccc_1_2_regs, a8) */
+#define ARM_SMCCC_1_2_REGS_X10_OFFS 80 /* offsetof(struct arm_smccc_1_2_regs, a10) */
+#define ARM_SMCCC_1_2_REGS_X12_OFFS 96 /* offsetof(struct arm_smccc_1_2_regs, a12) */
+#define ARM_SMCCC_1_2_REGS_X14_OFFS 112 /* offsetof(struct arm_smccc_1_2_regs, a14) */
+#define ARM_SMCCC_1_2_REGS_X16_OFFS 128 /* offsetof(struct arm_smccc_1_2_regs, a16) */
+
+#define HIBERN_PBE_ORIG 8 /* offsetof(struct pbe, orig_address) */
+#define HIBERN_PBE_ADDR 0 /* offsetof(struct pbe, address) */
+#define HIBERN_PBE_NEXT 16 /* offsetof(struct pbe, next) */
+#define ARM64_FTR_SYSVAL 24 /* offsetof(struct arm64_ftr_reg, sys_val) */
+
+#define TRAMP_VALIAS -4398084280320 /* TRAMP_VALIAS */
+#define PTRAUTH_USER_KEY_APIA 0 /* offsetof(struct ptrauth_keys_user, apia) */
+#define PTRAUTH_KERNEL_KEY_APIA 0 /* offsetof(struct ptrauth_keys_kernel, apia) */
+
+
+#endif
diff -Nuar -r --no-dereference linux-5.15.139/include/generated/timeconst.h linux/include/generated/timeconst.h
--- linux-5.15.139/include/generated/timeconst.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/include/generated/timeconst.h	2024-01-03 15:02:56.611868000 +0800
@@ -0,0 +1,40 @@
+/* Automatically generated by kernel/time/timeconst.bc */
+/* Time conversion constants for HZ == 250 */
+
+#ifndef KERNEL_TIMECONST_H
+#define KERNEL_TIMECONST_H
+
+#include <linux/param.h>
+#include <linux/types.h>
+
+#if HZ != 250
+#error "include/generated/timeconst.h has the wrong HZ value!"
+#endif
+
+#define HZ_TO_MSEC_MUL32	U64_C(0x80000000)
+#define HZ_TO_MSEC_ADJ32	U64_C(0x0)
+#define HZ_TO_MSEC_SHR32	29
+#define MSEC_TO_HZ_MUL32	U64_C(0x80000000)
+#define MSEC_TO_HZ_ADJ32	U64_C(0x180000000)
+#define MSEC_TO_HZ_SHR32	33
+#define HZ_TO_MSEC_NUM		4
+#define HZ_TO_MSEC_DEN		1
+#define MSEC_TO_HZ_NUM		1
+#define MSEC_TO_HZ_DEN		4
+
+#define HZ_TO_USEC_MUL32	U64_C(0xFA000000)
+#define HZ_TO_USEC_ADJ32	U64_C(0x0)
+#define HZ_TO_USEC_SHR32	20
+#define USEC_TO_HZ_MUL32	U64_C(0x83126E98)
+#define USEC_TO_HZ_ADJ32	U64_C(0x7FF7CED9168)
+#define USEC_TO_HZ_SHR32	43
+#define HZ_TO_USEC_NUM		4000
+#define HZ_TO_USEC_DEN		1
+#define USEC_TO_HZ_NUM		1
+#define USEC_TO_HZ_DEN		4000
+#define HZ_TO_NSEC_NUM		4000000
+#define HZ_TO_NSEC_DEN		1
+#define NSEC_TO_HZ_NUM		1
+#define NSEC_TO_HZ_DEN		4000000
+
+#endif /* KERNEL_TIMECONST_H */
diff -Nuar -r --no-dereference linux-5.15.139/include/generated/bounds.h linux/include/generated/bounds.h
--- linux-5.15.139/include/generated/bounds.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/include/generated/bounds.h	2024-01-03 15:02:56.647869000 +0800
@@ -0,0 +1,14 @@
+#ifndef __LINUX_BOUNDS_H__
+#define __LINUX_BOUNDS_H__
+/*
+ * DO NOT MODIFY.
+ *
+ * This file was generated by Kbuild
+ */
+
+#define NR_PAGEFLAGS 25 /* __NR_PAGEFLAGS */
+#define MAX_NR_ZONES 4 /* __MAX_NR_ZONES */
+#define NR_CPUS_BITS 3 /* ilog2(CONFIG_NR_CPUS) */
+#define SPINLOCK_SIZE 4 /* sizeof(spinlock_t) */
+
+#endif
diff -Nuar -r --no-dereference linux-5.15.139/include/generated/utsrelease.h linux/include/generated/utsrelease.h
--- linux-5.15.139/include/generated/utsrelease.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/include/generated/utsrelease.h	2024-01-03 15:02:55.687848000 +0800
@@ -0,0 +1 @@
+#define UTS_RELEASE "5.15.139-current-sunxi64"
diff -Nuar -r --no-dereference linux-5.15.139/include/generated/vdso-offsets.h linux/include/generated/vdso-offsets.h
--- linux-5.15.139/include/generated/vdso-offsets.h	1970-01-01 08:00:00.000000000 +0800
+++ linux/include/generated/vdso-offsets.h	2024-01-03 15:48:41.534785000 +0800
@@ -0,0 +1 @@
+#define vdso_offset_sigtramp 0x0790
